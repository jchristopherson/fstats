var tipuesearch = {"pages":[{"title":" FSTATS ","text":"FSTATS Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"anova_factor – FSTATS ","text":"type, public :: anova_factor Defines an ANOVA factor result. Contents Variables dof f_statistic probability sum_of_squares variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedome. real(kind=real64), public :: f_statistic The F-statistic. real(kind=real64), public :: probability The variance probability term. real(kind=real64), public :: sum_of_squares The sum of the squares. real(kind=real64), public :: variance The estimate of variance.","tags":"","loc":"type\\anova_factor.html"},{"title":"chi_squared_distribution – FSTATS ","text":"type, public, extends( distribution ) :: chi_squared_distribution Defines a Chi-squared distribution. Contents Variables dof Type-Bound Procedures cdf mean median mode pdf variance Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure, public :: cdf => cs_cdf interface private pure elemental module function cs_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a Chi-squared distribution is given as Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => cs_mean interface private pure module function cs_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => cs_median interface private pure module function cs_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => cs_mode interface private pure module function cs_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => cs_pdf interface private pure elemental module function cs_pdf(this, x) result(rst) Computes the probability density function. The PDF for a Chi-squared distribution is given as Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: variance => cs_variance interface private pure module function cs_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\chi_squared_distribution.html"},{"title":"convergence_info – FSTATS ","text":"type, public :: convergence_info Provides information regarding convergence status. Contents Variables converge_on_gradient converge_on_residual_parameter converge_on_solution_change function_evaluation_count gradient_value iteration_count reach_function_evaluation_limit reach_iteration_limit residual_value solution_change_value user_requested_stop Components Type Visibility Attributes Name Initial logical, public :: converge_on_gradient True if convergence on the gradient was achieved; else, false. logical, public :: converge_on_residual_parameter True if convergence on the residual error parameter was achieved; \nelse, false. logical, public :: converge_on_solution_change True if convergence on the change in solution was achieved; else,\nfalse. integer(kind=int32), public :: function_evaluation_count The function evaluation count. real(kind=real64), public :: gradient_value The value of the gradient test parameter. integer(kind=int32), public :: iteration_count The iteration count. logical, public :: reach_function_evaluation_limit True if the solution did not converge in the allowed number of\nfunction evaluations. logical, public :: reach_iteration_limit True if the solution did not converge in the allowed number of \niterations. real(kind=real64), public :: residual_value The value of the residual error parameter. real(kind=real64), public :: solution_change_value The value of the change in solution parameter. logical, public :: user_requested_stop True if the user requested the stop; else, false.","tags":"","loc":"type\\convergence_info.html"},{"title":"distribution – FSTATS ","text":"type, public, abstract :: distribution Defines a probability distribution. Contents Type-Bound Procedures cdf mean median mode pdf variance Type-Bound Procedures procedure( distribution_function ), public, deferred, pass :: cdf Computes the cumulative distribution function. pure elemental function distribution_function(this, x) result(rst) Prototype Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure( distribution_property ), public, deferred, pass :: mean Computes the mean of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_property ), public, deferred, pass :: median Computes the median of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_property ), public, deferred, pass :: mode Computes the mode of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_function ), public, deferred, pass :: pdf Computes the probability density function. pure elemental function distribution_function(this, x) result(rst) Prototype Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure( distribution_property ), public, deferred, pass :: variance Computes the variance of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value.","tags":"","loc":"type\\distribution.html"},{"title":"f_distribution – FSTATS ","text":"type, public, extends( distribution ) :: f_distribution Defines an F-distribution. Contents Variables d1 d2 Type-Bound Procedures cdf mean median mode pdf variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: d1 The measure of degrees of freedom for the first data set. real(kind=real64), public :: d2 The measure of degrees of freedom for the second data set. Type-Bound Procedures procedure, public :: cdf => fd_cdf interface private pure elemental module function fd_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a F distribution is given as Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => fd_mean interface private pure module function fd_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => fd_median interface private pure module function fd_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => fd_mode interface private pure module function fd_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => fd_pdf interface private pure elemental module function fd_pdf(this, x) result(rst) Computes the probability density function. The PDF for a F distribution is given as Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: variance => fd_variance interface private pure module function fd_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\f_distribution.html"},{"title":"iteration_controls – FSTATS ","text":"type, public :: iteration_controls Provides a collection of iteration control parameters. Contents Variables change_in_solution_tolerance gradient_tolerance iteration_improvement_tolerance max_function_evaluations max_iteration_between_updates max_iteration_count residual_tolerance Type-Bound Procedures set_to_default Components Type Visibility Attributes Name Initial real(kind=real64), public :: change_in_solution_tolerance Defines a tolerance on the change in parameter values. real(kind=real64), public :: gradient_tolerance Defines a tolerance on the gradient of the fitted function. real(kind=real64), public :: iteration_improvement_tolerance Defines a tolerance to ensure adequate improvement on each \niteration. integer(kind=int32), public :: max_function_evaluations Defines the maximum number of function evaluations allowed. integer(kind=int32), public :: max_iteration_between_updates Defines how many iterations can pass before a re-evaluation of \nthe Jacobian matrix is forced. integer(kind=int32), public :: max_iteration_count Defines the maximum number of iterations allowed. real(kind=real64), public :: residual_tolerance Defines a tolerance on the metric associated with the residual \nerror. Type-Bound Procedures procedure, public :: set_to_default => lm_set_default_tolerances interface private module subroutine lm_set_default_tolerances(x) Sets the object to its default values. Arguments Type Intent Optional Attributes Name class( iteration_controls ), intent(inout) :: x The iteration_controls object.","tags":"","loc":"type\\iteration_controls.html"},{"title":"lm_solver_options – FSTATS ","text":"type, public :: lm_solver_options Options to control the Levenberg-Marquardt solver. Contents Variables damping_decrease_factor damping_increase_factor finite_difference_step_size method Type-Bound Procedures set_to_default Components Type Visibility Attributes Name Initial real(kind=real64), public :: damping_decrease_factor The factor to use when decreasing the damping parameter. real(kind=real64), public :: damping_increase_factor The factor to use when increasing the damping parameter. real(kind=real64), public :: finite_difference_step_size The step size used for the finite difference calculations of the\nJacobian matrix. integer(kind=int32), public :: method The solver method to utilize.\n- FS_LEVENBERG_MARQUARDT_UPDATE:\n- FS_QUADRATIC_UPDATE:\n- FS_NIELSEN_UDPATE: Type-Bound Procedures procedure, public :: set_to_default => lm_set_default_settings interface private module subroutine lm_set_default_settings(x) Sets the object to its default values. Arguments Type Intent Optional Attributes Name class( lm_solver_options ), intent(inout) :: x The lm_solver_options object.","tags":"","loc":"type\\lm_solver_options.html"},{"title":"normal_distribution – FSTATS ","text":"type, public, extends( distribution ) :: normal_distribution Defines a normal distribution. Contents Variables mean_value standard_deviation Type-Bound Procedures cdf mean median mode pdf standardize variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure, public :: cdf => nd_cdf interface private pure elemental module function nd_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a normal distribution is given as Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => nd_mean interface private pure module function nd_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => nd_median interface private pure module function nd_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => nd_mode interface private pure module function nd_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => nd_pdf interface private pure elemental module function nd_pdf(this, x) result(rst) Computes the probability density function. The PDF for a normal distribution is given as . Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardize => nd_standardize interface private module subroutine nd_standardize(this) Standardizes the normal distribution to a mean of 0 and a \nstandard deviation of 1. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(inout) :: this The normal_distribution object. procedure, public :: variance => nd_variance interface private pure module function nd_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\normal_distribution.html"},{"title":"regression_statistics – FSTATS ","text":"type, public :: regression_statistics A container for regression-related statistical information. Contents Variables confidence_interval probability standard_error t_statistic Components Type Visibility Attributes Name Initial real(kind=real64), public :: confidence_interval The confidence interval for the parameter at the level \ndetermined by the regression process. real(kind=real64), public :: probability The probability that the coefficient is not statistically \nimportant.  A statistically important coefficient will have a \nlow probability (p-value), typically 0.05 or lower; however, a \np-value of up to ~0.2 may be acceptable dependent upon the \nproblem.  Typically any p-value larger than ~0.2 indicates the \nparameter is not statistically important for the model. real(kind=real64), public :: standard_error The standard error for the model coefficient. real(kind=real64), public :: t_statistic The T-statistic for the model coefficient.","tags":"","loc":"type\\regression_statistics.html"},{"title":"single_factor_anova_table – FSTATS ","text":"type, public :: single_factor_anova_table Defines a single-factor ANOVA results table. Contents Variables main_factor overall_mean total_dof total_sum_of_squares total_variance within_factor Components Type Visibility Attributes Name Initial type( anova_factor ), public :: main_factor The main, or main factor, results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within-treatement (error) results.","tags":"","loc":"type\\single_factor_anova_table.html"},{"title":"t_distribution – FSTATS ","text":"type, public, extends( distribution ) :: t_distribution Defines Student's T-Distribution. Contents Variables dof Type-Bound Procedures cdf mean median mode pdf variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure, public :: cdf => td_cdf interface private pure elemental module function td_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for Student's T-Distribution is given as where Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => td_mean interface private pure module function td_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => td_median interface private pure module function td_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => td_mode interface private pure module function td_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => td_pdf interface private pure elemental module function td_pdf(this, x) result(rst) Computes the probability density function. The PDF for Student's T-Distribution is given as Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: variance => td_variance interface private pure module function td_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\t_distribution.html"},{"title":"two_factor_anova_table – FSTATS ","text":"type, public :: two_factor_anova_table Defines a two-factor ANOVA results table. Contents Variables interaction main_factor_1 main_factor_2 overall_mean total_dof total_sum_of_squares total_variance within_factor Components Type Visibility Attributes Name Initial type( anova_factor ), public :: interaction The interaction effects. type( anova_factor ), public :: main_factor_1 The first main-factor results. type( anova_factor ), public :: main_factor_2 The second main-factor results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within (error) factor results.","tags":"","loc":"type\\two_factor_anova_table.html"},{"title":"adjusted_r_squared – FSTATS","text":"public interface adjusted_r_squared Computes the adjusted R-squared value for a data set. The adjusted R-squared provides a mechanism for tempering the effects\nof extra explanatory variables on the traditional R-squared \ncalculation.  It is computed by noting the sample size and \nthe number of variables . . See Also: Wikipedia Contents Module Procedures adjusted_r_squared_real64 adjusted_r_squared_real32 Module Procedures private  interface adjusted_r_squared_real64() Arguments None private  interface adjusted_r_squared_real32() Arguments None","tags":"","loc":"interface\\adjusted_r_squared.html"},{"title":"allan_variance – FSTATS","text":"public interface allan_variance Computes the Allan variance of a data set. Remarks This implementation computes the fully overlapped Allan variance \nusing the method presented by Yadav et. al. Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, \nViraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm \nfor Fully Overlapped Allan Variance and Total Variance for Analysis and \nModeling of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. \n10.1109/LSENS.2018.2829799. Contents Module Procedures allan_variance_1 Module Procedures private  interface allan_variance_1() Arguments None","tags":"","loc":"interface\\allan_variance.html"},{"title":"anova – FSTATS","text":"public interface anova Performs an analysis of variance (ANOVA) on the supplied data \nset. The following example illustrates a single-factor ANOVA on a \ndata set. program example use iso_fortran_env use fstats implicit none ! Local Variables character , parameter :: tab = achar ( 9 ) real ( real64 ) :: x ( 10 , 2 ) type ( single_factor_anova_table ) :: tbl ! Define the data x = reshape ( & [ & 3.086d3 , 3.082d3 , 3.069d3 , 3.072d3 , 3.045d3 , 3.070d3 , 3.079d3 , & 3.050d3 , 3.062d3 , 3.062d3 , 3.075d3 , 3.061d3 , 3.063d3 , 3.038d3 , & 3.070d3 , 3.062d3 , 3.070d3 , 3.049d3 , 3.042d3 , 3.063d3 & ], & [ 10 , 2 ] & ) ! Perform the ANOVA tbl = anova ( x ) ! Print out the table print '(A)' , \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" print '(AF2.0AF5.1AF5.1AF5.3AF5.3)' , \"Main Factor: \" // tab , & tbl % main_factor % dof , tab , & tbl % main_factor % sum_of_squares , tab // tab , & tbl % main_factor % variance , tab // tab , & tbl % main_factor % f_statistic , tab , & tbl % main_factor % probability print '(AF3.0AF6.1AF5.1)' , \"Within: \" // tab , & tbl % within_factor % dof , tab , & tbl % within_factor % sum_of_squares , tab // tab , & tbl % within_factor % variance print '(AF3.0AF6.1AF5.1)' , \"Total: \" // tab // tab , & tbl % total_dof , tab , & tbl % total_sum_of_squares , tab // tab , & tbl % total_variance print '(AF6.1)' , \"Overall Mean: \" , tbl % overall_mean end program The above program produces the following output. Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value\nMain Factor:    1.      352.8           352.8           2.147   0.160\nWithin:         18.     2958.2          164.3\nTotal:          19.     3311.0          174.3\nOverall Mean: 3063.5 See Also Wikipedia SPC Excel Single Factor ANOVA SPC Excel Gage R&R SPC Excel Understanding Regression Statistics NIST - Two Way ANOVA Contents Module Procedures anova_1_factor anova_2_factor anova_model_fit Module Procedures private  interface anova_1_factor() Arguments None private  interface anova_2_factor() Arguments None private  interface anova_model_fit() Arguments None","tags":"","loc":"interface\\anova.html"},{"title":"beta – FSTATS","text":"public interface beta Computes the beta function. The beta function is related to the gamma function\nby the following relationship. . See Also Wikipedia Contents Module Procedures beta_real64 beta_real32 Module Procedures private  interface beta_real64() Arguments None private  interface beta_real32() Arguments None","tags":"","loc":"interface\\beta.html"},{"title":"coefficient_matrix – FSTATS","text":"public interface coefficient_matrix Computes the coefficient matrix to the linear \nleast-squares regression problem of , where is the coefficient matrix computed here, is \nthe vector of coefficients to be determined, and is the \nvector of measured dependent variables. See Also Wikipedia Contents Module Procedures coefficient_matrix_real64 coefficient_matrix_real32 Module Procedures private  interface coefficient_matrix_real64() Arguments None private  interface coefficient_matrix_real32() Arguments None","tags":"","loc":"interface\\coefficient_matrix.html"},{"title":"confidence_interval – FSTATS","text":"public interface confidence_interval Computes the confidence interval for the specified distribution. See Also Wikipedia Contents Module Procedures confidence_interval_real64 confidence_interval_real32 confidence_interval_real64_array confidence_interval_real32_array Module Procedures private  interface confidence_interval_real64() Arguments None private  interface confidence_interval_real32() Arguments None private  interface confidence_interval_real64_array() Arguments None private  interface confidence_interval_real32_array() Arguments None","tags":"","loc":"interface\\confidence_interval.html"},{"title":"covariance_matrix – FSTATS","text":"public interface covariance_matrix Computes the covariance matrix where and is computed\nby coefficient_matrix. See Also Wikipedia Wikipedia - Regression Contents Module Procedures covariance_matrix_real64 covariance_matrix_real32 Module Procedures private  interface covariance_matrix_real64() Arguments None private  interface covariance_matrix_real32() Arguments None","tags":"","loc":"interface\\covariance_matrix.html"},{"title":"digamma – FSTATS","text":"public interface digamma Computes the digamma function. The digamma function is defined as: See Also Wikipedia Contents Module Procedures digamma_real64 digamma_real32 Module Procedures private  interface digamma_real64() Arguments None private  interface digamma_real32() Arguments None","tags":"","loc":"interface\\digamma.html"},{"title":"distribution_function – FSTATS","text":"interface public pure elemental function distribution_function(this, x) result(rst) Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. Description Defines the interface for a probability distribution function.","tags":"","loc":"interface\\distribution_function.html"},{"title":"distribution_property – FSTATS","text":"interface public pure function distribution_property(this) result(rst) Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. Description Computes the value of a distribution property.","tags":"","loc":"interface\\distribution_property.html"},{"title":"f_test – FSTATS","text":"public interface f_test Computes the F-test and returns the probability (two-tailed) that\nthe variances of two data sets are not significantly different. See Also Wikipedia Contents Module Procedures f_test_real64 f_test_real32 Module Procedures private  interface f_test_real64() Arguments None private  interface f_test_real32() Arguments None","tags":"","loc":"interface\\f_test.html"},{"title":"full_factorial – FSTATS","text":"public interface full_factorial Computes a table with values scaled from 1 to N describing a \nfull-factorial design. program example use iso_fortran_env use fstats implicit none ! Local Variables integer ( int32 ) :: i , vars ( 3 ), tbl ( 24 , 3 ) ! Define the number of design points for each of the 3 factors to study vars = [ 2 , 4 , 3 ] ! Determine the design table call full_factorial ( vars , tbl ) ! Display the table do i = 1 , size ( tbl , 1 ) print * , tbl ( i ,:) end do end program The above program produces the following output. 1           1           1\n1           1           2\n1           1           3\n1           2           1\n1           2           2\n1           2           3\n1           3           1\n1           3           2\n1           3           3\n1           4           1\n1           4           2\n1           4           3\n2           1           1\n2           1           2\n2           1           3\n2           2           1\n2           2           2\n2           2           3\n2           3           1\n2           3           2\n2           3           3\n2           4           1\n2           4           2\n2           4           3 Contents Module Procedures full_factorial_int32 Module Procedures private  interface full_factorial_int32() Arguments None","tags":"","loc":"interface\\full_factorial.html"},{"title":"get_full_factorial_matrix_size – FSTATS","text":"public interface get_full_factorial_matrix_size Computes the appropriate size for a full-factorial design table. Contents Module Procedures get_full_factorial_matrix_size_int32 Module Procedures private  interface get_full_factorial_matrix_size_int32() Arguments None","tags":"","loc":"interface\\get_full_factorial_matrix_size.html"},{"title":"incomplete_beta – FSTATS","text":"public interface incomplete_beta Computes the incomplete beta function. The incomplete beta function is defind as: . See Also Wikipedia Contents Module Procedures incomplete_beta_real64 incomplete_beta_real32 Module Procedures private  interface incomplete_beta_real64() Arguments None private  interface incomplete_beta_real32() Arguments None","tags":"","loc":"interface\\incomplete_beta.html"},{"title":"incomplete_gamma_lower – FSTATS","text":"public interface incomplete_gamma_lower Computes the lower incomplete gamma function. The lower incomplete gamma function is defined as: See Also Wikipedia Contents Module Procedures incomplete_gamma_lower_real64 incomplete_gamma_lower_real32 Module Procedures private  interface incomplete_gamma_lower_real64() Arguments None private  interface incomplete_gamma_lower_real32() Arguments None","tags":"","loc":"interface\\incomplete_gamma_lower.html"},{"title":"incomplete_gamma_upper – FSTATS","text":"public interface incomplete_gamma_upper Computes the upper incomplete gamma function. The upper incomplete gamma function is defined as: See Also Wikipedia Contents Module Procedures incomplete_gamma_upper_real64 incomplete_gamma_upper_real32 Module Procedures private  interface incomplete_gamma_upper_real64() Arguments None private  interface incomplete_gamma_upper_real32() Arguments None","tags":"","loc":"interface\\incomplete_gamma_upper.html"},{"title":"iteration_update – FSTATS","text":"interface public  subroutine iteration_update(iter, funvals, resid, params, step) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter real(kind=real64), intent(in) :: funvals (:) real(kind=real64), intent(in) :: resid (:) real(kind=real64), intent(in) :: params (:) real(kind=real64), intent(in) :: step (:)","tags":"","loc":"interface\\iteration_update.html"},{"title":"jacobian – FSTATS","text":"public interface jacobian Computes the Jacobian matrix for a nonlinear regression problem. Contents Module Procedures regression_jacobian_1 Module Procedures private  interface regression_jacobian_1() Arguments None","tags":"","loc":"interface\\jacobian.html"},{"title":"linear_least_squares – FSTATS","text":"public interface linear_least_squares Computes a linear least-squares regression to fit a set of data. See Also Wikipedia SPC Excel Understanding Regression Statistics Contents Module Procedures linear_least_squares_real64 linear_least_squares_real32 Module Procedures private  interface linear_least_squares_real64() Arguments None private  interface linear_least_squares_real32() Arguments None","tags":"","loc":"interface\\linear_least_squares.html"},{"title":"mean – FSTATS","text":"public interface mean Computes the mean of the values in an array. Contents Module Procedures mean_real64 mean_real32 Module Procedures private  interface mean_real64() Arguments None private  interface mean_real32() Arguments None","tags":"","loc":"interface\\mean.html"},{"title":"median – FSTATS","text":"public interface median Computes the median of the values in an array. Contents Module Procedures median_real64 median_real32 Module Procedures private  interface median_real64() Arguments None private  interface median_real32() Arguments None","tags":"","loc":"interface\\median.html"},{"title":"nonlinear_least_squares – FSTATS","text":"public interface nonlinear_least_squares Performs a nonlinear regression to fit a model using a version\nof the Levenberg-Marquardt algorithm. Contents Module Procedures nonlinear_least_squares_1 Module Procedures private  interface nonlinear_least_squares_1() Arguments None","tags":"","loc":"interface\\nonlinear_least_squares.html"},{"title":"quantile – FSTATS","text":"public interface quantile Computes the specified quantile of a data set using the SAS \nMethod 4. See Also Wikipedia Contents Module Procedures quantile_real64 quantile_real32 Module Procedures private  interface quantile_real64() Arguments None private  interface quantile_real32() Arguments None","tags":"","loc":"interface\\quantile.html"},{"title":"r_squared – FSTATS","text":"public interface r_squared Computes the R-squared value for a data set. The R-squared value is computed by determining the sum of the squares\nof the residuals: The total sum of the squares: . \nThe R-squared value is then: . See Also: Wikipedia Contents Module Procedures r_squared_real64 r_squared_real32 Module Procedures private  interface r_squared_real64() Arguments None private  interface r_squared_real32() Arguments None","tags":"","loc":"interface\\r_squared.html"},{"title":"regression_function – FSTATS","text":"interface public  subroutine regression_function(xdata, params, resid, stop) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xdata real(kind=real64), intent(in), dimension(:) :: params real(kind=real64), intent(out), dimension(:) :: resid logical, intent(out) :: stop","tags":"","loc":"interface\\regression_function.html"},{"title":"regularized_beta – FSTATS","text":"public interface regularized_beta Computes the regularized beta function. The regularized beta function is defined as the ratio between\nthe incomplete beta function and the beta function. . See Also Wikipedia Contents Module Procedures regularized_beta_real64 regularized_beta_real32 Module Procedures private  interface regularized_beta_real64() Arguments None private  interface regularized_beta_real32() Arguments None","tags":"","loc":"interface\\regularized_beta.html"},{"title":"standard_deviation – FSTATS","text":"public interface standard_deviation Computes the sample standard deviation of the values in an array. The value computed is the sample standard deviation. Contents Module Procedures standard_deviation_real64 standard_deviation_real32 Module Procedures private  interface standard_deviation_real64() Arguments None private  interface standard_deviation_real32() Arguments None","tags":"","loc":"interface\\standard_deviation.html"},{"title":"t_test_equal_variance – FSTATS","text":"public interface t_test_equal_variance Computes the 2-tailed Student's T-Test for two data sets of \nassumed equivalent variances. See Also Wikipedia Contents Module Procedures t_test_equal_var_real64 t_test_equal_var_real32 Module Procedures private  interface t_test_equal_var_real64() Arguments None private  interface t_test_equal_var_real32() Arguments None","tags":"","loc":"interface\\t_test_equal_variance.html"},{"title":"t_test_paired – FSTATS","text":"public interface t_test_paired Computes the 2-tailed Student's T-Test for two paired data sets. See Also Wikipedia Contents Module Procedures t_test_paired_real64 t_test_paired_real32 Module Procedures private  interface t_test_paired_real64() Arguments None private  interface t_test_paired_real32() Arguments None","tags":"","loc":"interface\\t_test_paired.html"},{"title":"t_test_unequal_variance – FSTATS","text":"public interface t_test_unequal_variance Computes the 2-tailed Student's T-Test for two data sets of \nassumed non-equivalent variances. See Also Wikipedia Contents Module Procedures t_test_unequal_var_real64 t_test_unequal_var_real32 Module Procedures private  interface t_test_unequal_var_real64() Arguments None private  interface t_test_unequal_var_real32() Arguments None","tags":"","loc":"interface\\t_test_unequal_variance.html"},{"title":"variance – FSTATS","text":"public interface variance Computes the sample variance of the values in an array. The variance computed is the sample variance such that the variance. Contents Module Procedures variance_real64 variance_real32 Module Procedures private  interface variance_real64() Arguments None private  interface variance_real32() Arguments None","tags":"","loc":"interface\\variance.html"},{"title":"report_array_size_error – FSTATS","text":"public  subroutine report_array_size_error(err, fname, name, expect, actual) @brief Reports an array size error. @param[in,out] err The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] name The name of the array.\n@param[in] expect The expected size of the array.\n@param[in] actual The actual size of the array. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: expect integer(kind=int32), intent(in) :: actual Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_arrays_not_same_size_error – FSTATS","text":"public  subroutine report_arrays_not_same_size_error(err, fname, name1, name2, size1, size2) @brief Reports an error relating to two arrays not being the same size\nwhen they should be the same size. @param[in,out] The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] name1 The name of the first array.\n@param[in] name2 The name of the second array.\n@param[in] size1 The size of the first array.\n@param[in] size2 The size of the second array. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 integer(kind=int32), intent(in) :: size1 integer(kind=int32), intent(in) :: size2 Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_arrays_not_same_size_error.html"},{"title":"report_iteration_count_error – FSTATS","text":"public  subroutine report_iteration_count_error(err, fname, msg, mincount) @brief Reports an iteration count error. @param[in,out] The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] msg The error message.\n@param[in] mincount The minimum iteration count expected. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*) :: fname character(len=*) :: msg integer(kind=int32), intent(in) :: mincount Contents Variables emsg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: emsg","tags":"","loc":"proc\\report_iteration_count_error.html"},{"title":"report_matrix_size_error – FSTATS","text":"public  subroutine report_matrix_size_error(err, fname, name, expect_rows, expect_cols, actual_rows, actual_cols) @brief Reports a matrix size error. @param[in,out] err The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] name The name of the matrix.\n@param[in] expect_rows The expected number of rows.\n@param[in] expect_cols The expected number of columns.\n@param[in] actual_rows The actual number of rows.\n@param[in] actual_cols The actual number of columns. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: expect_rows integer(kind=int32), intent(in) :: expect_cols integer(kind=int32), intent(in) :: actual_rows integer(kind=int32), intent(in) :: actual_cols Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – FSTATS","text":"public  subroutine report_memory_error(err, fname, code) @brief Reports a memory allocation related error. @param[in,out] err The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] code The error code returned by the allocation routine. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname integer(kind=int32), intent(in) :: code Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_underdefined_error – FSTATS","text":"public  subroutine report_underdefined_error(err, fname, expect, actual) @brief Reports an underdefined problem error. @param[in,out] The error handling object.\n@param[in] fname The name of the routine in which the error occurred.\n@param[in] expect The expected minimum number of equations.\n@param[in] actual The actual number of equations. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname integer(kind=int32), intent(in) :: expect integer(kind=int32), intent(in) :: actual Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_underdefined_error.html"},{"title":"fstats – FSTATS","text":"FSTATS is a modern Fortran statistical library containing routines for \ncomputing basic statistical properties, hypothesis testing, regression, \nspecial functions, and experimental design. Uses ferror iso_fortran_env Used by Descendants: allan distributions_chisquared distributions_f distributions_normal distributions_t experimental_design_implementation levenberg_marquardt regression_implementation special_functions_beta special_functions_digamma special_functions_gamma statistics_implementation Contents Variables FS_LEVENBERG_MARQUARDT_UPDATE FS_NIELSEN_UPDATE FS_QUADRATIC_UPDATE Interfaces adjusted_r_squared allan_variance anova beta coefficient_matrix confidence_interval covariance_matrix digamma distribution_function distribution_property f_test full_factorial get_full_factorial_matrix_size incomplete_beta incomplete_gamma_lower incomplete_gamma_upper iteration_update jacobian linear_least_squares mean median nonlinear_least_squares quantile r_squared regression_function regularized_beta standard_deviation t_test_equal_variance t_test_paired t_test_unequal_variance variance Derived Types anova_factor chi_squared_distribution convergence_info distribution f_distribution iteration_controls lm_solver_options normal_distribution regression_statistics single_factor_anova_table t_distribution two_factor_anova_table Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: FS_LEVENBERG_MARQUARDT_UPDATE = 1 integer(kind=int32), public, parameter :: FS_NIELSEN_UPDATE = 3 integer(kind=int32), public, parameter :: FS_QUADRATIC_UPDATE = 2 Interfaces public        interface adjusted_r_squared Computes the adjusted R-squared value for a data set. The adjusted R-squared provides a mechanism for tempering the effects\nof extra explanatory variables on the traditional R-squared \ncalculation.  It is computed by noting the sample size and \nthe number of variables . . See Also: Wikipedia private  interface adjusted_r_squared_real64() Arguments None private  interface adjusted_r_squared_real32() Arguments None public        interface allan_variance Computes the Allan variance of a data set. Remarks This implementation computes the fully overlapped Allan variance \nusing the method presented by Yadav et. al. Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, \nViraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm \nfor Fully Overlapped Allan Variance and Total Variance for Analysis and \nModeling of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. \n10.1109/LSENS.2018.2829799. private  interface allan_variance_1() Arguments None public        interface anova Performs an analysis of variance (ANOVA) on the supplied data \nset. The following example illustrates a single-factor ANOVA on a \ndata set. program example use iso_fortran_env use fstats implicit none ! Local Variables character , parameter :: tab = achar ( 9 ) real ( real64 ) :: x ( 10 , 2 ) type ( single_factor_anova_table ) :: tbl ! Define the data x = reshape ( & [ & 3.086d3 , 3.082d3 , 3.069d3 , 3.072d3 , 3.045d3 , 3.070d3 , 3.079d3 , & 3.050d3 , 3.062d3 , 3.062d3 , 3.075d3 , 3.061d3 , 3.063d3 , 3.038d3 , & 3.070d3 , 3.062d3 , 3.070d3 , 3.049d3 , 3.042d3 , 3.063d3 & ], & [ 10 , 2 ] & ) ! Perform the ANOVA tbl = anova ( x ) ! Print out the table print '(A)' , \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" print '(AF2.0AF5.1AF5.1AF5.3AF5.3)' , \"Main Factor: \" // tab , & tbl % main_factor % dof , tab , & tbl % main_factor % sum_of_squares , tab // tab , & tbl % main_factor % variance , tab // tab , & tbl % main_factor % f_statistic , tab , & tbl % main_factor % probability print '(AF3.0AF6.1AF5.1)' , \"Within: \" // tab , & tbl % within_factor % dof , tab , & tbl % within_factor % sum_of_squares , tab // tab , & tbl % within_factor % variance print '(AF3.0AF6.1AF5.1)' , \"Total: \" // tab // tab , & tbl % total_dof , tab , & tbl % total_sum_of_squares , tab // tab , & tbl % total_variance print '(AF6.1)' , \"Overall Mean: \" , tbl % overall_mean end program The above program produces the following output. Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value\nMain Factor:    1.      352.8           352.8           2.147   0.160\nWithin:         18.     2958.2          164.3\nTotal:          19.     3311.0          174.3\nOverall Mean: 3063.5 See Also Wikipedia SPC Excel Single Factor ANOVA SPC Excel Gage R&R SPC Excel Understanding Regression Statistics NIST - Two Way ANOVA private  interface anova_1_factor() Arguments None private  interface anova_2_factor() Arguments None private  interface anova_model_fit() Arguments None public        interface beta Computes the beta function. The beta function is related to the gamma function\nby the following relationship. . See Also Wikipedia private  interface beta_real64() Arguments None private  interface beta_real32() Arguments None public        interface coefficient_matrix Computes the coefficient matrix to the linear \nleast-squares regression problem of , where is the coefficient matrix computed here, is \nthe vector of coefficients to be determined, and is the \nvector of measured dependent variables. See Also Wikipedia private  interface coefficient_matrix_real64() Arguments None private  interface coefficient_matrix_real32() Arguments None public        interface confidence_interval Computes the confidence interval for the specified distribution. See Also Wikipedia private  interface confidence_interval_real64() Arguments None private  interface confidence_interval_real32() Arguments None private  interface confidence_interval_real64_array() Arguments None private  interface confidence_interval_real32_array() Arguments None public        interface covariance_matrix Computes the covariance matrix where and is computed\nby coefficient_matrix. See Also Wikipedia Wikipedia - Regression private  interface covariance_matrix_real64() Arguments None private  interface covariance_matrix_real32() Arguments None public        interface digamma Computes the digamma function. The digamma function is defined as: See Also Wikipedia private  interface digamma_real64() Arguments None private  interface digamma_real32() Arguments None interface public pure elemental function distribution_function(this, x) result(rst) Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. interface public pure function distribution_property(this) result(rst) Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. public        interface f_test Computes the F-test and returns the probability (two-tailed) that\nthe variances of two data sets are not significantly different. See Also Wikipedia private  interface f_test_real64() Arguments None private  interface f_test_real32() Arguments None public        interface full_factorial Computes a table with values scaled from 1 to N describing a \nfull-factorial design. program example use iso_fortran_env use fstats implicit none ! Local Variables integer ( int32 ) :: i , vars ( 3 ), tbl ( 24 , 3 ) ! Define the number of design points for each of the 3 factors to study vars = [ 2 , 4 , 3 ] ! Determine the design table call full_factorial ( vars , tbl ) ! Display the table do i = 1 , size ( tbl , 1 ) print * , tbl ( i ,:) end do end program The above program produces the following output. 1           1           1\n1           1           2\n1           1           3\n1           2           1\n1           2           2\n1           2           3\n1           3           1\n1           3           2\n1           3           3\n1           4           1\n1           4           2\n1           4           3\n2           1           1\n2           1           2\n2           1           3\n2           2           1\n2           2           2\n2           2           3\n2           3           1\n2           3           2\n2           3           3\n2           4           1\n2           4           2\n2           4           3 private  interface full_factorial_int32() Arguments None public        interface get_full_factorial_matrix_size Computes the appropriate size for a full-factorial design table. private  interface get_full_factorial_matrix_size_int32() Arguments None public        interface incomplete_beta Computes the incomplete beta function. The incomplete beta function is defind as: . See Also Wikipedia private  interface incomplete_beta_real64() Arguments None private  interface incomplete_beta_real32() Arguments None public        interface incomplete_gamma_lower Computes the lower incomplete gamma function. The lower incomplete gamma function is defined as: See Also Wikipedia private  interface incomplete_gamma_lower_real64() Arguments None private  interface incomplete_gamma_lower_real32() Arguments None public        interface incomplete_gamma_upper Computes the upper incomplete gamma function. The upper incomplete gamma function is defined as: See Also Wikipedia private  interface incomplete_gamma_upper_real64() Arguments None private  interface incomplete_gamma_upper_real32() Arguments None interface public  subroutine iteration_update(iter, funvals, resid, params, step) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter real(kind=real64), intent(in) :: funvals (:) real(kind=real64), intent(in) :: resid (:) real(kind=real64), intent(in) :: params (:) real(kind=real64), intent(in) :: step (:) public        interface jacobian Computes the Jacobian matrix for a nonlinear regression problem. private  interface regression_jacobian_1() Arguments None public        interface linear_least_squares Computes a linear least-squares regression to fit a set of data. See Also Wikipedia SPC Excel Understanding Regression Statistics private  interface linear_least_squares_real64() Arguments None private  interface linear_least_squares_real32() Arguments None public        interface mean Computes the mean of the values in an array. private  interface mean_real64() Arguments None private  interface mean_real32() Arguments None public        interface median Computes the median of the values in an array. private  interface median_real64() Arguments None private  interface median_real32() Arguments None public        interface nonlinear_least_squares Performs a nonlinear regression to fit a model using a version\nof the Levenberg-Marquardt algorithm. private  interface nonlinear_least_squares_1() Arguments None public        interface quantile Computes the specified quantile of a data set using the SAS \nMethod 4. See Also Wikipedia private  interface quantile_real64() Arguments None private  interface quantile_real32() Arguments None public        interface r_squared Computes the R-squared value for a data set. The R-squared value is computed by determining the sum of the squares\nof the residuals: The total sum of the squares: . \nThe R-squared value is then: . See Also: Wikipedia private  interface r_squared_real64() Arguments None private  interface r_squared_real32() Arguments None interface public  subroutine regression_function(xdata, params, resid, stop) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xdata real(kind=real64), intent(in), dimension(:) :: params real(kind=real64), intent(out), dimension(:) :: resid logical, intent(out) :: stop public        interface regularized_beta Computes the regularized beta function. The regularized beta function is defined as the ratio between\nthe incomplete beta function and the beta function. . See Also Wikipedia private  interface regularized_beta_real64() Arguments None private  interface regularized_beta_real32() Arguments None public        interface standard_deviation Computes the sample standard deviation of the values in an array. The value computed is the sample standard deviation. private  interface standard_deviation_real64() Arguments None private  interface standard_deviation_real32() Arguments None public        interface t_test_equal_variance Computes the 2-tailed Student's T-Test for two data sets of \nassumed equivalent variances. See Also Wikipedia private  interface t_test_equal_var_real64() Arguments None private  interface t_test_equal_var_real32() Arguments None public        interface t_test_paired Computes the 2-tailed Student's T-Test for two paired data sets. See Also Wikipedia private  interface t_test_paired_real64() Arguments None private  interface t_test_paired_real32() Arguments None public        interface t_test_unequal_variance Computes the 2-tailed Student's T-Test for two data sets of \nassumed non-equivalent variances. See Also Wikipedia private  interface t_test_unequal_var_real64() Arguments None private  interface t_test_unequal_var_real32() Arguments None public        interface variance Computes the sample variance of the values in an array. The variance computed is the sample variance such that the variance. private  interface variance_real64() Arguments None private  interface variance_real32() Arguments None Derived Types type, public :: anova_factor Defines an ANOVA factor result. Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedome. real(kind=real64), public :: f_statistic The F-statistic. real(kind=real64), public :: probability The variance probability term. real(kind=real64), public :: sum_of_squares The sum of the squares. real(kind=real64), public :: variance The estimate of variance. type, public, extends( distribution ) :: chi_squared_distribution Defines a Chi-squared distribution. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    cs_cdf Interface procedure\n                    ,                  public\n                  :: mean =>\n                    cs_mean Interface procedure\n                    ,                  public\n                  :: median =>\n                    cs_median Interface procedure\n                    ,                  public\n                  :: mode =>\n                    cs_mode Interface procedure\n                    ,                  public\n                  :: pdf =>\n                    cs_pdf Interface procedure\n                    ,                  public\n                  :: variance =>\n                    cs_variance Interface type, public :: convergence_info Provides information regarding convergence status. Components Type Visibility Attributes Name Initial logical, public :: converge_on_gradient True if convergence on the gradient was achieved; else, false. logical, public :: converge_on_residual_parameter True if convergence on the residual error parameter was achieved; \nelse, false. logical, public :: converge_on_solution_change True if convergence on the change in solution was achieved; else,\nfalse. integer(kind=int32), public :: function_evaluation_count The function evaluation count. real(kind=real64), public :: gradient_value The value of the gradient test parameter. integer(kind=int32), public :: iteration_count The iteration count. logical, public :: reach_function_evaluation_limit True if the solution did not converge in the allowed number of\nfunction evaluations. logical, public :: reach_iteration_limit True if the solution did not converge in the allowed number of \niterations. real(kind=real64), public :: residual_value The value of the residual error parameter. real(kind=real64), public :: solution_change_value The value of the change in solution parameter. logical, public :: user_requested_stop True if the user requested the stop; else, false. type, public :: distribution Defines a probability distribution. Type-Bound Procedures procedure\n(distribution_function)                    ,                  public\n, pass                  :: cdf Computes the cumulative distribution function. procedure\n(distribution_property)                    ,                  public\n, pass                  :: mean Computes the mean of the distribution. procedure\n(distribution_property)                    ,                  public\n, pass                  :: median Computes the median of the distribution. procedure\n(distribution_property)                    ,                  public\n, pass                  :: mode Computes the mode of the distribution. procedure\n(distribution_function)                    ,                  public\n, pass                  :: pdf Computes the probability density function. procedure\n(distribution_property)                    ,                  public\n, pass                  :: variance Computes the variance of the distribution. type, public, extends( distribution ) :: f_distribution Defines an F-distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: d1 The measure of degrees of freedom for the first data set. real(kind=real64), public :: d2 The measure of degrees of freedom for the second data set. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    fd_cdf Interface procedure\n                    ,                  public\n                  :: mean =>\n                    fd_mean Interface procedure\n                    ,                  public\n                  :: median =>\n                    fd_median Interface procedure\n                    ,                  public\n                  :: mode =>\n                    fd_mode Interface procedure\n                    ,                  public\n                  :: pdf =>\n                    fd_pdf Interface procedure\n                    ,                  public\n                  :: variance =>\n                    fd_variance Interface type, public :: iteration_controls Provides a collection of iteration control parameters. Components Type Visibility Attributes Name Initial real(kind=real64), public :: change_in_solution_tolerance Defines a tolerance on the change in parameter values. real(kind=real64), public :: gradient_tolerance Defines a tolerance on the gradient of the fitted function. real(kind=real64), public :: iteration_improvement_tolerance Defines a tolerance to ensure adequate improvement on each \niteration. integer(kind=int32), public :: max_function_evaluations Defines the maximum number of function evaluations allowed. integer(kind=int32), public :: max_iteration_between_updates Defines how many iterations can pass before a re-evaluation of \nthe Jacobian matrix is forced. integer(kind=int32), public :: max_iteration_count Defines the maximum number of iterations allowed. real(kind=real64), public :: residual_tolerance Defines a tolerance on the metric associated with the residual \nerror. Type-Bound Procedures procedure\n                    ,                  public\n                  :: set_to_default =>\n                    lm_set_default_tolerances Interface type, public :: lm_solver_options Options to control the Levenberg-Marquardt solver. Components Type Visibility Attributes Name Initial real(kind=real64), public :: damping_decrease_factor The factor to use when decreasing the damping parameter. real(kind=real64), public :: damping_increase_factor The factor to use when increasing the damping parameter. real(kind=real64), public :: finite_difference_step_size The step size used for the finite difference calculations of the\nJacobian matrix. integer(kind=int32), public :: method The solver method to utilize.\n- FS_LEVENBERG_MARQUARDT_UPDATE:\n- FS_QUADRATIC_UPDATE:\n- FS_NIELSEN_UDPATE: Type-Bound Procedures procedure\n                    ,                  public\n                  :: set_to_default =>\n                    lm_set_default_settings Interface type, public, extends( distribution ) :: normal_distribution Defines a normal distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    nd_cdf Interface procedure\n                    ,                  public\n                  :: mean =>\n                    nd_mean Interface procedure\n                    ,                  public\n                  :: median =>\n                    nd_median Interface procedure\n                    ,                  public\n                  :: mode =>\n                    nd_mode Interface procedure\n                    ,                  public\n                  :: pdf =>\n                    nd_pdf Interface procedure\n                    ,                  public\n                  :: standardize =>\n                    nd_standardize Interface procedure\n                    ,                  public\n                  :: variance =>\n                    nd_variance Interface type, public :: regression_statistics A container for regression-related statistical information. Components Type Visibility Attributes Name Initial real(kind=real64), public :: confidence_interval The confidence interval for the parameter at the level \ndetermined by the regression process. Read more… real(kind=real64), public :: probability The probability that the coefficient is not statistically \nimportant.  A statistically important coefficient will have a \nlow probability (p-value), typically 0.05 or lower; however, a \np-value of up to ~0.2 may be acceptable dependent upon the \nproblem.  Typically any p-value larger than ~0.2 indicates the \nparameter is not statistically important for the model. Read more… real(kind=real64), public :: standard_error The standard error for the model coefficient. Read more… real(kind=real64), public :: t_statistic The T-statistic for the model coefficient. Read more… type, public :: single_factor_anova_table Defines a single-factor ANOVA results table. Components Type Visibility Attributes Name Initial type( anova_factor ), public :: main_factor The main, or main factor, results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within-treatement (error) results. type, public, extends( distribution ) :: t_distribution Defines Student's T-Distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    td_cdf Interface procedure\n                    ,                  public\n                  :: mean =>\n                    td_mean Interface procedure\n                    ,                  public\n                  :: median =>\n                    td_median Interface procedure\n                    ,                  public\n                  :: mode =>\n                    td_mode Interface procedure\n                    ,                  public\n                  :: pdf =>\n                    td_pdf Interface procedure\n                    ,                  public\n                  :: variance =>\n                    td_variance Interface type, public :: two_factor_anova_table Defines a two-factor ANOVA results table. Components Type Visibility Attributes Name Initial type( anova_factor ), public :: interaction The interaction effects. type( anova_factor ), public :: main_factor_1 The first main-factor results. type( anova_factor ), public :: main_factor_2 The second main-factor results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within (error) factor results.","tags":"","loc":"module\\fstats.html"},{"title":"fstats_errors – FSTATS","text":"Uses ferror iso_fortran_env Contents Variables FS_ARRAY_SIZE_ERROR FS_INVALID_INPUT_ERROR FS_MATRIX_SIZE_ERROR FS_MEMORY_ERROR FS_NO_ERROR FS_TOLERANCE_TOO_SMALL_ERROR FS_TOO_FEW_ITERATION_ERROR FS_UNDERDEFINED_PROBLEM_ERROR Subroutines report_array_size_error report_arrays_not_same_size_error report_iteration_count_error report_matrix_size_error report_memory_error report_underdefined_error Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: FS_ARRAY_SIZE_ERROR = 10000 integer(kind=int32), public, parameter :: FS_INVALID_INPUT_ERROR = 10002 integer(kind=int32), public, parameter :: FS_MATRIX_SIZE_ERROR = 10001 integer(kind=int32), public, parameter :: FS_MEMORY_ERROR = 10003 integer(kind=int32), public, parameter :: FS_NO_ERROR = 0 integer(kind=int32), public, parameter :: FS_TOLERANCE_TOO_SMALL_ERROR = 10005 integer(kind=int32), public, parameter :: FS_TOO_FEW_ITERATION_ERROR = 10006 integer(kind=int32), public, parameter :: FS_UNDERDEFINED_PROBLEM_ERROR = 10004 Subroutines public  subroutine report_array_size_error (err, fname, name, expect, actual) @brief Reports an array size error. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: expect integer(kind=int32), intent(in) :: actual public  subroutine report_arrays_not_same_size_error (err, fname, name1, name2, size1, size2) @brief Reports an error relating to two arrays not being the same size\nwhen they should be the same size. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name1 character(len=*), intent(in) :: name2 integer(kind=int32), intent(in) :: size1 integer(kind=int32), intent(in) :: size2 public  subroutine report_iteration_count_error (err, fname, msg, mincount) @brief Reports an iteration count error. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*) :: fname character(len=*) :: msg integer(kind=int32), intent(in) :: mincount public  subroutine report_matrix_size_error (err, fname, name, expect_rows, expect_cols, actual_rows, actual_cols) @brief Reports a matrix size error. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname character(len=*), intent(in) :: name integer(kind=int32), intent(in) :: expect_rows integer(kind=int32), intent(in) :: expect_cols integer(kind=int32), intent(in) :: actual_rows integer(kind=int32), intent(in) :: actual_cols public  subroutine report_memory_error (err, fname, code) @brief Reports a memory allocation related error. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname integer(kind=int32), intent(in) :: code public  subroutine report_underdefined_error (err, fname, expect, actual) @brief Reports an underdefined problem error. Read more… Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err character(len=*), intent(in) :: fname integer(kind=int32), intent(in) :: expect integer(kind=int32), intent(in) :: actual","tags":"","loc":"module\\fstats_errors.html"},{"title":"allan – FSTATS","text":"Uses fstats_errors Ancestors: fstats Contents None","tags":"","loc":"module\\allan.html"},{"title":"distributions_chisquared – FSTATS","text":"Uses Ancestors: fstats Contents None","tags":"","loc":"module\\distributions_chisquared.html"},{"title":"distributions_f – FSTATS","text":"Uses ieee_arithmetic Ancestors: fstats Contents None","tags":"","loc":"module\\distributions_f.html"},{"title":"distributions_normal – FSTATS","text":"Uses Ancestors: fstats Contents None","tags":"","loc":"module\\distributions_normal.html"},{"title":"distributions_t – FSTATS","text":"Uses ieee_arithmetic Ancestors: fstats Contents None","tags":"","loc":"module\\distributions_t.html"},{"title":"experimental_design_implementation – FSTATS","text":"Uses fstats_errors Ancestors: fstats Contents None","tags":"","loc":"module\\experimental_design_implementation.html"},{"title":"levenberg_marquardt – FSTATS","text":"Uses linalg fstats_errors Ancestors: fstats Contents None","tags":"","loc":"module\\levenberg_marquardt.html"},{"title":"regression_implementation – FSTATS","text":"Uses linalg fstats_errors Ancestors: fstats Contents None","tags":"","loc":"module\\regression_implementation.html"},{"title":"special_functions_beta – FSTATS","text":"Uses Ancestors: fstats Contents None","tags":"","loc":"module\\special_functions_beta.html"},{"title":"special_functions_digamma – FSTATS","text":"Uses ieee_arithmetic Ancestors: fstats Contents None","tags":"","loc":"module\\special_functions_digamma.html"},{"title":"special_functions_gamma – FSTATS","text":"Uses ieee_arithmetic Ancestors: fstats Contents None","tags":"","loc":"module\\special_functions_gamma.html"},{"title":"statistics_implementation – FSTATS","text":"Uses ieee_arithmetic linalg fstats_errors Ancestors: fstats Contents None","tags":"","loc":"module\\statistics_implementation.html"},{"title":"allan.f90 – FSTATS","text":"Contents Submodules allan Source Code allan.f90 Source Code submodule ( fstats ) allan use fstats_errors contains ! ------------------------------------------------------------------------------ ! REF: Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, ! Viraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm for ! Fully Overlapped Allan Variance and Total Variance for Analysis and Modeling ! of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. ! 10.1109/LSENS.2018.2829799. ! ! https://www.researchgate.net/publication/324738301_A_Fast_Parallel_Algorithm_for_Fully_Overlapped_Allan_Variance_and_Total_Variance_for_Analysis_and_Modeling_of_Noise_in_Inertial_Sensors ! https://github.com/shrikanth95/Fast-Parallel-Fully-Overlapped-Allan-Variance-and-Total-Variance/blob/master/fast_FOAV.m module function allan_variance_1 ( x , dt , err ) result ( rst ) ! Arguments real ( real64 ), intent ( in ), dimension (:) :: x real ( real64 ), intent ( in ), optional :: dt class ( errors ), intent ( inout ), optional , target :: err real ( real64 ), allocatable , dimension (:,:) :: rst ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: flag , j , m , n , limit , nr real ( real64 ), allocatable , dimension (:) :: tall1 , tall2 real ( real64 ) :: temp , deltaT ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( dt )) then deltaT = dt else deltaT = 1.0d0 end if ! Initialization n = size ( x ) limit = n nr = floor ( 0.5 * n ) - 1 allocate ( tall1 ( n - 1 ), source = x (: n - 1 ), stat = flag ) if ( flag == 0 ) allocate ( tall2 ( n - 1 ), source = x ( 2 : n )) if ( flag == 0 ) allocate ( rst ( nr , 2 ), source = 0.0d0 ) if ( flag /= 0 ) go to 10 ! Process do m = 1 , nr temp = 0.0d0 do j = 1 , limit - 1 temp = temp + ( tall2 ( j ) - tall1 ( j )) ** 2 tall1 ( j ) = tall1 ( j ) + x ( m + j ) tall2 ( j ) = tall2 ( j + 1 ) + x ( 2 * m + j + 1 ) end do limit = limit - 2 rst ( m , 1 ) = dt * m rst ( m , 2 ) = temp / ( 2.0d0 * ( n - 2 * m + 1 ) * m ** 2 ) end do ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"allan_variance_1\" , flag ) return end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\allan.f90.html"},{"title":"distributions_chisquared.f90 – FSTATS","text":"Contents Submodules distributions_chisquared Source Code distributions_chisquared.f90 Source Code submodule ( fstats ) distributions_chisquared contains ! ------------------------------------------------------------------------------ pure module elemental function cs_pdf ( this , x ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Local Variables real ( real64 ) :: arg ! Process arg = 0.5d0 * this % dof rst = 1.0d0 / ( 2.0d0 ** arg * gamma ( arg )) * x ** ( arg - 1.0d0 ) * exp ( - 0.5d0 * x ) end function ! ------------------------------------------------------------------------------ pure module elemental function cs_cdf ( this , x ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Local Variables real ( real64 ) :: arg ! Process arg = 0.5d0 * this % dof rst = incomplete_gamma_lower ( arg , 0.5d0 * x ) / gamma ( arg ) end function ! ------------------------------------------------------------------------------ pure module function cs_mean ( this ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process rst = real ( this % dof , real64 ) end function ! ------------------------------------------------------------------------------ pure module function cs_median ( this ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process rst = this % dof * ( 1.0d0 - 2.0d0 / ( 9.0d0 * this % dof )) ** 3 end function ! ------------------------------------------------------------------------------ pure module function cs_mode ( this ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process rst = max ( this % dof - 2.0d0 , 0.0d0 ) end function ! ------------------------------------------------------------------------------ pure module function cs_variance ( this ) result ( rst ) ! Arguments class ( chi_squared_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process rst = 2.0d0 * this % dof end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\distributions_chisquared.f90.html"},{"title":"distributions_f.f90 – FSTATS","text":"Contents Submodules distributions_f Source Code distributions_f.f90 Source Code submodule ( fstats ) distributions_f use ieee_arithmetic contains ! ------------------------------------------------------------------------------ pure module elemental function fd_pdf ( this , x ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 rst = ( 1.0d0 / beta ( 0.5d0 * d1 , 0.5d0 * d2 )) * ( d1 / d2 ) ** ( 0.5d0 * d1 ) * & x ** ( 0.5d0 * d1 - 1.0d0 ) * ( 1.0d0 + d1 * x / d2 ) ** ( - 0.5d0 * ( d1 + d2 )) end function ! ------------------------------------------------------------------------------ pure module elemental function fd_cdf ( this , x ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 rst = regularized_beta ( 0.5d0 * d1 , 0.5d0 * d2 , d1 * x / ( d1 * x + d2 )) end function ! ------------------------------------------------------------------------------ pure module function fd_mean ( this ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process if ( this % d2 > 2.0d0 ) then rst = this % d2 / ( this % d2 - 2.0d0 ) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ------------------------------------------------------------------------------ pure module function fd_median ( this ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = ieee_value ( rst , IEEE_QUIET_NAN ) end function ! ------------------------------------------------------------------------------ pure module function fd_mode ( this ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process if ( this % d1 > 2.0d0 ) then rst = (( this % d1 - 2.0d0 ) / this % d1 ) * ( this % d2 / ( this % d2 + 2.0d0 )) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ------------------------------------------------------------------------------ pure module function fd_variance ( this ) result ( rst ) ! Arguments class ( f_distribution ), intent ( in ) :: this real ( real64 ) :: rst ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 if ( d2 > 4.0d0 ) then rst = ( 2.0d0 * d2 ** 2 * ( d1 + d2 - 2.0d0 )) / & ( d1 * ( d2 - 2.0d0 ) ** 2 * ( d2 - 4.0d0 )) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\distributions_f.f90.html"},{"title":"distributions_normal.f90 – FSTATS","text":"Contents Submodules distributions_normal Source Code distributions_normal.f90 Source Code submodule ( fstats ) distributions_normal real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) contains ! ------------------------------------------------------------------------------ pure module elemental function nd_pdf ( this , x ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst rst = exp ( - 0.5d0 * (( x - this % mean_value ) / this % standard_deviation ) ** 2 ) / & ( this % standard_deviation * sqrt ( 2.0d0 * pi )) end function ! ------------------------------------------------------------------------------ pure module elemental function nd_cdf ( this , x ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst rst = 0.5d0 * ( 1.0d0 + erf (( x - this % mean_value ) / & ( this % standard_deviation * sqrt ( 2.0d0 )))) end function ! ------------------------------------------------------------------------------ pure module function nd_mean ( this ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure module function nd_median ( this ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure module function nd_mode ( this ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure module function nd_variance ( this ) result ( rst ) class ( normal_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = this % standard_deviation ** 2 end function ! ------------------------------------------------------------------------------ module subroutine nd_standardize ( this ) class ( normal_distribution ), intent ( inout ) :: this this % mean_value = 0.0d0 this % standard_deviation = 1.0d0 end subroutine ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\distributions_normal.f90.html"},{"title":"distributions_t.f90 – FSTATS","text":"Contents Submodules distributions_t Source Code distributions_t.f90 Source Code submodule ( fstats ) distributions_t use ieee_arithmetic real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) contains ! ------------------------------------------------------------------------------ ! REF: https://en.wikipedia.org/wiki/Student%27s_t-distribution pure module elemental function td_pdf ( this , x ) result ( rst ) ! Arguments class ( t_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Process rst = gamma (( this % dof + 1.0d0 ) / 2.0d0 ) / & ( sqrt ( this % dof * pi ) * gamma ( this % dof / 2.0d0 )) * & ( 1.0d0 + x ** 2 / this % dof ) ** ( - 0.5d0 * ( 1.0d0 + this % dof )) end function ! ------------------------------------------------------------------------------ pure module elemental function td_cdf ( this , x ) result ( rst ) ! Arguments class ( t_distribution ), intent ( in ) :: this real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Process real ( real64 ) :: t t = this % dof / ( this % dof + x ** 2 ) rst = 1.0d0 - 0.5d0 * regularized_beta ( 0.5d0 * this % dof , 0.5d0 , t ) if ( x < 0 ) rst = 1.0d0 - rst end function ! ------------------------------------------------------------------------------ pure module function td_mean ( this ) result ( rst ) class ( t_distribution ), intent ( in ) :: this real ( real64 ) :: rst if ( this % dof < 1.0d0 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) else rst = 0.0d0 end if end function ! ------------------------------------------------------------------------------ pure module function td_median ( this ) result ( rst ) class ( t_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = 0.0d0 end function ! ------------------------------------------------------------------------------ pure module function td_mode ( this ) result ( rst ) class ( t_distribution ), intent ( in ) :: this real ( real64 ) :: rst rst = 0.0d0 end function ! ------------------------------------------------------------------------------ pure module function td_variance ( this ) result ( rst ) class ( t_distribution ), intent ( in ) :: this real ( real64 ) :: rst if ( this % dof <= 1.0d0 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) else if ( this % dof > 1.0d0 . and . this % dof <= 2.0d0 ) then rst = ieee_value ( rst , IEEE_POSITIVE_INF ) else rst = this % dof / ( this % dof - 2.0d0 ) end if end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\distributions_t.f90.html"},{"title":"experimental_design_implementation.f90 – FSTATS","text":"Contents Submodules experimental_design_implementation Source Code experimental_design_implementation.f90 Source Code submodule ( fstats ) experimental_design_implementation use fstats_errors contains ! ------------------------------------------------------------------------------ module subroutine get_full_factorial_matrix_size_int32 ( vars , m , n , err ) ! Arguments integer ( int32 ), intent ( in ) :: vars (:) integer ( int32 ), intent ( out ) :: m , n class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: i class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = 0 n = 0 ! Ensure every value is greater than 1 do i = 1 , size ( vars ) if ( vars ( i ) < 1 ) then write ( errmsg , 100 ) \"A value less than 1 was found at index \" , & i , \" of the input array.  All values must be greater \" // & \"than or equal to 1.\" call errmgr % report_error ( \"get_full_factorial_matrix_size_int32\" , & trim ( errmsg ), FS_INVALID_INPUT_ERROR ) return end if end do ! Process m = product ( vars ) n = size ( vars ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ module subroutine full_factorial_int32 ( vars , tbl , err ) ! Arguments integer ( int32 ), intent ( in ) :: vars (:) integer ( int32 ), intent ( out ) :: tbl (:,:) class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: i , col , stride , last , val , m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Verify the size of the input table call get_full_factorial_matrix_size ( vars , m , n , errmgr ) if ( errmgr % has_error_occurred ()) return if ( size ( tbl , 1 ) /= m . or . size ( tbl , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"full_factorial_int32\" , & \"tbl\" , m , n , size ( tbl , 1 ), size ( tbl , 2 )) return end if ! Process do col = 1 , n stride = 1 if ( col /= n ) stride = product ( vars ( col + 1 : n )) val = 1 do i = 1 , m , stride last = i + stride - 1 tbl ( i : last , col ) = val val = val + 1 if ( val > vars ( col )) val = 1 end do end do end subroutine ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\experimental_design_implementation.f90.html"},{"title":"fstats.f90 – FSTATS","text":"Contents Modules fstats Source Code fstats.f90 Source Code module fstats !! FSTATS is a modern Fortran statistical library containing routines for !! computing basic statistical properties, hypothesis testing, regression, !! special functions, and experimental design. use iso_fortran_env use ferror implicit none private public :: distribution public :: distribution_function public :: distribution_property public :: t_distribution public :: normal_distribution public :: f_distribution public :: chi_squared_distribution public :: mean public :: variance public :: standard_deviation public :: median public :: r_squared public :: adjusted_r_squared public :: quantile public :: t_test_equal_variance public :: t_test_unequal_variance public :: t_test_paired public :: f_test public :: anova public :: anova_factor public :: single_factor_anova_table public :: two_factor_anova_table public :: confidence_interval public :: beta public :: regularized_beta public :: incomplete_beta public :: digamma public :: incomplete_gamma_upper public :: incomplete_gamma_lower public :: coefficient_matrix public :: covariance_matrix public :: linear_least_squares public :: regression_statistics public :: get_full_factorial_matrix_size public :: full_factorial public :: iteration_controls public :: lm_solver_options public :: convergence_info public :: regression_function public :: iteration_update public :: jacobian public :: nonlinear_least_squares public :: allan_variance public :: FS_LEVENBERG_MARQUARDT_UPDATE public :: FS_QUADRATIC_UPDATE public :: FS_NIELSEN_UPDATE public :: assignment ( = ) ! ****************************************************************************** ! CONSTANTS ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: FS_LEVENBERG_MARQUARDT_UPDATE = 1 integer ( int32 ), parameter :: FS_QUADRATIC_UPDATE = 2 integer ( int32 ), parameter :: FS_NIELSEN_UPDATE = 3 ! ****************************************************************************** ! OPERATORS ! ------------------------------------------------------------------------------ interface assignment ( = ) module procedure :: ic_equal module procedure :: ci_equal module procedure :: lso_equal end interface ! ****************************************************************************** ! DISTRIBUTIONS ! ------------------------------------------------------------------------------ type , abstract :: distribution !! Defines a probability distribution. contains procedure ( distribution_function ), deferred , pass :: pdf !! Computes the probability density function. procedure ( distribution_function ), deferred , pass :: cdf !! Computes the cumulative distribution function. procedure ( distribution_property ), deferred , pass :: mean !! Computes the mean of the distribution. procedure ( distribution_property ), deferred , pass :: median !! Computes the median of the distribution. procedure ( distribution_property ), deferred , pass :: mode !! Computes the mode of the distribution. procedure ( distribution_property ), deferred , pass :: variance !! Computes the variance of the distribution. end type interface pure elemental function distribution_function ( this , x ) result ( rst ) !! Defines the interface for a probability distribution function. use iso_fortran_env , only : real64 import distribution class ( distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure function distribution_property ( this ) result ( rst ) !! Computes the value of a distribution property. use iso_fortran_env , only : real64 import distribution class ( distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ) :: rst !! The property value. end function end interface type , extends ( distribution ) :: t_distribution !! Defines Student's T-Distribution. real ( real64 ) :: dof !! The number of degrees of freedom. contains procedure , public :: pdf => td_pdf procedure , public :: cdf => td_cdf procedure , public :: mean => td_mean procedure , public :: median => td_median procedure , public :: mode => td_mode procedure , public :: variance => td_variance end type ! distributions_t.f90 interface pure module elemental function td_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for Student's T-Distribution is given as !!  f(t) = \\frac{ \\Gamma \\left( \\frac{\\nu + 1}{2} \\right) } !! { \\sqrt{\\nu \\pi} \\Gamma \\left( \\frac{\\nu}{2} \\right) } !! \\left( 1 + \\frac{t&#94;2}{\\nu} \\right)&#94;{-(\\nu + 1) / 2}  class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module elemental function td_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for Student's T-Distribution is given as !!  F(t) = \\int_{-\\infty}&#94;{t} f(u) \\,du = 1 - \\frac{1}{2} I_{x(t)} !! \\left( \\frac{\\nu}{2}, \\frac{1}{2} \\right)  !! where  x(t) = \\frac{\\nu}{\\nu + t&#94;2}  class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module function td_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The mean. end function pure module function td_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The median. end function pure module function td_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The mode. end function pure module function td_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The variance. end function end interface type , extends ( distribution ) :: normal_distribution !! Defines a normal distribution. real ( real64 ) :: standard_deviation !! The standard deviation of the distribution. real ( real64 ) :: mean_value !! The mean value of the distribution. contains procedure , public :: pdf => nd_pdf procedure , public :: cdf => nd_cdf procedure , public :: mean => nd_mean procedure , public :: median => nd_median procedure , public :: mode => nd_mode procedure , public :: variance => nd_variance procedure , public :: standardize => nd_standardize end type ! distributions_normal.f90 interface pure module elemental function nd_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a normal distribution is given as !!  f(x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} \\exp \\left(-\\frac{1}{2} !! \\left( \\frac{x - \\mu}{\\sigma} \\right)&#94;2 \\right) . class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module elemental function nd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a normal distribution is given as !!  F(x) = \\frac{1}{2} \\left( 1 + erf \\left( \\frac{x - \\mu} !! {\\sigma \\sqrt{2}} \\right) \\right)  class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module function nd_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The mean. end function pure module function nd_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The median. end function pure module function nd_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The mode. end function pure module function nd_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The variance. end function module subroutine nd_standardize ( this ) !! Standardizes the normal distribution to a mean of 0 and a !! standard deviation of 1. class ( normal_distribution ), intent ( inout ) :: this !! The normal_distribution object. end subroutine end interface type , extends ( distribution ) :: f_distribution !! Defines an F-distribution. real ( real64 ) :: d1 !! The measure of degrees of freedom for the first data set. real ( real64 ) :: d2 !! The measure of degrees of freedom for the second data set. contains procedure , public :: pdf => fd_pdf procedure , public :: cdf => fd_cdf procedure , public :: mean => fd_mean procedure , public :: median => fd_median procedure , public :: mode => fd_mode procedure , public :: variance => fd_variance end type ! distributions_f.f90 interface pure module elemental function fd_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a F distribution is given as !!  f(x) = !! \\sqrt{ \\frac{ (d_1 x)&#94;{d_1} d_{2}&#94;{d_2} }{ (d_1 x + d_2)&#94;{d_1 + d_2} } } !! \\frac{1}{x \\beta \\left( \\frac{d_1}{2}, \\frac{d_2}{2} \\right) }  class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module elemental function fd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a F distribution is given as !!  F(x) = I_{d_1 x/(d_1 x + d_2)} \\left( \\frac{d_1}{2}, !! \\frac{d_2}{2} \\right)  class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module function fd_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The mean. end function pure module function fd_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The median. end function pure module function fd_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The mode. end function pure module function fd_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The variance. end function end interface type , extends ( distribution ) :: chi_squared_distribution !! Defines a Chi-squared distribution. integer ( int32 ) :: dof !! The number of degrees of freedom. contains procedure , public :: pdf => cs_pdf procedure , public :: cdf => cs_cdf procedure , public :: mean => cs_mean procedure , public :: median => cs_median procedure , public :: mode => cs_mode procedure , public :: variance => cs_variance end type ! distributions_chisquared.f90 interface pure module elemental function cs_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a Chi-squared distribution is given as !!  f(x) = \\frac{x&#94;{k/2 - 1} \\exp{-x / 2}} {2&#94;{k / 2} !! \\Gamma \\left( \\frac{k}{2} \\right)}  class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module elemental function cs_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a Chi-squared distribution is given as !!  F(x) = \\frac{ \\gamma \\left( \\frac{k}{2}, \\frac{x}{2} \\right) } !! { \\Gamma \\left( \\frac{k}{2} \\right)}  class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure module function cs_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The mean. end function pure module function cs_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The median. end function pure module function cs_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The mode. end function pure module function cs_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The variance. end function end interface ! ****************************************************************************** ! GENERAL STATISTICS ! ------------------------------------------------------------------------------ type anova_factor !! Defines an ANOVA factor result. real ( real64 ) :: dof !! The number of degrees of freedome. real ( real64 ) :: variance !! The estimate of variance. real ( real64 ) :: sum_of_squares !! The sum of the squares. real ( real64 ) :: f_statistic !! The F-statistic. real ( real64 ) :: probability !! The variance probability term. end type type single_factor_anova_table !! Defines a single-factor ANOVA results table. type ( anova_factor ) :: main_factor !! The main, or main factor, results. type ( anova_factor ) :: within_factor !! The within-treatement (error) results. real ( real64 ) :: total_dof !! The total number of degrees of freedom. real ( real64 ) :: total_sum_of_squares !! The total sum of squares. real ( real64 ) :: total_variance !! The total variance estimate. real ( real64 ) :: overall_mean !! The overall mean value. end type type two_factor_anova_table !! Defines a two-factor ANOVA results table. type ( anova_factor ) :: main_factor_1 !! The first main-factor results. type ( anova_factor ) :: main_factor_2 !! The second main-factor results. type ( anova_factor ) :: interaction !! The interaction effects. type ( anova_factor ) :: within_factor !! The within (error) factor results. real ( real64 ) :: total_dof !! The total number of degrees of freedom. real ( real64 ) :: total_sum_of_squares !! The total sum of squares. real ( real64 ) :: total_variance !! The total variance estimate. real ( real64 ) :: overall_mean !! The overall mean value. end type interface mean !! Computes the mean of the values in an array. module procedure :: mean_real64 module procedure :: mean_real32 end interface interface variance !! Computes the sample variance of the values in an array. !! !! The variance computed is the sample variance such that the variance. !!  s&#94;2 = \\frac{\\Sigma \\left( x_{i} - \\bar{x} \\right)&#94;2}{n - 1}  module procedure :: variance_real64 module procedure :: variance_real32 end interface interface standard_deviation !! Computes the sample standard deviation of the values in an array. !! !! The value computed is the sample standard deviation. !!  s = \\sqrt{ \\frac{\\Sigma \\left( x_{i} - \\bar{x} \\right)&#94;2}{n - 1} }  module procedure :: standard_deviation_real64 module procedure :: standard_deviation_real32 end interface interface median !! Computes the median of the values in an array. module procedure :: median_real64 module procedure :: median_real32 end interface interface r_squared !! Computes the R-squared value for a data set. !! !! The R-squared value is computed by determining the sum of the squares !! of the residuals: !!  SS_{res} = \\Sigma \\left( y_i - f_i \\right)&#94;2  !! The total sum of the squares: !!  SS_{tot} = \\Sigma \\left( y_i - \\bar{y} \\right)&#94;2 . !! The R-squared value is then: !!  R&#94;2 = 1 - \\frac{SS_{res}}{SS_{tot}} . !! !! See Also: !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Coefficient_of_determination) module procedure :: r_squared_real64 module procedure :: r_squared_real32 end interface interface adjusted_r_squared !! Computes the adjusted R-squared value for a data set. !! !! The adjusted R-squared provides a mechanism for tempering the effects !! of extra explanatory variables on the traditional R-squared !! calculation.  It is computed by noting the sample size  n  and !! the number of variables  p . !!  \\bar{R}&#94;2 = 1 - \\left( 1 - R&#94;2 \\right) \\frac{n - 1}{n - p} . !! !! See Also: !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Coefficient_of_determination#Adjusted_R2) module procedure :: adjusted_r_squared_real64 module procedure :: adjusted_r_squared_real32 end interface interface quantile !! Computes the specified quantile of a data set using the SAS !! Method 4. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Quantile) module procedure :: quantile_real64 module procedure :: quantile_real32 end interface interface t_test_equal_variance !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed equivalent variances. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) module procedure :: t_test_equal_var_real64 module procedure :: t_test_equal_var_real32 end interface interface t_test_unequal_variance !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed non-equivalent variances. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) module procedure :: t_test_unequal_var_real64 module procedure :: t_test_unequal_var_real32 end interface interface t_test_paired !! Computes the 2-tailed Student's T-Test for two paired data sets. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) module procedure :: t_test_paired_real64 module procedure :: t_test_paired_real32 end interface interface f_test !! Computes the F-test and returns the probability (two-tailed) that !! the variances of two data sets are not significantly different. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/F-test) module procedure :: f_test_real64 module procedure :: f_test_real32 end interface interface anova !! Performs an analysis of variance (ANOVA) on the supplied data !! set. !! !! The following example illustrates a single-factor ANOVA on a !! data set. !! ```fortran !! program example !!     use iso_fortran_env !!     use fstats !!     implicit none !! !!     ! Local Variables !!     character, parameter :: tab = achar(9) !!     real(real64) :: x(10, 2) !!     type(single_factor_anova_table) :: tbl !! !!     ! Define the data !!     x = reshape( & !!         [ & !!             3.086d3, 3.082d3, 3.069d3, 3.072d3, 3.045d3, 3.070d3, 3.079d3, & !!             3.050d3, 3.062d3, 3.062d3, 3.075d3, 3.061d3, 3.063d3, 3.038d3, & !!             3.070d3, 3.062d3, 3.070d3, 3.049d3, 3.042d3, 3.063d3 & !!         ], & !!         [10, 2] & !!     ) !! !!     ! Perform the ANOVA !!     tbl = anova(x) !! !!     ! Print out the table !!     print '(A)', \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & !!         tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" !!     print '(AF2.0AF5.1AF5.1AF5.3AF5.3)', \"Main Factor: \" // tab, & !!         tbl%main_factor%dof, tab, & !!         tbl%main_factor%sum_of_squares, tab // tab, & !!         tbl%main_factor%variance, tab // tab, & !!         tbl%main_factor%f_statistic, tab, & !!         tbl%main_factor%probability !! !!     print '(AF3.0AF6.1AF5.1)', \"Within: \" // tab, & !!         tbl%within_factor%dof, tab, & !!         tbl%within_factor%sum_of_squares, tab // tab, & !!         tbl%within_factor%variance !! !!     print '(AF3.0AF6.1AF5.1)', \"Total: \" // tab // tab, & !!         tbl%total_dof, tab, & !!         tbl%total_sum_of_squares, tab // tab, & !!         tbl%total_variance !! !!     print '(AF6.1)', \"Overall Mean: \", tbl%overall_mean !! end program !! ``` !! The above program produces the following output. !! ```text !! Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value !! Main Factor:    1.      352.8           352.8           2.147   0.160 !! Within:         18.     2958.2          164.3 !! Total:          19.     3311.0          174.3 !! Overall Mean: 3063.5 !! ``` !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Analysis_of_variance) !! - [SPC Excel Single Factor ANOVA](https://www.spcforexcel.com/knowledge/root-cause-analysis/single-factor-anova) !! - [SPC Excel Gage R&R](https://www.spcforexcel.com/knowledge/measurement-systems-analysis/anova-gage-rr-part-1) !! - [SPC Excel Understanding Regression Statistics](https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1) !! - [NIST - Two Way ANOVA](https://www.itl.nist.gov/div898/handbook/prc/section4/prc427.htm) module procedure :: anova_1_factor module procedure :: anova_2_factor module procedure :: anova_model_fit end interface interface confidence_interval !! Computes the confidence interval for the specified distribution. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Confidence_interval) module procedure :: confidence_interval_real64 module procedure :: confidence_interval_real32 module procedure :: confidence_interval_real64_array module procedure :: confidence_interval_real32_array end interface ! statistics_implementation.f90 interface pure module function mean_real64 ( x ) result ( rst ) !! Computes the mean of the values in an array. real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst !! The result. end function pure module function mean_real32 ( x ) result ( rst ) !! Computes the mean of the values in an array. real ( real32 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real32 ) :: rst !! The result. end function pure module function variance_real64 ( x ) result ( rst ) !! Computes the sample variance of the values in an array. real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst !! The result. end function pure module function variance_real32 ( x ) result ( rst ) !! Computes the sample variance of the values in an array. real ( real32 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real32 ) :: rst !! The result. end function pure module function standard_deviation_real64 ( x ) result ( rst ) !! Computes the sample standard deviation of the values in an array. real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst !! The result. end function pure module function standard_deviation_real32 ( x ) result ( rst ) !! Computes the sample standard deviation of the values in an array. real ( real32 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real32 ) :: rst !! The result. end function module function median_real64 ( x ) result ( rst ) !! Computes the median of the values in an array. real ( real64 ), intent ( inout ) :: x (:) !! The array of values to analyze.  On output, the same values, !! but sorted into ascending order. real ( real64 ) :: rst !! The result. end function module function median_real32 ( x ) result ( rst ) !! Computes the median of the values in an array. real ( real32 ), intent ( inout ) :: x (:) !! The array of values to analyze.  On output, the same values, !! but sorted into ascending order. real ( real32 ) :: rst !! The result. end function module function r_squared_real64 ( x , xm , err ) result ( rst ) !! Computes the R-squared value for a data set. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real64 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if @p x and @p xm are not the !!   same size. real ( real64 ) :: rst !! The result. end function module function r_squared_real32 ( x , xm , err ) result ( rst ) !! Computes the R-squared value for a data set. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real32 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if @p x and @p xm are not the !!   same size. real ( real32 ) :: rst !! The result. end function module function adjusted_r_squared_real64 ( p , x , xm , err ) result ( rst ) !! Computes the adjusted R-squared value for a data set. integer ( int32 ), intent ( in ) :: p !! The number of variables. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real64 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the !!   same size. real ( real64 ) :: rst !! The result. end function module function adjusted_r_squared_real32 ( p , x , xm , err ) result ( rst ) !! Computes the adjusted R-squared value for a data set. integer ( int32 ), intent ( in ) :: p !! The number of variables. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real32 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if @p x and @p xm are not the !!   same size. real ( real32 ) :: rst !! The result. end function pure module function quantile_real64 ( x , q ) result ( rst ) !! Computes the specified quantile of a data set using the SAS !! Method 4. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the data. real ( real64 ), intent ( in ) :: q !! The quantile to compute (e.g. 0.25 computes the 25% !! quantile). real ( real64 ) :: rst !! The result. end function pure module function quantile_real32 ( x , q ) result ( rst ) !! Computes the specified quantile of a data set using the SAS !! Method 4. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the data. real ( real32 ), intent ( in ) :: q !! The quantile to compute (e.g. 0.25 computes the 25% !! quantile). real ( real32 ) :: rst !! The result. end function pure module function confidence_interval_real64 ( dist , alpha , s , n ) & result ( rst ) !! Computes the confidence interval for the specified distribution. class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real64 ), intent ( in ) :: alpha !! The probability value of interest. real ( real64 ), intent ( in ) :: s !! The sample standard deviation. integer ( int32 ), intent ( in ) :: n !! The number of samples in the data set. real ( real64 ) :: rst !! The result. end function pure module function confidence_interval_real32 ( dist , alpha , s , n ) & result ( rst ) class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real32 ), intent ( in ) :: alpha !! The probability value of interest. real ( real32 ), intent ( in ) :: s !! The sample standard deviation. integer ( int32 ), intent ( in ) :: n !! The number of samples in the data set. real ( real32 ) :: rst !! The result. end function pure module function confidence_interval_real64_array ( dist , alpha , x ) & result ( rst ) class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real64 ), intent ( in ) :: alpha !! The probability value of interest. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the data to analyze. real ( real64 ) :: rst !! The result. end function pure module function confidence_interval_real32_array ( dist , alpha , x ) & result ( rst ) class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real32 ), intent ( in ) :: alpha !! The probability value of interest. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the data to analyze. real ( real32 ) :: rst !! The result. end function module subroutine t_test_equal_var_real64 ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed equivalent variances. real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. end subroutine module subroutine t_test_equal_var_real32 ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed equivalent variances. real ( real32 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real32 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real32 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real32 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real32 ), intent ( out ) :: dof !! The degrees of freedom. end subroutine module subroutine t_test_unequal_var_real64 ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed non-equivalent variances. real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. end subroutine module subroutine t_test_unequal_var_real32 ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed non-equivalent variances. real ( real32 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real32 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real32 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real32 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real32 ), intent ( out ) :: dof !! The degrees of freedom. end subroutine module subroutine t_test_paired_real64 ( x1 , x2 , stat , p , dof , err ) !! Computes the 2-tailed Student's T-Test for two paired data sets. real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An N-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x1 and x2 are not the same !!   length. end subroutine module subroutine t_test_paired_real32 ( x1 , x2 , stat , p , dof , err ) !! Computes the 2-tailed Student's T-Test for two paired data sets. real ( real32 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real32 ), intent ( in ) :: x2 (:) !! An N-element array containing the second data set. real ( real32 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real32 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the same two underlying populations that !! have the same mean. real ( real32 ), intent ( out ) :: dof !! The degrees of freedom. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x1 and x2 are not the same !!   length. end subroutine module subroutine f_test_real64 ( x1 , x2 , stat , p , dof1 , dof2 ) !! Computes the F-test and returns the probability (two-tailed) that !! the variances of two data sets are not significantly different. real ( real64 ), intent ( in ) :: x1 (:), x2 (:) real ( real64 ), intent ( out ) :: stat , p , dof1 , dof2 end subroutine module subroutine f_test_real32 ( x1 , x2 , stat , p , dof1 , dof2 ) !! Computes the F-test and returns the probability (two-tailed) that !! the variances of two data sets are not significantly different. real ( real32 ), intent ( in ) :: x1 (:), x2 (:) real ( real32 ), intent ( out ) :: stat , p , dof1 , dof2 end subroutine module function anova_1_factor ( x ) result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data !! set. real ( real64 ), intent ( in ) :: x (:,:) !! An M-by-N matrix containing the M replications of the N test !! points of interest. type ( single_factor_anova_table ) :: rst !! A single_factor_anova_table instance containing the ANOVA !! results. end function module function anova_2_factor ( x ) result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data !! set. real ( real64 ), intent ( in ) :: x (:,:,:) !! An M-by-N-by-K array containing the M replications of the !! N first factor results, and the K second factor results. type ( two_factor_anova_table ) :: rst !! A @ref two_factor_anova_table instance containing the ANOVA !! results. end function module function anova_model_fit ( nmodelparams , ymeas , ymod , err ) & result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data !! set. integer ( int32 ), intent ( in ) :: nmodelparams !! The number of model parameters. real ( real64 ), intent ( in ) :: ymeas (:) !! An N-element array containing the measured dependent !! variable data. real ( real64 ), intent ( in ) :: ymod (:) !! An N-element array containing the modeled dependent !! variable data. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if ymeas and ymod are not the !!   same length. !! - FS_MEMORY_ERROR: Occurs if a memory error is encountered. type ( single_factor_anova_table ) :: rst end function end interface ! ****************************************************************************** ! SPECIAL FUNCTIONS ! ------------------------------------------------------------------------------ interface beta !! Computes the beta function. !! !! The beta function is related to the gamma function !! by the following relationship. !!  \\beta(a,b) = \\frac{\\Gamma(a) \\Gamma(b)}{\\Gamma(a + b)} . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function) module procedure :: beta_real64 module procedure :: beta_real32 end interface interface regularized_beta !! Computes the regularized beta function. !! !! The regularized beta function is defined as the ratio between !! the incomplete beta function and the beta function. !!  I_{x}(a,b) = \\frac{\\beta(x;a,b)}{\\beta(a,b)} . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function) module procedure :: regularized_beta_real64 module procedure :: regularized_beta_real32 end interface interface incomplete_beta !! Computes the incomplete beta function. !! !! The incomplete beta function is defind as: !!  \\beta(x;a,b) = \\int_{0}&#94;{x} t&#94;{a-1} (1 - t)&#94;{b-1} dt . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function) module procedure :: incomplete_beta_real64 module procedure :: incomplete_beta_real32 end interface interface digamma !! Computes the digamma function. !! !! The digamma function is defined as: !!  \\psi(x) = !! \\frac{d}{dx}\\left( \\ln \\left( \\Gamma \\left( x \\right) \\right) !! \\right)  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Digamma_function) module procedure :: digamma_real64 module procedure :: digamma_real32 end interface interface incomplete_gamma_upper !! Computes the upper incomplete gamma function. !! !! The upper incomplete gamma function is defined as: !!  \\Gamma(a, x) = \\int_{x}&#94;{\\infty} t&#94;{a-1} e&#94;{-t} \\,dt  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Incomplete_gamma_function) module procedure :: incomplete_gamma_upper_real64 module procedure :: incomplete_gamma_upper_real32 end interface interface incomplete_gamma_lower !! Computes the lower incomplete gamma function. !! !! The lower incomplete gamma function is defined as: !!  \\gamma(a, x) = \\int_{0}&#94;{x} t&#94;{a-1} e&#94;{-t} \\,dt  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Incomplete_gamma_function) module procedure :: incomplete_gamma_lower_real64 module procedure :: incomplete_gamma_lower_real32 end interface ! special_functions_beta.f90 interface pure elemental module function beta_real64 ( a , b ) result ( rst ) !! Computes the beta function. real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ) :: rst !! The value of the beta function at  a  and  b . end function pure elemental module function beta_real32 ( a , b ) result ( rst ) real ( real32 ), intent ( in ) :: a !! The first argument of the function. real ( real32 ), intent ( in ) :: b !! The second argument of the function. real ( real32 ) :: rst !! The value of the beta function at  a  and  b . end function pure elemental module function regularized_beta_real64 ( a , b , x ) result ( rst ) !! Computes the regularized beta function. real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ), intent ( in ) :: x !! The upper limit of the integration. real ( real64 ) :: rst !! The value of the regularized beta function. end function pure elemental module function regularized_beta_real32 ( a , b , x ) result ( rst ) !! Computes the regularized beta function. real ( real32 ), intent ( in ) :: a !! The first argument of the function. real ( real32 ), intent ( in ) :: b !! The second argument of the function. real ( real32 ), intent ( in ) :: x !! The upper limit of the integration. real ( real32 ) :: rst !! The value of the regularized beta function. end function pure elemental module function incomplete_beta_real64 ( a , b , x ) result ( rst ) !! Computes the incomplete beta function. real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ), intent ( in ) :: x !! The upper limit of the integration. real ( real64 ) :: rst !! The value of the incomplete beta function. end function pure elemental module function incomplete_beta_real32 ( a , b , x ) result ( rst ) !! Computes the incomplete beta function. real ( real32 ), intent ( in ) :: a !! The first argument of the function. real ( real32 ), intent ( in ) :: b !! The second argument of the function. real ( real32 ), intent ( in ) :: x !! The upper limit of the integration. real ( real32 ) :: rst !! The value of the incomplete beta function. end function end interface ! special_functions_digamma.f90 interface pure elemental module function digamma_real64 ( x ) result ( rst ) !! Computes the digamma function. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. end function pure elemental module function digamma_real32 ( x ) result ( rst ) !! Computes the digamma function. real ( real32 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real32 ) :: rst !! The function value. end function end interface ! special_functions_gamma.f90 interface pure elemental module function incomplete_gamma_upper_real64 ( a , x ) & result ( rst ) !! Computes the upper incomplete gamma function. real ( real64 ), intent ( in ) :: a !! The coefficient value. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. end function pure elemental module function incomplete_gamma_upper_real32 ( a , x ) & result ( rst ) !! Computes the upper incomplete gamma function. real ( real32 ), intent ( in ) :: a !! The coefficient value. real ( real32 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real32 ) :: rst !! The function value. end function pure elemental module function incomplete_gamma_lower_real64 ( a , x ) & result ( rst ) !! Computes the lower incomplete gamma function. real ( real64 ), intent ( in ) :: a !! The coefficient value. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. end function pure elemental module function incomplete_gamma_lower_real32 ( a , x ) & result ( rst ) !! Computes the lower incomplete gamma function. real ( real32 ), intent ( in ) :: a !! The coefficient value. real ( real32 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real32 ) :: rst !! The function value. end function end interface ! ****************************************************************************** ! REGRESSION ! ------------------------------------------------------------------------------ type regression_statistics !! A container for regression-related statistical information. real ( real64 ) :: standard_error !! The standard error for the model coefficient. !! !!  E_{s}(\\beta_{i}) = \\sqrt{\\sigma&#94;{2} C_{ii}}  real ( real64 ) :: t_statistic !! The T-statistic for the model coefficient. !! !!  t_o = \\frac{ \\beta_{i} }{E_{s}(\\beta_{i})}  real ( real64 ) :: probability !! The probability that the coefficient is not statistically !! important.  A statistically important coefficient will have a !! low probability (p-value), typically 0.05 or lower; however, a !! p-value of up to ~0.2 may be acceptable dependent upon the !! problem.  Typically any p-value larger than ~0.2 indicates the !! parameter is not statistically important for the model. !! !!  p = t_{|t_o|, df_{residual}}  real ( real64 ) :: confidence_interval !! The confidence interval for the parameter at the level !! determined by the regression process. !! !!  c = t_{\\alpha, df} E_{s}(\\beta_{i})  end type interface coefficient_matrix !! Computes the coefficient matrix  X  to the linear !! least-squares regression problem of  X \\beta = y , where !!  X  is the coefficient matrix computed here,  \\beta  is !! the vector of coefficients to be determined, and  y  is the !! vector of measured dependent variables. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Linear_regression) module procedure :: coefficient_matrix_real64 module procedure :: coefficient_matrix_real32 end interface interface covariance_matrix !! Computes the covariance matrix  C  where !!  C = \\left( X&#94;{T} X \\right)&#94;{-1}  and  X  is computed !! by coefficient_matrix. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Covariance_matrix) !! - [Wikipedia - Regression](https://en.wikipedia.org/wiki/Linear_regression) module procedure :: covariance_matrix_real64 module procedure :: covariance_matrix_real32 end interface interface linear_least_squares !! Computes a linear least-squares regression to fit a set of data. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Linear_regression) !! - [SPC Excel Understanding Regression Statistics](https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1) module procedure :: linear_least_squares_real64 module procedure :: linear_least_squares_real32 end interface interface calculate_regression_statistics !! Computes statistics for the quality of fit for a regression model. module procedure :: calculate_regression_stats_r64 module procedure :: calculate_regression_stats_r32 end interface ! regression_implementation.f90 interface module subroutine coefficient_matrix_real64 ( order , intercept , x , c , err ) !! Computes the coefficient matrix to the linear-least squares !! regression problem. integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be !! at least one (linear equation), but can be higher as desired. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed !! as part of the regression; else, false. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real64 ), intent ( out ) :: c (:,:) !! An N-by-K matrix where the results will be written.  K !! must equal order + 1 in the event intercept is true; !! however, if intercept is false, K must equal order. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not properly sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. end subroutine module subroutine coefficient_matrix_real32 ( order , intercept , x , c , err ) !! Computes the coefficient matrix to the linear-least squares !! regression problem. integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be !! at least one (linear equation), but can be higher as desired. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed !! as part of the regression; else, false. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real32 ), intent ( out ) :: c (:,:) !! An N-by-K matrix where the results will be written.  K !! must equal order + 1 in the event intercept is true; !! however, if intercept is false, K must equal order. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not properly sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. end subroutine module subroutine covariance_matrix_real64 ( x , c , err ) !! Computes the covariance matrix. real ( real64 ), intent ( in ) :: x (:,:) !! An M-by-N matrix containing the formatted independent data !!  matrix  X  as computed by coefficient_matrix. real ( real64 ), intent ( out ) :: c (:,:) !! The N-by-N covariance matrix. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the matrices are not !!      sized correctly. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. end subroutine module subroutine covariance_matrix_real32 ( x , c , err ) !! Computes the covariance matrix. real ( real32 ), intent ( in ) :: x (:,:) !! An M-by-N matrix containing the formatted independent data !!  matrix  X  as computed by coefficient_matrix. real ( real32 ), intent ( out ) :: c (:,:) !! The N-by-N covariance matrix. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the matrices are not !!      sized correctly. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. end subroutine module subroutine linear_least_squares_real64 ( order , intercept , x , y , & coeffs , ymod , resid , stats , alpha , err ) !! Computes a linear least-squares regression to fit a set of data. integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be at !! least one (linear equation), but can be higher as desired, !! as long as there is sufficient data. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed as part of !! the regression; else, false. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real64 ), intent ( in ) :: y (:) !! An N-element array containing the dependent variable !! measurement points. real ( real64 ), intent ( out ) :: coeffs (:) !! An ORDER+1 element array where the coefficients will !! be written. real ( real64 ), intent ( out ) :: ymod (:) !! An N-element array where the modeled data will be written. real ( real64 ), intent ( out ) :: resid (:) !! An N-element array where the residual error data will be !! written (modeled - actual). type ( regression_statistics ), intent ( out ), optional :: stats (:) !! An M-element array of regression_statistics items where !! M = ORDER + 1 when intercept is set to true; however, if !! intercept is set to false, M = ORDER. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      approriately sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. end subroutine module subroutine linear_least_squares_real32 ( order , intercept , x , y , & coeffs , ymod , resid , stats , alpha , err ) !! Computes a linear least-squares regression to fit a set of data. integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be at !! least one (linear equation), but can be higher as desired, !! as long as there is sufficient data. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed as part of !! the regression; else, false. real ( real32 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real32 ), intent ( in ) :: y (:) !! An N-element array containing the dependent variable !! measurement points. real ( real32 ), intent ( out ) :: coeffs (:) !! An ORDER+1 element array where the coefficients will !! be written. real ( real32 ), intent ( out ) :: ymod (:) !! An N-element array where the modeled data will be written. real ( real32 ), intent ( out ) :: resid (:) !! An N-element array where the residual error data will be !! written (modeled - actual). type ( regression_statistics ), intent ( out ), optional :: stats (:) !! An M-element array of regression_statistics items where !! M = ORDER + 1 when intercept is set to true; however, if !! intercept is set to false, M = ORDER. real ( real32 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      approriately sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. end subroutine module function calculate_regression_stats_r64 ( resid , params , c , & alpha , err ) result ( rst ) !! Computes statistics for the quality of fit for a regression !! model. real ( real64 ), intent ( in ) :: resid (:) !! An M-element array containing the model residual errors. real ( real64 ), intent ( in ) :: params (:) !! An N-element array containing the model parameters. real ( real64 ), intent ( in ) :: c (:,:) !! The N-by-N covariance matrix. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not sized correctly. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. type ( regression_statistics ), allocatable :: rst (:) !! A regression_statistics object containing the analysis !! results. end function module function calculate_regression_stats_r32 ( resid , params , c , & alpha , err ) result ( rst ) !! Computes statistics for the quality of fit for a regression !! model. real ( real32 ), intent ( in ) :: resid (:) !! An M-element array containing the model residual errors. real ( real32 ), intent ( in ) :: params (:) !! An N-element array containing the model parameters. real ( real32 ), intent ( in ) :: c (:,:) !! The N-by-N covariance matrix. real ( real32 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not sized correctly. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. type ( regression_statistics ), allocatable :: rst (:) !! A regression_statistics object containing the analysis !! results. end function end interface ! ****************************************************************************** ! EXPERIMENTAL DESIGN ! ------------------------------------------------------------------------------ interface get_full_factorial_matrix_size !! Computes the appropriate size for a full-factorial design table. module procedure :: get_full_factorial_matrix_size_int32 end interface interface full_factorial !! Computes a table with values scaled from 1 to N describing a !! full-factorial design. !! !! ```fortran !! program example !!     use iso_fortran_env !!     use fstats !!     implicit none !! !!     ! Local Variables !!     integer(int32) :: i, vars(3), tbl(24, 3) !! !!     ! Define the number of design points for each of the 3 factors to study !!     vars = [2, 4, 3] !! !!     ! Determine the design table !!     call full_factorial(vars, tbl) !! !!     ! Display the table !!     do i = 1, size(tbl, 1) !!         print *, tbl(i,:) !!     end do !! end program !! ``` !! The above program produces the following output. !! ```text !! 1           1           1 !! 1           1           2 !! 1           1           3 !! 1           2           1 !! 1           2           2 !! 1           2           3 !! 1           3           1 !! 1           3           2 !! 1           3           3 !! 1           4           1 !! 1           4           2 !! 1           4           3 !! 2           1           1 !! 2           1           2 !! 2           1           3 !! 2           2           1 !! 2           2           2 !! 2           2           3 !! 2           3           1 !! 2           3           2 !! 2           3           3 !! 2           4           1 !! 2           4           2 !! 2           4           3 !! ``` module procedure :: full_factorial_int32 end interface ! experimental_design_implementation.f90 interface module subroutine get_full_factorial_matrix_size_int32 ( vars , m , n , err ) !! Computes the appropriate size for a full-factorial design table. integer ( int32 ), intent ( in ) :: vars (:) !! An M-element array containing the M factors to study.  Each !! of the M entries to the array is expected to contain the !! number of options for that particular factor to explore. !! This value must be greater than or equal to 1. integer ( int32 ), intent ( out ) :: m !! The number of rows for the table. integer ( int32 ), intent ( out ) :: n !! The number of columns for the table. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_INVALID_INPUT_ERROR: Occurs if any items in vars are !!      less than 1. end subroutine module subroutine full_factorial_int32 ( vars , tbl , err ) !! Computes a table with values scaled from 1 to N describing a !! full-factorial design. integer ( int32 ), intent ( in ) :: vars (:) !! An M-element array containing the M factors to study. !! Each of the M entries to the array is expected to contain !! the number of options for that particular factor to explore. !! This value must be greater than or equal to 1. integer ( int32 ), intent ( out ) :: tbl (:,:) !! A table where the design will be written.  Use !! get_full_factorial_matrix_size to determine the appropriate !! table size. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_INVALID_INPUT_ERROR: Occurs if any items in vars are !!      less than 1. !! - FS_ARRAY_SIZE_ERROR: Occurs if tbl is not properly sized. end subroutine end interface ! ****************************************************************************** ! NONLINEAR REGRESSION ! ------------------------------------------------------------------------------ type iteration_controls !! Provides a collection of iteration control parameters. integer ( int32 ) :: max_iteration_count !! Defines the maximum number of iterations allowed. integer ( int32 ) :: max_function_evaluations !! Defines the maximum number of function evaluations allowed. real ( real64 ) :: gradient_tolerance !! Defines a tolerance on the gradient of the fitted function. real ( real64 ) :: change_in_solution_tolerance !! Defines a tolerance on the change in parameter values. real ( real64 ) :: residual_tolerance !! Defines a tolerance on the metric associated with the residual !! error. real ( real64 ) :: iteration_improvement_tolerance !! Defines a tolerance to ensure adequate improvement on each !! iteration. integer ( int32 ) :: max_iteration_between_updates !! Defines how many iterations can pass before a re-evaluation of !! the Jacobian matrix is forced. contains procedure , public :: set_to_default => lm_set_default_tolerances end type type convergence_info !! Provides information regarding convergence status. logical :: converge_on_gradient !! True if convergence on the gradient was achieved; else, false. real ( real64 ) :: gradient_value !! The value of the gradient test parameter. logical :: converge_on_solution_change !! True if convergence on the change in solution was achieved; else, !! false. real ( real64 ) :: solution_change_value !! The value of the change in solution parameter. logical :: converge_on_residual_parameter !! True if convergence on the residual error parameter was achieved; !! else, false. real ( real64 ) :: residual_value !! The value of the residual error parameter. logical :: reach_iteration_limit !! True if the solution did not converge in the allowed number of !! iterations. integer ( int32 ) :: iteration_count !! The iteration count. logical :: reach_function_evaluation_limit !! True if the solution did not converge in the allowed number of !! function evaluations. integer ( int32 ) :: function_evaluation_count !! The function evaluation count. logical :: user_requested_stop !! True if the user requested the stop; else, false. end type type lm_solver_options !! Options to control the Levenberg-Marquardt solver. integer ( int32 ) :: method !! The solver method to utilize. !! - FS_LEVENBERG_MARQUARDT_UPDATE: !! - FS_QUADRATIC_UPDATE: !! - FS_NIELSEN_UDPATE: real ( real64 ) :: finite_difference_step_size !! The step size used for the finite difference calculations of the !! Jacobian matrix. real ( real64 ) :: damping_increase_factor !! The factor to use when increasing the damping parameter. real ( real64 ) :: damping_decrease_factor !! The factor to use when decreasing the damping parameter. contains procedure , public :: set_to_default => lm_set_default_settings end type interface subroutine regression_function ( xdata , params , resid , stop ) use iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: xdata , params real ( real64 ), intent ( out ), dimension (:) :: resid logical , intent ( out ) :: stop end subroutine subroutine iteration_update ( iter , funvals , resid , params , step ) use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: iter real ( real64 ), intent ( in ) :: funvals (:), resid (:), params (:), step (:) end subroutine module subroutine regression_jacobian_1 ( fun , xdata , params , & jac , stop , f0 , f1 , step , err ) !! Computes the Jacobian matrix for a nonlinear regression problem. procedure ( regression_function ), intent ( in ), pointer :: fun !! A pointer to the regression_function to evaluate. real ( real64 ), intent ( in ) :: xdata (:) !! The M-element array containing x-coordinate data. real ( real64 ), intent ( in ) :: params (:) !! The N-element array containing the model parameters. real ( real64 ), intent ( out ) :: jac (:,:) !! The M-by-N matrix where the Jacobian will be written. logical , intent ( out ) :: stop !! A value that the user can set in fun forcing the !! evaluation process to stop prior to completion. real ( real64 ), intent ( in ), optional , target :: f0 (:) !! An optional M-element array containing the model values !!  using the current parameters as defined in m.  This input !! can be used to prevent the routine from performing a !! function evaluation at the model parameter state defined in !! params. real ( real64 ), intent ( out ), optional , target :: f1 (:) !! An optional M-element workspace array used for function !! evaluations. real ( real64 ), intent ( in ), optional :: step !! The differentiation step size.  The default is the square !! root of machine precision. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      properly sized. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. end subroutine module subroutine nonlinear_least_squares_1 ( fun , x , y , params , ymod , & resid , weights , maxp , minp , stats , alpha , controls , settings , & info , status , err ) !! Performs a nonlinear regression to fit a model using a version !! of the Levenberg-Marquardt algorithm. procedure ( regression_function ), intent ( in ), pointer :: fun !! A pointer to the regression_function to evaluate. real ( real64 ), intent ( in ) :: x (:) !! The M-element array containing independent data. real ( real64 ), intent ( in ) :: y (:) !! The M-element array containing dependent data. real ( real64 ), intent ( inout ) :: params (:) !! On input, the N-element array containing the initial estimate !! of the model parameters.  On output, the computed model !! parameters. real ( real64 ), intent ( out ) :: ymod (:) !! An M-element array where the modeled dependent data will !! be written. real ( real64 ), intent ( out ) :: resid (:) !! An M-element array where the model residuals will be !! written. real ( real64 ), intent ( in ), optional , target :: weights (:) !! An optional M-element array allowing the weighting of !! individual points. real ( real64 ), intent ( in ), optional , target :: maxp (:) !! An optional N-element array that can be used as upper limits !! on the parameter values.  If no upper limit is requested for !! a particular parameter, utilize a very large value.  The !! internal default is to utilize huge() as a value. real ( real64 ), intent ( in ), optional , target :: minp (:) !! An optional N-element array that can be used as lower limits !! on the parameter values.  If no lower limit is requested for !! a particalar parameter, utilize a very large magnitude, but !! negative, value.  The internal default is to utilize -huge() !! as a value. type ( regression_statistics ), intent ( out ), optional :: stats (:) !! An optional N-element array that, if supplied, will be used !! to return statistics about the fit for each parameter. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. type ( iteration_controls ), intent ( in ), optional :: controls !! An optional input providing custom iteration controls. type ( lm_solver_options ), intent ( in ), optional :: settings !! An optional input providing custom settings for the solver. type ( convergence_info ), intent ( out ), optional , target :: info !! An optional output that can be used to gain information about !! the iterative solution and the nature of the convergence. procedure ( iteration_update ), intent ( in ), pointer , optional :: status !! An optional pointer to a routine that can be used to extract !! iteration information. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      properly sized. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. !! - FS_UNDERDEFINED_PROBLEM_ERROR: Occurs if the problem posed !!      is underdetetermined (M < N). !! - FS_TOLERANCE_TOO_SMALL_ERROR: Occurs if any supplied !!      tolerances are too small to be practical. !! - FS_TOO_FEW_ITERATION_ERROR: Occurs if too few iterations !!      are allowed. end subroutine module subroutine ic_equal ( x , y ) type ( iteration_controls ), intent ( inout ) :: x type ( iteration_controls ), intent ( in ) :: y end subroutine module subroutine ci_equal ( x , y ) type ( convergence_info ), intent ( inout ) :: x type ( convergence_info ), intent ( in ) :: y end subroutine module subroutine lso_equal ( x , y ) type ( lm_solver_options ), intent ( inout ) :: x type ( lm_solver_options ), intent ( in ) :: y end subroutine module subroutine lm_set_default_tolerances ( x ) !! Sets the object to its default values. class ( iteration_controls ), intent ( inout ) :: x !! The iteration_controls object. end subroutine module subroutine lm_set_default_settings ( x ) !! Sets the object to its default values. class ( lm_solver_options ), intent ( inout ) :: x !! The lm_solver_options object. end subroutine end interface interface jacobian !! Computes the Jacobian matrix for a nonlinear regression problem. module procedure :: regression_jacobian_1 end interface interface nonlinear_least_squares !! Performs a nonlinear regression to fit a model using a version !! of the Levenberg-Marquardt algorithm. module procedure :: nonlinear_least_squares_1 end interface ! ****************************************************************************** ! ALLAN VARIANCE ! ------------------------------------------------------------------------------ ! allan.f90 interface module function allan_variance_1 ( x , dt , err ) result ( rst ) !! Computes the Allan variance of a data set. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element data set to analyze. real ( real64 ), intent ( in ), optional :: dt !! An optional input specifying the time increment between !! samples in x.  If not specified, this value is set to 1. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-2 array containing the results where M is N / 2 - 1 !! if N is even; else, M is (N - 1) / 2 - 1 if N is odd.  The !! first column contains the averaging times associated with !! the M results stored in the second column. end function end interface interface allan_variance !! Computes the Allan variance of a data set. !! !! Remarks !! !! This implementation computes the fully overlapped Allan variance !! using the method presented by Yadav et. al. !! !! Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, !! Viraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm !! for Fully Overlapped Allan Variance and Total Variance for Analysis and !! Modeling of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. !! 10.1109/LSENS.2018.2829799. module procedure :: allan_variance_1 end interface ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats.f90.html"},{"title":"fstats_errors.f90 – FSTATS","text":"Contents Modules fstats_errors Source Code fstats_errors.f90 Source Code ! A module providing a set of routines to handle errors for the FSTATS library. module fstats_errors use ferror use iso_fortran_env , only : int32 implicit none ! ****************************************************************************** ! ERROR CODES ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: FS_NO_ERROR = 0 integer ( int32 ), parameter :: FS_ARRAY_SIZE_ERROR = 10000 integer ( int32 ), parameter :: FS_MATRIX_SIZE_ERROR = 10001 integer ( int32 ), parameter :: FS_INVALID_INPUT_ERROR = 10002 integer ( int32 ), parameter :: FS_MEMORY_ERROR = 10003 integer ( int32 ), parameter :: FS_UNDERDEFINED_PROBLEM_ERROR = 10004 integer ( int32 ), parameter :: FS_TOLERANCE_TOO_SMALL_ERROR = 10005 integer ( int32 ), parameter :: FS_TOO_FEW_ITERATION_ERROR = 10006 ! ------------------------------------------------------------------------------ integer ( int32 ), private , parameter :: MESSAGE_SIZE = 1024 contains ! ------------------------------------------------------------------------------ !> @brief Reports a memory allocation related error. !! !! @param[in,out] err The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] code The error code returned by the allocation routine. subroutine report_memory_error ( err , fname , code ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ), intent ( in ) :: fname integer ( int32 ), intent ( in ) :: code ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) & \"A memory allocation error occurred with code \" , code , \".\" call err % report_error ( fname , trim ( msg ), FS_MEMORY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ !> @brief Reports an array size error. !! !! @param[in,out] err The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] name The name of the array. !! @param[in] expect The expected size of the array. !! @param[in] actual The actual size of the array. subroutine report_array_size_error ( err , fname , name , expect , actual ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ), intent ( in ) :: fname , name integer ( int32 ), intent ( in ) :: expect , actual ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Expected array \" // name // \" to be of length \" , & expect , \", but found it to be of length \" , actual , \".\" call err % report_error ( fname , trim ( msg ), FS_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ !> @brief Reports a matrix size error. !! !! @param[in,out] err The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] name The name of the matrix. !! @param[in] expect_rows The expected number of rows. !! @param[in] expect_cols The expected number of columns. !! @param[in] actual_rows The actual number of rows. !! @param[in] actual_cols The actual number of columns. subroutine report_matrix_size_error ( err , fname , name , expect_rows , & expect_cols , actual_rows , actual_cols ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ), intent ( in ) :: fname , name integer ( int32 ), intent ( in ) :: expect_rows , expect_cols , actual_rows , & actual_cols ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Expected matrix \" // name // \" to be of size (\" , & expect_rows , \", \" , expect_cols , \"), but found it to be of size (\" , & actual_rows , \", \" , actual_cols , \").\" call err % report_error ( fname , trim ( msg ), FS_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ !> @brief Reports an error relating to two arrays not being the same size !! when they should be the same size. !! !! @param[in,out] The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] name1 The name of the first array. !! @param[in] name2 The name of the second array. !! @param[in] size1 The size of the first array. !! @param[in] size2 The size of the second array. subroutine report_arrays_not_same_size_error ( err , fname , name1 , name2 , & size1 , size2 ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ), intent ( in ) :: fname , name1 , name2 integer ( int32 ), intent ( in ) :: size1 , size2 ! Local Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Array \" // name1 // \" and array \" // name2 // & \"were expected to be the same size, but instead were found \" // & \"to be sized \" , size1 , \" and \" , size2 , \" respectively.\" call err % report_error ( fname , trim ( msg ), FS_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ !> @brief Reports an underdefined problem error. !! !! @param[in,out] The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] expect The expected minimum number of equations. !! @param[in] actual The actual number of equations. subroutine report_underdefined_error ( err , fname , expect , actual ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ), intent ( in ) :: fname integer ( int32 ), intent ( in ) :: expect , actual ! Local Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"The problem is underdefined.  The number of \" // & \"equations was found to be \" , actual , & \", but must be at least equal to the number of unknowns \" , & expect , \".\" call err % report_error ( fname , trim ( msg ), FS_UNDERDEFINED_PROBLEM_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ !> @brief Reports an iteration count error. !! !! @param[in,out] The error handling object. !! @param[in] fname The name of the routine in which the error occurred. !! @param[in] msg The error message. !! @param[in] mincount The minimum iteration count expected. subroutine report_iteration_count_error ( err , fname , msg , mincount ) ! Arguments class ( errors ), intent ( inout ) :: err character ( len = * ) :: fname , msg integer ( int32 ), intent ( in ) :: mincount ! Local Variables character ( len = MESSAGE_SIZE ) :: emsg ! Process write ( emsg , 100 ) msg // \"  A minimum of \" , mincount , \" is expected.\" call err % report_error ( fname , trim ( emsg ), FS_TOO_FEW_ITERATION_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_errors.f90.html"},{"title":"levenberg_marquardt.f90 – FSTATS","text":"Contents Submodules levenberg_marquardt Source Code levenberg_marquardt.f90 Source Code submodule ( fstats ) levenberg_marquardt ! REFERENCES: ! 1. https://people.duke.edu/~hpgavin/ExperimentalSystems/lm.pdf use linalg use fstats_errors contains ! ------------------------------------------------------------------------------ module subroutine regression_jacobian_1 ( fun , xdata , params , & jac , stop , f0 , f1 , step , err ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), params (:) real ( real64 ), intent ( out ) :: jac (:,:) logical , intent ( out ) :: stop real ( real64 ), intent ( in ), optional , target :: f0 (:) real ( real64 ), intent ( out ), optional , target :: f1 (:) real ( real64 ), intent ( in ), optional :: step class ( errors ), intent ( inout ), optional , target :: err ! Local Variables real ( real64 ) :: h integer ( int32 ) :: m , n , flag , expected , actual real ( real64 ), pointer :: f1p (:), f0p (:) real ( real64 ), allocatable , target :: f1a (:), f0a (:), work (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( step )) then h = step else h = sqrt ( epsilon ( h )) end if m = size ( xdata ) n = size ( params ) ! Input Size Checking if ( size ( jac , 1 ) /= m . or . size ( jac , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"regression_jacobian_1\" , & \"JAC\" , m , n , size ( jac , 1 ), size ( jac , 2 )) return end if if ( present ( f0 )) then ! Check Size if ( size ( f0 ) /= m ) then call report_array_size_error ( errmgr , \"regression_jacobian_1\" , & \"F0\" , m , size ( f0 )) return end if f0p ( 1 : m ) => f0 else ! Allocate space, and fill the array with the current function ! results allocate ( f0a ( m ), stat = flag ) if ( flag /= 0 ) go to 20 f0p ( 1 : m ) => f0a call fun ( xdata , params , f0p , stop ) if ( stop ) return end if if ( present ( f1 )) then ! Check Size if ( size ( f1 ) /= m ) then call report_array_size_error ( errmgr , \"regression_jacobian_1\" , & \"F1\" , m , size ( f1 )) return end if f1p ( 1 : m ) => f1 else ! Allocate space allocate ( f1a ( m ), stat = flag ) if ( flag /= 0 ) go to 20 f1p ( 1 : m ) => f1a end if ! Allocate a workspace array the same size as params allocate ( work ( n ), stat = flag ) if ( flag /= 0 ) go to 20 ! Compute the Jacobian call jacobian_finite_diff ( fun , xdata , params , f0p , jac , f1p , & stop , h , work ) ! End return ! Memroy Allocation Error Handling 20 continue call report_memory_error ( errmgr , \"regression_jacobian_1\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ module subroutine nonlinear_least_squares_1 ( fun , x , y , params , ymod , & resid , weights , maxp , minp , stats , alpha , controls , settings , info , & status , err ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: x (:), y (:) real ( real64 ), intent ( inout ) :: params (:) real ( real64 ), intent ( out ) :: ymod (:), resid (:) real ( real64 ), intent ( in ), optional , target :: weights (:), maxp (:), & minp (:) type ( regression_statistics ), intent ( out ), optional :: stats (:) real ( real64 ), intent ( in ), optional :: alpha type ( iteration_controls ), intent ( in ), optional :: controls type ( lm_solver_options ), intent ( in ), optional :: settings type ( convergence_info ), intent ( out ), optional , target :: info procedure ( iteration_update ), intent ( in ), pointer , optional :: status class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: too_small = 1.0d-14 integer ( int32 ), parameter :: min_iter_count = 2 integer ( int32 ), parameter :: min_fun_count = 10 integer ( int32 ), parameter :: min_update_count = 1 ! Local Variables logical :: stop integer ( int32 ) :: m , n , actual , expected , flag real ( real64 ), pointer :: w (:), pmax (:), pmin (:) real ( real64 ), allocatable , target :: defaultWeights (:), maxparam (:), & minparam (:), JtWJ (:,:) type ( iteration_controls ) :: tol type ( lm_solver_options ) :: opt type ( convergence_info ) :: cInfo class ( errors ), pointer :: errmgr type ( errors ), target :: deferr type ( convergence_info ), target :: defaultinfo type ( convergence_info ), pointer :: inf ! Initialization stop = . false . m = size ( x ) n = size ( params ) if ( present ( info )) then inf => info else inf => defaultinfo end if if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( controls )) then tol = controls else call tol % set_to_default () end if if ( present ( settings )) then opt = settings else call opt % set_to_default () end if ! Input Checking if ( size ( y ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares_1\" , & \"y\" , m , size ( y )) return end if if ( size ( ymod ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares_1\" , & \"ymod\" , m , size ( ymod )) return end if if ( size ( resid ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares_1\" , & \"resid\" , m , size ( resid )) return end if if ( m < n ) then call report_underdefined_error ( errmgr , & \"nonlinear_least_squares_1\" , n , m ) return end if ! Tolerance Checking if ( tol % gradient_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares_1\" , & \"The gradient tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % change_in_solution_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares_1\" , & \"The change in solution tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % residual_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares_1\" , & \"The residual error tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % iteration_improvement_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares_1\" , & \"The iteration improvement tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if ! Iteration Count Checking if ( tol % max_iteration_count < min_iter_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares_1\" , & \"Too few iterations were specified.\" , & min_iter_count ) return end if if ( tol % max_function_evaluations < min_fun_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares_1\" , & \"Too few function evaluations were specified.\" , & min_fun_count ) return end if if ( tol % max_iteration_between_updates < min_update_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares_1\" , & \"Too few iterations between updates were specified.\" , & min_update_count ) return end if ! Optional Array Arguments (weights, parameter limits, etc.) if ( present ( weights )) then if ( size ( weights ) < m ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares_1\" , \"weights\" , m , size ( weights )) return end if w ( 1 : m ) => weights ( 1 : m ) else allocate ( defaultWeights ( m ), source = 1.0d0 , stat = flag ) if ( flag /= 0 ) go to 50 w ( 1 : m ) => defaultWeights ( 1 : m ) end if if ( present ( maxp )) then if ( size ( maxp ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares_1\" , \"maxp\" , n , size ( maxp )) return end if pmax ( 1 : n ) => maxp ( 1 : n ) else allocate ( maxparam ( n ), source = huge ( 1.0d0 ), stat = flag ) if ( flag /= 0 ) go to 50 pmax ( 1 : n ) => maxparam ( 1 : n ) end if if ( present ( minp )) then if ( size ( minp ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares_1\" , \"minp\" , n , size ( minp )) return end if pmin ( 1 : n ) => minp ( 1 : n ) else allocate ( minparam ( n ), source = - huge ( 1.0d0 ), stat = flag ) if ( flag /= 0 ) go to 50 pmin ( 1 : n ) => minparam ( 1 : n ) end if ! Local Memory Allocations allocate ( JtWJ ( n , n ), stat = flag ) if ( flag /= 0 ) go to 50 ! Process call lm_solve ( fun , x , y , params , w , pmax , pmin , tol , opt , ymod , & resid , JtWJ , inf , stop , errmgr , status ) ! Statistical Parameters if ( present ( stats )) then if ( size ( stats ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares_1\" , \"stats\" , n , size ( stats )) return end if ! Compute the covariance matrix call mtx_inverse ( JtWJ , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the statistics stats = calculate_regression_statistics ( resid , params , JtWJ , & alpha , errmgr ) end if ! End return ! Memory Error Handler 50 continue call report_memory_error ( errmgr , \"nonlinear_least_squares_1\" , flag ) return end subroutine ! ****************************************************************************** ! SETTINGS DEFAULTS ! ------------------------------------------------------------------------------ ! Sets up default tolerances. module subroutine lm_set_default_tolerances ( x ) ! Arguments class ( iteration_controls ), intent ( inout ) :: x ! Set defaults x % max_iteration_count = 500 x % max_function_evaluations = 5000 x % max_iteration_between_updates = 10 x % gradient_tolerance = 1.0d-8 x % residual_tolerance = 0.5d-2 x % change_in_solution_tolerance = 1.0d-6 x % iteration_improvement_tolerance = 1.0d-1 end subroutine ! ------------------------------------------------------------------------------ ! Sets up default solver settings. module subroutine lm_set_default_settings ( x ) ! Arguments class ( lm_solver_options ), intent ( inout ) :: x ! Set defaults x % method = FS_LEVENBERG_MARQUARDT_UPDATE x % finite_difference_step_size = sqrt ( epsilon ( 1.0d0 )) x % damping_increase_factor = 1 1.0d0 x % damping_decrease_factor = 9.0d0 end subroutine ! ****************************************************************************** ! OPERATORS ! ------------------------------------------------------------------------------ module subroutine ic_equal ( x , y ) type ( iteration_controls ), intent ( inout ) :: x type ( iteration_controls ), intent ( in ) :: y x % max_iteration_count = y % max_iteration_count x % max_function_evaluations = y % max_function_evaluations x % gradient_tolerance = y % gradient_tolerance x % change_in_solution_tolerance = y % change_in_solution_tolerance x % residual_tolerance = y % residual_tolerance x % iteration_improvement_tolerance = y % iteration_improvement_tolerance x % max_iteration_between_updates = y % max_iteration_between_updates end subroutine ! ------------------------------------------------------------------------------ module subroutine ci_equal ( x , y ) type ( convergence_info ), intent ( inout ) :: x type ( convergence_info ), intent ( in ) :: y x % converge_on_gradient = y % converge_on_gradient x % gradient_value = y % gradient_value x % converge_on_solution_change = y % converge_on_solution_change x % solution_change_value = y % solution_change_value x % converge_on_residual_parameter = y % converge_on_residual_parameter x % residual_value = y % residual_value x % reach_iteration_limit = y % reach_iteration_limit x % iteration_count = y % iteration_count x % reach_function_evaluation_limit = y % reach_function_evaluation_limit x % function_evaluation_count = y % function_evaluation_count x % user_requested_stop = y % user_requested_stop end subroutine ! ------------------------------------------------------------------------------ module subroutine lso_equal ( x , y ) type ( lm_solver_options ), intent ( inout ) :: x type ( lm_solver_options ), intent ( in ) :: y x % method = y % method x % finite_difference_step_size = y % finite_difference_step_size x % damping_increase_factor = y % damping_increase_factor x % damping_decrease_factor = y % damping_decrease_factor end subroutine ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ ! Computes the Jacobian matrix via a forward difference. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - params: The model parameters (N-by-1) ! - f0: The current model estimate (M-by-1) ! - step: The differentiation step size ! ! Outputs: ! - jac: The Jacobian matrix (M-by-N) ! - f1: A workspace array for the model output (M-by-1) ! - stop: A flag allowing the user to terminate model execution ! - work: A workspace array for the model parameters (N-by-1) subroutine jacobian_finite_diff ( fun , xdata , params , f0 , jac , f1 , & stop , step , work ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), params (:) real ( real64 ), intent ( in ) :: f0 (:) real ( real64 ), intent ( out ) :: jac (:,:) real ( real64 ), intent ( out ) :: f1 (:), work (:) logical , intent ( out ) :: stop real ( real64 ), intent ( in ) :: step ! Local Variables integer ( int32 ) :: i , n ! Initialization n = size ( params ) ! Cycle over each column of the Jacobian and calculate the derivative ! via a forward difference scheme ! ! J(i,j) = df(i) / dx(j) work = params do i = 1 , n work ( i ) = work ( i ) + step call fun ( xdata , work , f1 , stop ) if ( stop ) return jac (:, i ) = ( f1 - f0 ) / step work ( i ) = params ( i ) end do end subroutine ! ------------------------------------------------------------------------------ ! Computes a rank-1 update to the Jacobian matrix ! ! Inputs: ! - pOld: previous set of parameters (N-by-1) ! - yOld: model evaluation at previous set of parameters (M-by-1) ! - jac: current Jacobian estimate (M-by-N) ! - p: current set of parameters (N-by-1) ! - y: model evaluation at current set of parameters (M-by-1) ! ! Outputs: ! - jac: updated Jacobian matrix (M-by-N) (dy * dp**T + J) ! - dp: p - pOld (N-by-1) ! - dy: (y - yOld - J * dp) / (dp' * dp) (M-by-1) subroutine broyden_update ( pOld , yOld , jac , p , y , dp , dy ) ! Arguments real ( real64 ), intent ( in ) :: pOld (:), yOld (:), p (:), y (:) real ( real64 ), intent ( inout ) :: jac (:,:) real ( real64 ), intent ( out ) :: dp (:), dy (:) ! Local Variables real ( real64 ) :: h2 ! Process dp = p - pOld h2 = dot_product ( dp , dp ) dy = y - yOld - matmul ( jac , dp ) call recip_mult_array ( h2 , dy ) ! compute dy / h2 call rank1_update ( 1.0d0 , dy , dp , jac ) end subroutine ! ------------------------------------------------------------------------------ ! Updates the Levenberg-Marquardt matrix by either computing a new Jacobian ! matrix or performing a rank-1 update to the existing Jacobian matrix. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - pOld: previous set of parameters (N-by-1) ! - yOld: model evaluation at previous set of parameters (M-by-1) ! - dX2: The previous change in the Chi-squared criteria ! - jac: current Jacobian estimate (M-by-N) ! - p: current set of parameters (N-by-1) ! - weights: A weighting vector (M-by-1) ! - neval: Current number of function evaluations ! - update: Set to true to force an update of the Jacobian; else, set to !       false to let the program choose based upon the change in the !       Chi-squared parameter. ! - step: The differentiation step size ! ! Outputs: ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - JtWdy: linearized fitting vector (N-by-1) ! - X2: Updated Chi-squared criteria ! - yNew: model evaluated with parameters of p (M-by-1) ! - jac: updated Jacobian matrix (M-by-N) ! - neval: updated count of function evaluations ! - stop: A flag allowing the user to terminate model execution ! - work: A workspace array (N+M-by-1) ! - mwork: A workspace matrix (N-by-M) ! - update: Reset to false if a Jacobian evaluation was performed. subroutine lm_matrix ( fun , xdata , ydata , pOld , yOld , dX2 , jac , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , yNew , stop , work , mwork ) ! Arguments procedure ( regression_function ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), pOld (:), yOld (:), & p (:), weights (:) real ( real64 ), intent ( in ) :: dX2 , step real ( real64 ), intent ( inout ) :: jac (:,:) integer ( int32 ), intent ( inout ) :: neval logical , intent ( inout ) :: update real ( real64 ), intent ( out ) :: JtWJ (:,:), JtWdy (:) real ( real64 ), intent ( out ) :: X2 , mwork (:,:), yNew (:) logical , intent ( out ) :: stop real ( real64 ), intent ( out ), target :: work (:) ! Local Variables integer ( int32 ) :: m , n real ( real64 ), pointer :: w1 (:), w2 (:) ! Initialization m = size ( xdata ) n = size ( p ) w1 ( 1 : m ) => work ( 1 : m ) w2 ( 1 : n ) => work ( m + 1 : n + m ) ! Perform the next function evaluation call fun ( xdata , p , yNew , stop ) neval = neval + 1 if ( stop ) return ! Update or recompute the Jacobian matrix if ( dX2 > 0 . or . update ) then ! Recompute the Jacobian call jacobian_finite_diff ( fun , xdata , p , yNew , jac , w1 , & stop , step , w2 ) neval = neval + n if ( stop ) return update = . false . else ! Simply perform a rank-1 update to the Jacobian call broyden_update ( pOld , yOld , jac , p , yNew , w2 , w1 ) end if ! Update the Chi-squared estimate w1 = ydata - yNew X2 = dot_product ( w1 , w1 * weights ) ! Compute J**T * (W .* dY) w1 = w1 * weights call mtx_mult (. true ., 1.0d0 , jac , w1 , 0.0d0 , JtWdy ) ! Update the Hessian ! First: J**T * W = MWORK ! Second: (J**T * W) * J call diag_mtx_mult (. false ., . true ., 1.0d0 , weights , jac , 0.0d0 , mwork ) call mtx_mult (. false ., . false ., 1.0d0 , mwork , jac , 0.0d0 , JtWJ ) end subroutine ! ------------------------------------------------------------------------------ ! Performs a single iteration of the Levenberg-Marquardt algorithm. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - p: current set of parameters (N-by-1) ! - neval: current number of function evaluations ! - niter: current iteration number ! - update: set to 1 to use Marquardt's modification; else, ! - step: the differentiation step size ! - lambda: LM damping parameter ! - maxP: maximum limits on the parameters.  Use huge() or larger for no constraints (N-by-1) ! - minP: minimum limits on the parameters.  Use -huge() or smaller for no constraints (N-by-1) ! - weights: a weighting vector (M-by-1) ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - JtWdy: linearized fitting vector (N-by-1) ! ! Outputs: ! - JtWJ: overwritten LU factorization of the original matrix (N-by-N) ! - h: The new estimate of the change in parameter (N-by-1) ! - pNew: The new parameter estimates (N-by-1) ! - deltaY: The new difference between data and model (M-by-1) ! - yNew: model evaluated with parameters of pNew (M-by-1) ! - neval: updated count of function evaluations ! - niter: updated current iteration number ! - X2: updated Chi-squared criteria ! - stop: A flag allowing the user to terminate model execution ! - iwork: A workspace array (N-by-1) ! - err: An error handling mechanism subroutine lm_iter ( fun , xdata , ydata , p , neval , niter , update , lambda , & maxP , minP , weights , JtWJ , JtWdy , h , pNew , deltaY , yNew , X2 , X2Old , & alpha , stop , iwork , err , status ) ! Arguments procedure ( regression_function ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), p (:), maxP (:), & minP (:), weights (:), JtWdy (:) real ( real64 ), intent ( in ) :: lambda , X2Old integer ( int32 ), intent ( inout ) :: neval , niter integer ( int32 ), intent ( in ) :: update real ( real64 ), intent ( inout ) :: JtWJ (:,:) real ( real64 ), intent ( out ) :: h (:), pNew (:), deltaY (:), yNew (:) real ( real64 ), intent ( out ) :: X2 , alpha logical , intent ( out ) :: stop integer ( int32 ), intent ( out ) :: iwork (:) class ( errors ), intent ( inout ) :: err procedure ( iteration_update ), intent ( in ), pointer , optional :: status ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: dpJh ! Initialization n = size ( p ) ! Increment the iteration counter niter = niter + 1 ! Solve the linear system to determine the change in parameters ! A is N-by-N and is stored in JtWJ ! b is N-by-1 if ( update == FS_LEVENBERG_MARQUARDT_UPDATE ) then ! Compute: h = A \\ b ! A = J**T * W * J + lambda * diag(J**T * W * J) ! b = J**T * W * dy do i = 1 , n JtWJ ( i , i ) = JtWJ ( i , i ) * ( 1.0d0 + lambda ) h ( i ) = JtWdy ( i ) end do else ! Compute: h = A \\ b ! A = J**T * W * J + lambda * I ! b = J**T * W * dy do i = 1 , n JtWJ ( i , i ) = JtWJ ( i , i ) + lambda h ( i ) = JtWdy ( i ) end do end if call lu_factor ( JtWJ , iwork , err ) ! overwrites JtWJ with [L\\U] if ( err % has_error_occurred ()) return ! if JtWJ is singular call solve_lu ( JtWJ , iwork , h ) ! solution stored in h ! Compute the new attempted solution, and apply any constraints do i = 1 , n pNew ( i ) = min ( max ( minP ( i ), h ( i ) + p ( i )), maxP ( i )) end do ! Update the residual error call fun ( xdata , pNew , yNew , stop ) neval = neval + 1 deltaY = ydata - yNew if ( stop ) return ! Update the Chi-squared estimate X2 = dot_product ( deltaY , deltaY * weights ) ! Perform a quadratic line update in the H direction, if necessary if ( update == FS_QUADRATIC_UPDATE ) then dpJh = dot_product ( JtWdy , h ) alpha = abs ( dpJh / ( 0.5d0 * ( X2 - X2Old ) + 2.0d0 * dpJh )) h = alpha * h do i = 1 , n pNew ( i ) = min ( max ( minP ( i ), p ( i ) + h ( i )), maxP ( i )) end do call fun ( xdata , pNew , yNew , stop ) if ( stop ) return neval = neval + 1 deltaY = ydata - yNew X2 = dot_product ( deltaY , deltaY * weights ) end if ! Update the status of the iteration, if needed if ( present ( status )) then call status ( niter , yNew , deltaY , pNew , h ) end if end subroutine ! ------------------------------------------------------------------------------ ! A Levenberg-Marquardt solver. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - p: current set of parameters (N-by-1) ! - weights: a weighting vector (M-by-1) ! - maxP: maximum limits on the parameters.  Use huge() or larger for no constraints (N-by-1) ! - minP: minimum limits on the parameters.  Use -huge() or smaller for no constraints (N-by-1) ! - controls: an iteration_controls instance containing solution tolerances ! ! Outputs: ! - p: solution (N-by-1) ! - y: model results at p (M-by-1) ! - resid: residual (ydata - y) (M-by-1) ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - opt: a convergence_info object containing information regarding !       convergence of the iteration ! - stop: A flag allowing the user to terminate model execution ! - err: An error handling object subroutine lm_solve ( fun , xdata , ydata , p , weights , maxP , minP , controls , & opt , y , resid , JtWJ , info , stop , err , status ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), weights (:), maxP (:), & minP (:) real ( real64 ), intent ( inout ) :: p (:) class ( iteration_controls ), intent ( in ) :: controls class ( lm_solver_options ), intent ( in ) :: opt real ( real64 ), intent ( out ) :: y (:), resid (:), JtWJ (:,:) class ( convergence_info ), intent ( out ) :: info logical , intent ( out ) :: stop class ( errors ), intent ( inout ) :: err procedure ( iteration_update ), intent ( in ), pointer , optional :: status ! Local Variables logical :: update integer ( int32 ) :: i , m , n , dof , flag , neval , niter , nupdate real ( real64 ) :: dX2 , X2 , X2Old , X2Try , lambda , alpha , nu , step real ( real64 ), allocatable :: pOld (:), yOld (:), J (:,:), JtWdy (:), & work (:), mwork (:,:), pTry (:), yTemp (:), JtWJc (:,:), h (:) integer ( int32 ), allocatable :: iwork (:) character ( len = :), allocatable :: errmsg ! Initialization update = . true . m = size ( xdata ) n = size ( p ) dof = m - n niter = 0 step = opt % finite_difference_step_size stop = . false . info % user_requested_stop = . false . ! Local Memory Allocation allocate ( pOld ( n ), source = 0.0d0 , stat = flag ) if ( flag == 0 ) allocate ( yOld ( m ), source = 0.0d0 , stat = flag ) if ( flag == 0 ) allocate ( J ( m , n ), stat = flag ) if ( flag == 0 ) allocate ( JtWdy ( n ), stat = flag ) if ( flag == 0 ) allocate ( work ( m + n ), stat = flag ) if ( flag == 0 ) allocate ( mwork ( n , m ), stat = flag ) if ( flag == 0 ) allocate ( pTry ( n ), stat = flag ) if ( flag == 0 ) allocate ( h ( n ), stat = flag ) if ( flag == 0 ) allocate ( yTemp ( m ), stat = flag ) if ( flag == 0 ) allocate ( JtWJc ( n , n ), stat = flag ) if ( flag == 0 ) allocate ( iwork ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Perform an initial function evaluation call fun ( xdata , p , y , stop ) neval = 1 ! Evaluate the problem matrices call lm_matrix ( fun , xdata , ydata , pOld , yOld , 1.0d0 , J , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , y , stop , work , mwork ) if ( stop ) go to 5 X2Old = X2 JtWJc = JtWJ ! Determine an initial value for lambda if ( opt % method == FS_LEVENBERG_MARQUARDT_UPDATE ) then lambda = 1.0d-2 else call extract_diagonal ( JtWJ , work ( 1 : n )) lambda = 1.0d-2 * maxval ( work ( 1 : n )) nu = 2.0d0 end if ! Main Loop main : do while ( niter < controls % max_iteration_count ) ! Compute the linear solution at the current solution estimate and ! update the new parameter estimates call lm_iter ( fun , xdata , ydata , p , neval , niter , opt % method , & lambda , maxP , minP , weights , JtWJc , JtWdy , h , pTry , resid , & yTemp , X2Try , X2Old , alpha , stop , iwork , err , status ) if ( stop ) go to 5 if ( err % has_error_occurred ()) return ! Update the Chi-squared estimate, update the damping parameter ! lambda, and, if necessary, update the matrices call lm_update ( fun , xdata , ydata , pOld , p , pTry , yOld , y , h , dX2 , & X2Old , X2 , X2Try , lambda , alpha , nu , JtWdy , JtWJ , J , weights , & niter , neval , update , step , work , mwork , controls , opt , stop ) if ( stop ) go to 5 JtWJc = JtWJ ! Determine the matrix update scheme nupdate = nupdate + 1 if ( opt % method == FS_QUADRATIC_UPDATE ) then update = mod ( niter , 2 * n ) > 0 else if ( nupdate >= controls % max_iteration_between_updates ) then update = . true . nupdate = 0 end if ! Test for convergence if ( lm_check_convergence ( controls , dof , resid , niter , neval , & JtWdy , h , p , X2 , info )) & then exit main end if end do main ! End return ! User Requested End 5 continue info % user_requested_stop = . true . return ! Memory Error Handling 10 continue allocate ( character ( len = 512 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error code \" , flag , \".\" call err % report_error ( \"lm_solve\" , & trim ( errmsg ), ML_OUT_OF_MEMORY_ERROR ) return ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ ! subroutine lm_update ( fun , xdata , ydata , pOld , p , pTry , yOld , y , h , dX2 , & X2old , X2 , X2try , lambda , alpha , nu , JtWdy , JtWJ , J , weights , niter , & neval , update , step , work , mwork , controls , opt , stop ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), X2try , h (:), step , & pTry (:), weights (:), alpha real ( real64 ), intent ( inout ) :: pOld (:), p (:), yOld (:), y (:), lambda , & JtWdy (:), dX2 , X2 , X2old , JtWJ (:,:), J (:,:), nu real ( real64 ), intent ( out ) :: work (:), mwork (:,:) integer ( int32 ), intent ( in ) :: niter integer ( int32 ), intent ( inout ) :: neval logical , intent ( inout ) :: update class ( iteration_controls ), intent ( in ) :: controls class ( lm_solver_options ), intent ( in ) :: opt logical , intent ( out ) :: stop ! Local Variables integer ( int32 ) :: n real ( real64 ) :: rho ! Initialization n = size ( p ) ! Process if ( opt % method == FS_LEVENBERG_MARQUARDT_UPDATE ) then call extract_diagonal ( JtWJ , work ( 1 : n )) work ( 1 : n ) = lambda * work ( 1 : n ) * h + JtWdy else work ( 1 : n ) = lambda * h + JtWdy end if rho = ( X2 - X2try ) / abs ( dot_product ( h , work ( 1 : n ))) if ( rho > controls % iteration_improvement_tolerance ) then ! Things are getting better at an acceptable rate dX2 = X2 - X2old X2old = X2 pOld = p yOld = y p = pTry ! Recompute the matrices call lm_matrix ( fun , xdata , ydata , pOld , yOld , dX2 , J , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , y , stop , work , mwork ) if ( stop ) return ! Decrease lambda select case ( opt % method ) case ( FS_LEVENBERG_MARQUARDT_UPDATE ) lambda = max ( lambda / opt % damping_decrease_factor , 1.0d-7 ) case ( FS_QUADRATIC_UPDATE ) lambda = max ( lambda / ( 1.0d0 + alpha ), 1.0d-7 ) case ( FS_NIELSEN_UPDATE ) lambda = lambda * max ( 1.0d0 / 3.0d0 , & 1.0d0 - ( 2.0d0 * rho - 1.0d0 ** 3 )) nu = 2.0d0 end select else ! The iteration is not improving in a satisfactory manner X2 = X2old if ( mod ( niter , 2 * n ) /= 0 ) then call lm_matrix ( fun , xdata , ydata , pOld , yOld , - 1.0d0 , J , p , & weights , neval , update , step , JtWJ , JtWdy , dX2 , y , stop , & work , mwork ) if ( stop ) return end if ! Increase lambda select case ( opt % method ) case ( FS_LEVENBERG_MARQUARDT_UPDATE ) lambda = min ( lambda * opt % damping_increase_factor , 1.0d7 ) case ( FS_QUADRATIC_UPDATE ) lambda = lambda + abs (( X2try - X2 ) / 2.0d0 / alpha ) case ( FS_NIELSEN_UPDATE ) lambda = lambda * nu nu = 2.0d0 * nu end select end if end subroutine ! ------------------------------------------------------------------------------ ! Checks the Levenberg-Marquardt solution against the convergence criteria. ! ! Inputs: ! - controls: the solution controls and convergence criteria ! - dof: the statistical degrees of freedom of the system (M - N) ! - resid: the residual error (M-by-1) ! - niter: the number of iterations ! - neval: the number of function evaluations ! - JtWdy: linearized fitting vector (N-by-1) ! - h: the change in parameter (solution) values (N-by-1) ! - p: the parameter (solution) values (N-by-1) ! - X2: the Chi-squared estimate ! ! Outputs: ! - info: The convergence information. ! - rst: True if convergence was achieved; else, false. function lm_check_convergence ( controls , dof , resid , niter , neval , & JtWdy , h , p , X2 , info ) result ( rst ) ! Arguments class ( iteration_controls ), intent ( in ) :: controls real ( real64 ), intent ( in ) :: resid (:), JtWdy (:), h (:), p (:), X2 integer ( int32 ), intent ( in ) :: dof , niter , neval class ( convergence_info ), intent ( out ) :: info logical :: rst ! Initialization rst = . false . ! Iteration Checks info % iteration_count = niter if ( niter >= controls % max_iteration_count ) then info % reach_iteration_limit = . true . rst = . true . else info % reach_iteration_limit = . false . end if info % function_evaluation_count = neval if ( neval >= controls % max_function_evaluations ) then info % reach_function_evaluation_limit = . true . rst = . true . else info % reach_function_evaluation_limit = . false . end if info % gradient_value = maxval ( abs ( JtWdy )) if ( info % gradient_value < controls % gradient_tolerance . and . niter > 2 ) & then info % converge_on_gradient = . true . rst = . true . else info % converge_on_gradient = . false . end if info % solution_change_value = maxval ( abs ( h ) / ( abs ( p ) + 1.0d-12 )) if ( info % solution_change_value < & controls % change_in_solution_tolerance . and . niter > 2 ) & then info % converge_on_solution_change = . true . rst = . true . else info % converge_on_solution_change = . false . end if info % residual_value = X2 / dof if ( info % residual_value < controls % residual_tolerance . and . niter > 2 ) & then info % converge_on_residual_parameter = . true . rst = . true . else info % converge_on_residual_parameter = . false . end if end function ! ------------------------------------------------------------------------------ ! Extracts the diagonal (D - MIN(M,N)) from a matrix (X - M-by-N). subroutine extract_diagonal ( x , d ) ! Arguments real ( real64 ), intent ( in ) :: x (:,:) real ( real64 ), intent ( out ) :: d (:) ! Local Variables integer ( int32 ) :: i , m , n , mn ! Process m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) do i = 1 , mn d ( i ) = x ( i , i ) end do end subroutine ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\levenberg_marquardt.f90.html"},{"title":"regression_implementation.f90 – FSTATS","text":"Contents Submodules regression_implementation Source Code regression_implementation.f90 Source Code submodule ( fstats ) regression_implementation use linalg use fstats_errors contains ! ------------------------------------------------------------------------------ module subroutine coefficient_matrix_real64 ( order , intercept , x , c , err ) ! Arguments integer ( int32 ), intent ( in ) :: order logical , intent ( in ) :: intercept real ( real64 ), intent ( in ) :: x (:) real ( real64 ), intent ( out ) :: c (:,:) class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , start , npts , ncols class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncols = order if ( intercept ) ncols = ncols + 1 ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"coefficient_matrix_real64\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( c , 1 ) /= npts . or . size ( c , 2 ) /= ncols ) then call report_matrix_size_error ( errmgr , \"coefficient_matrix_real64\" , & \"c\" , npts , ncols , size ( c , 1 ), size ( c , 2 )) return end if ! Process if ( intercept ) then c (:, 1 ) = one c (:, 2 ) = x start = 3 else c (:, 1 ) = x start = 2 end if if ( start >= ncols ) return do i = start , ncols c (:, i ) = c (:, i - 1 ) * x end do end subroutine ! -------------------- module subroutine coefficient_matrix_real32 ( order , intercept , x , c , err ) ! Arguments integer ( int32 ), intent ( in ) :: order logical , intent ( in ) :: intercept real ( real32 ), intent ( in ) :: x (:) real ( real32 ), intent ( out ) :: c (:,:) class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real32 ), parameter :: one = 1.0 ! Local Variables integer ( int32 ) :: i , start , npts , ncols class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncols = order if ( intercept ) ncols = ncols + 1 ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"coefficient_matrix_real32\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( c , 1 ) /= npts . or . size ( c , 2 ) /= ncols ) then call report_matrix_size_error ( errmgr , \"coefficient_matrix_real32\" , & \"c\" , npts , ncols , size ( c , 1 ), size ( c , 2 )) return end if ! Process if ( intercept ) then c (:, 1 ) = one c (:, 2 ) = x start = 3 else c (:, 1 ) = x start = 2 end if if ( start >= ncols ) return do i = start , ncols c (:, i ) = c (:, i - 1 ) * x end do end subroutine ! ------------------------------------------------------------------------------ module subroutine covariance_matrix_real64 ( x , c , err ) ! Arguments real ( real64 ), intent ( in ) :: x (:,:) real ( real64 ), intent ( out ) :: c (:,:) class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: npts , ncoeffs , flag real ( real64 ), allocatable :: xtx (:,:) ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x , 1 ) ncoeffs = size ( x , 2 ) ! Input Checking if ( size ( c , 1 ) /= ncoeffs . or . size ( c , 2 ) /= ncoeffs ) then call report_matrix_size_error ( errmgr , \"covariance_matrix_real64\" , & \"c\" , ncoeffs , ncoeffs , size ( c , 1 ), size ( c , 2 )) return end if ! Local Memory Allocation allocate ( xtx ( ncoeffs , ncoeffs ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"covariance_matrix_real64\" , flag ) return end if ! Compute X**T * X call DGEMM ( \"T\" , \"N\" , ncoeffs , ncoeffs , npts , one , x , npts , x , npts , & zero , xtx , ncoeffs ) ! Compute the inverse of X**T * X to obtain the covariance matrix call mtx_pinverse ( xtx , c , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! -------------------- module subroutine covariance_matrix_real32 ( x , c , err ) ! Arguments real ( real32 ), intent ( in ) :: x (:,:) real ( real32 ), intent ( out ) :: c (:,:) class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real32 ), parameter :: zero = 0.0d0 real ( real32 ), parameter :: one = 1.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: npts , ncoeffs , flag real ( real32 ), allocatable :: xtx (:,:) ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x , 1 ) ncoeffs = size ( x , 2 ) ! Input Checking if ( size ( c , 1 ) /= ncoeffs . or . size ( c , 2 ) /= ncoeffs ) then call report_matrix_size_error ( errmgr , \"covariance_matrix_real32\" , & \"c\" , ncoeffs , ncoeffs , size ( c , 1 ), size ( c , 2 )) return end if ! Local Memory Allocation allocate ( xtx ( ncoeffs , ncoeffs ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"covariance_matrix_real64\" , flag ) return end if ! Compute X**T * X call SGEMM ( \"T\" , \"N\" , ncoeffs , ncoeffs , npts , one , x , npts , x , npts , & zero , xtx , ncoeffs ) ! Compute the inverse of X**T * X to obtain the covariance matrix call r32_inverse ( xtx , c , errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ module subroutine linear_least_squares_real64 ( order , intercept , x , y , coeffs , & ymod , resid , stats , alpha , err ) ! Arguments integer ( int32 ), intent ( in ) :: order logical , intent ( in ) :: intercept real ( real64 ), intent ( in ) :: x (:), y (:) real ( real64 ), intent ( out ) :: coeffs (:), ymod (:), resid (:) type ( regression_statistics ), intent ( out ), optional :: stats (:) real ( real64 ), intent ( in ), optional :: alpha class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , npts , ncols , ncoeffs , flag real ( real64 ) :: alph , var , df , ssr , talpha real ( real64 ), allocatable :: a (:,:), c (:,:), cxt (:,:) type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncoeffs = order + 1 ncols = order if ( intercept ) ncols = ncols + 1 alph = 0.05d0 if ( present ( alpha )) alph = alpha ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"linear_least_squares_real64\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( y ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real64\" , & \"y\" , npts , size ( y )) return end if if ( size ( coeffs ) /= ncoeffs ) then call report_array_size_error ( errmgr , \"linear_least_squares_real64\" , & \"coeffs\" , ncoeffs , size ( coeffs )) return end if if ( size ( ymod ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real64\" , & \"ymod\" , npts , size ( ymod )) return end if if ( size ( resid ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real64\" , & \"resid\" , npts , size ( resid )) return end if if ( present ( stats )) then if ( size ( stats ) /= ncols ) then call report_array_size_error ( errmgr , & \"linear_least_squares_real64\" , \"stats\" , ncols , size ( stats )) return end if end if ! Memory Allocation allocate ( a ( npts , ncols ), stat = flag ) if ( flag == 0 ) allocate ( c ( ncols , ncols ), stat = flag ) if ( flag == 0 ) allocate ( cxt ( ncols , npts ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"linear_least_squares_real64\" , flag ) return end if ! Compute the coefficient matrix call coefficient_matrix ( order , intercept , x , a , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the covariance matrix call covariance_matrix ( a , c , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the coefficients (NCOLS-by-1) call DGEMM ( \"N\" , \"T\" , ncols , npts , ncols , one , c , ncols , a , npts , zero , & cxt , ncols ) ! C * X**T i = 2 coeffs ( 1 ) = zero if ( intercept ) i = 1 call DGEMM ( \"N\" , \"N\" , ncols , 1 , npts , one , cxt , ncols , y , npts , zero , & coeffs ( i : ncoeffs ), ncols ) ! (C * X**T) * Y ! Evaluate the model and compute the residuals call DGEMM ( \"N\" , \"N\" , npts , 1 , ncols , one , a , npts , coeffs ( i : ncoeffs ), & ncols , zero , ymod , npts ) resid = ymod - y ! If the user doesn't want the statistics calculations we can stop now if (. not . present ( stats )) return ! Start the process of computing statistics stats = calculate_regression_statistics ( resid , coeffs ( 1 : ncols ), c , alph , & errmgr ) end subroutine ! -------------------- module subroutine linear_least_squares_real32 ( order , intercept , x , y , coeffs , & ymod , resid , stats , alpha , err ) ! Arguments integer ( int32 ), intent ( in ) :: order logical , intent ( in ) :: intercept real ( real32 ), intent ( in ) :: x (:), y (:) real ( real32 ), intent ( out ) :: coeffs (:), ymod (:), resid (:) type ( regression_statistics ), intent ( out ), optional :: stats (:) real ( real32 ), intent ( in ), optional :: alpha class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: half = 0.5 real ( real32 ), parameter :: one = 1.0 ! Local Variables integer ( int32 ) :: i , npts , ncols , ncoeffs , flag real ( real32 ) :: alph , var , df , ssr , talpha real ( real32 ), allocatable :: a (:,:), c (:,:), cxt (:,:) type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncoeffs = order + 1 ncols = order if ( intercept ) ncols = ncols + 1 alph = 0.05 if ( present ( alpha )) alph = alpha ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"linear_least_squares_real32\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( y ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real32\" , & \"y\" , npts , size ( y )) return end if if ( size ( coeffs ) /= ncoeffs ) then call report_array_size_error ( errmgr , \"linear_least_squares_real32\" , & \"coeffs\" , ncoeffs , size ( coeffs )) return end if if ( size ( ymod ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real32\" , & \"ymod\" , npts , size ( ymod )) return end if if ( size ( resid ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares_real32\" , & \"resid\" , npts , size ( resid )) return end if if ( present ( stats )) then if ( size ( stats ) /= ncols ) then call report_array_size_error ( errmgr , & \"linear_least_squares_real32\" , \"stats\" , ncols , size ( stats )) return end if end if ! Memory Allocation allocate ( a ( npts , ncols ), stat = flag ) if ( flag == 0 ) allocate ( c ( ncols , ncols ), stat = flag ) if ( flag == 0 ) allocate ( cxt ( ncols , npts ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"linear_least_squares_real32\" , flag ) return end if ! Compute the coefficient matrix call coefficient_matrix ( order , intercept , x , a , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the covariance matrix call covariance_matrix ( a , c , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the coefficients (NCOLS-by-1) call SGEMM ( \"N\" , \"T\" , ncols , npts , ncols , one , c , ncols , a , npts , zero , & cxt , ncols ) ! C * X**T i = 2 coeffs ( 1 ) = zero if ( intercept ) i = 1 call SGEMM ( \"N\" , \"N\" , ncols , 1 , npts , one , cxt , ncols , y , npts , zero , & coeffs ( i : ncoeffs ), ncols ) ! (C * X**T) * Y ! Evaluate the model and compute the residuals call SGEMM ( \"N\" , \"N\" , npts , 1 , ncols , one , a , npts , coeffs ( i : ncoeffs ), & ncols , zero , ymod , npts ) resid = ymod - y ! If the user doesn't want the statistics calculations we can stop now if (. not . present ( stats )) return ! Start the process of computing statistics stats = calculate_regression_statistics ( resid , coeffs ( 1 : ncols ), c , alph , & errmgr ) end subroutine ! ------------------------------------------------------------------------------ module function calculate_regression_stats_r64 ( resid , params , c , alpha , err ) & result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: resid (:), params (:), c (:,:) real ( real64 ), intent ( in ), optional :: alpha class ( errors ), intent ( inout ), optional , target :: err type ( regression_statistics ), allocatable :: rst (:) ! Parameters real ( real64 ), parameter :: p05 = 0.05d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , dof , flag real ( real64 ) :: a , ssr , var , talpha type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Initialization m = size ( resid ) n = size ( params ) dof = m - n if ( present ( alpha )) then a = alpha else a = p05 end if allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then end if ! Input Checking if ( size ( c , 1 ) /= n . or . size ( c , 2 ) /= n ) then end if ! Process ssr = norm2 ( resid ) ** 2 ! sum of the squares of the residual var = ssr / dof dist % dof = real ( dof , real64 ) talpha = confidence_interval ( dist , a , one , 1 ) do i = 1 , n rst ( i )% standard_error = sqrt ( var * c ( i , i )) rst ( i )% t_statistic = params ( i ) / rst ( i )% standard_error rst ( i )% probability = regularized_beta ( & half * dof , & half , & real ( dof , real64 ) / ( dof + ( rst ( i )% t_statistic ) ** 2 ) & ) rst ( i )% confidence_interval = talpha * rst ( i )% standard_error end do end function ! -------------------- module function calculate_regression_stats_r32 ( resid , params , c , alpha , err ) & result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: resid (:), params (:), c (:,:) real ( real32 ), intent ( in ), optional :: alpha class ( errors ), intent ( inout ), optional , target :: err type ( regression_statistics ), allocatable :: rst (:) ! Parameters real ( real32 ), parameter :: p05 = 0.05 real ( real64 ), parameter :: half = 0.5d0 real ( real32 ), parameter :: one = 1.0 ! Local Variables integer ( int32 ) :: i , m , n , dof , flag real ( real32 ) :: a , ssr , var , talpha type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Initialization m = size ( resid ) n = size ( params ) dof = m - n if ( present ( alpha )) then a = alpha else a = p05 end if allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then end if ! Input Checking if ( size ( c , 1 ) /= n . or . size ( c , 2 ) /= n ) then end if ! Process ssr = norm2 ( resid ) ** 2 ! sum of the squares of the residual var = ssr / dof dist % dof = real ( dof , real32 ) talpha = confidence_interval ( dist , a , one , 1 ) do i = 1 , n rst ( i )% standard_error = sqrt ( var * c ( i , i )) rst ( i )% t_statistic = params ( i ) / rst ( i )% standard_error rst ( i )% probability = regularized_beta ( & half * dof , & half , & real ( dof , real64 ) / ( dof + ( rst ( i )% t_statistic ) ** 2 ) & ) rst ( i )% confidence_interval = talpha * rst ( i )% standard_error end do end function ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ subroutine r32_inverse ( x , xinv , err ) ! Arguments real ( real32 ), intent ( in ) :: x (:,:) real ( real32 ), intent ( out ) :: xinv (:,:) class ( errors ), intent ( inout ) :: err ! Variables integer ( int32 ) :: m , n real ( real64 ), allocatable :: xc (:,:), xcinv (:,:) ! Process m = size ( x , 1 ) n = size ( x , 2 ) allocate ( xcinv ( n , m )) xc = real ( x , real64 ) call mtx_pinverse ( xc , xcinv , err = err ) xinv = real ( xcinv , real32 ) end subroutine ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\regression_implementation.f90.html"},{"title":"special_functions_beta.f90 – FSTATS","text":"Contents Submodules special_functions_beta Source Code special_functions_beta.f90 Source Code submodule ( fstats ) special_functions_beta contains ! ------------------------------------------------------------------------------ pure elemental module function beta_real64 ( a , b ) result ( rst ) ! Local Variables real ( real64 ), intent ( in ) :: a , b real ( real64 ) :: rst ! Process ! REF: https://en.wikipedia.org/wiki/Beta_function rst = exp ( log_gamma ( a ) + log_gamma ( b ) - log_gamma ( a + b )) end function ! -------------------- pure elemental module function beta_real32 ( a , b ) result ( rst ) ! Local Variables real ( real32 ), intent ( in ) :: a , b real ( real32 ) :: rst ! Process ! REF: https://en.wikipedia.org/wiki/Beta_function rst = exp ( log_gamma ( a ) + log_gamma ( b ) - log_gamma ( a + b )) end function ! ------------------------------------------------------------------------------ ! source: https://people.math.sc.edu/Burkardt/f_src/special_functions/special_functions.f90 pure elemental module function regularized_beta_real64 ( a , b , x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: a , b , x real ( real64 ) :: rst ! Local Variables real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ) :: bt , dk ( 51 ), fk ( 51 ), s0 , t1 , t2 , ta , tb integer ( int32 ) :: k ! Process s0 = ( a + one ) / ( a + b + two ) bt = beta ( a , b ) if ( x <= s0 ) then do k = 1 , 20 dk ( 2 * k ) = k * ( b - k ) * x / ( a + two * k - one ) / ( a + two * k ) end do do k = 0 , 20 dk ( 2 * k + 1 ) = - ( a + k ) * ( a + b + k ) * x / ( a + two * k ) / & ( a + two * k + one ) end do t1 = zero do k = 20 , 1 , - 1 t1 = dk ( k ) / ( one + t1 ) end do ta = one / ( one + t1 ) rst = x ** a * ( one - x ) ** b / ( a * bt ) * ta else do k = 1 , 20 fk ( 2 * k ) = k * ( a - k ) * ( one - x ) / ( b + two * k - one ) / ( b + two * k ) end do do k = 0 , 20 fk ( 2 * k + 1 ) = - ( b + k ) * ( a + b + k ) * ( one - x ) / ( b + two * k ) / & ( b + two * k + one ) end do t2 = zero do k = 20 , 1 , - 1 t2 = fk ( k ) / ( one + t2 ) end do tb = one / ( one + t2 ) rst = one - x ** a * ( one - x ) ** b / ( b * bt ) * tb end if end function ! -------------------- pure elemental module function regularized_beta_real32 ( a , b , x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: a , b , x real ( real32 ) :: rst ! Local Variables real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: two = 2.0 real ( real32 ) :: bt , dk ( 51 ), fk ( 51 ), s0 , t1 , t2 , ta , tb integer ( int32 ) :: k ! Process s0 = ( a + one ) / ( a + b + two ) bt = beta ( a , b ) if ( x <= s0 ) then do k = 1 , 20 dk ( 2 * k ) = k * ( b - k ) * x / ( a + two * k - one ) / ( a + two * k ) end do do k = 0 , 20 dk ( 2 * k + 1 ) = - ( a + k ) * ( a + b + k ) * x / ( a + two * k ) / & ( a + two * k + one ) end do t1 = zero do k = 20 , 1 , - 1 t1 = dk ( k ) / ( one + t1 ) end do ta = one / ( one + t1 ) rst = x ** a * ( one - x ) ** b / ( a * bt ) * ta else do k = 1 , 20 fk ( 2 * k ) = k * ( a - k ) * ( one - x ) / ( b + two * k - one ) / ( b + two * k ) end do do k = 0 , 20 fk ( 2 * k + 1 ) = - ( b + k ) * ( a + b + k ) * ( one - x ) / ( b + two * k ) / & ( b + two * k + one ) end do t2 = zero do k = 20 , 1 , - 1 t2 = fk ( k ) / ( one + t2 ) end do tb = one / ( one + t2 ) rst = one - x ** a * ( one - x ) ** b / ( b * bt ) * tb end if end function ! ------------------------------------------------------------------------------ pure elemental module function incomplete_beta_real64 ( a , b , x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: a , b , x real ( real64 ) :: rst ! Process rst = beta ( a , b ) * regularized_beta ( a , b , x ) end function ! -------------------- pure elemental module function incomplete_beta_real32 ( a , b , x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: a , b , x real ( real32 ) :: rst ! Process rst = beta ( a , b ) * regularized_beta ( a , b , x ) end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\special_functions_beta.f90.html"},{"title":"special_functions_digamma.f90 – FSTATS","text":"Contents Submodules special_functions_digamma Source Code special_functions_digamma.f90 Source Code submodule ( fstats ) special_functions_digamma use ieee_arithmetic contains ! ------------------------------------------------------------------------------ pure elemental module function digamma_real64 ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: c = 8.5d0 real ( real64 ), parameter :: euler_mascheroni = 0.57721566490153286060d0 ! Local Variables real ( real64 ) :: r , x2 , nan ! REF: ! - https://people.sc.fsu.edu/~jburkardt/f_src/asa103/asa103.f90 ! If x <= 0.0 if ( x <= 0.0 ) then nan = ieee_value ( nan , IEEE_QUIET_NAN ) rst = nan return end if ! Approximation for a small argument if ( x <= 1.0d-6 ) then rst = - euler_mascheroni - 1.0d0 / x + 1.6449340668482264365d0 * x return end if ! Process rst = 0.0d0 x2 = x do while ( x2 < c ) rst = rst - 1.0d0 / x2 x2 = x2 + 1.0d0 end do r = 1.0d0 / x2 rst = rst + log ( x2 ) - 0.5d0 * r r = r * r rst = rst & - r * ( 1.0d0 / 1 2.0d0 & - r * ( 1.0d0 / 12 0.0d0 & - r * ( 1.0d0 / 25 2.0d0 & - r * ( 1.0d0 / 24 0.0d0 & - r * ( 1.0d0 / 13 2.0d0 ) & )))) end function ! ------------------------------------------------------------------------------ pure elemental module function digamma_real32 ( x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: c = 8.5 real ( real32 ), parameter :: euler_mascheroni = 0.57721566490153286060 ! Local Variables real ( real32 ) :: r , x2 , nan ! REF: ! - https://people.sc.fsu.edu/~jburkardt/f_src/asa103/asa103.f90 ! If x <= 0.0 if ( x <= 0.0 ) then nan = ieee_value ( nan , IEEE_QUIET_NAN ) rst = nan return end if ! Approximation for a small argument if ( x <= 1.0d-6 ) then rst = - euler_mascheroni - 1.0 / x + 1.6449340668482264365 * x return end if ! Process rst = 0.0 x2 = x do while ( x2 < c ) rst = rst - 1.0 / x2 x2 = x2 + 1.0 end do r = 1.0 / x2 rst = rst + log ( x2 ) - 0.5 * r r = r * r rst = rst & - r * ( 1.0 / 1 2.0 & - r * ( 1.0 / 12 0.0 & - r * ( 1.0 / 25 2.0 & - r * ( 1.0 / 24 0.0 & - r * ( 1.0 / 13 2.0 ) & )))) end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\special_functions_digamma.f90.html"},{"title":"special_functions_gamma.f90 – FSTATS","text":"Contents Submodules special_functions_gamma Source Code special_functions_gamma.f90 Source Code submodule ( fstats ) special_functions_gamma use ieee_arithmetic contains ! ------------------------------------------------------------------------------ ! REF: https://people.math.sc.edu/Burkardt/f_src/special_functions/special_functions.f90 pure elemental module function incomplete_gamma_upper_real64 ( a , x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: a , x real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 ! Local Variables real ( real64 ) :: ga , gin , gip , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0d2 . or . a > 1.7d2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = gamma ( a ) else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do gin = exp ( xam ) * s ga = gamma ( a ) gip = gin / ga rst = ga - gin else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do rst = exp ( xam ) / ( x + t0 ) end if end function ! ------------------------------------------------------------------------------ pure elemental module function incomplete_gamma_upper_real32 ( a , x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: a , x real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: ten = 1.0e1 ! Local Variables real ( real32 ) :: ga , gin , gip , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0e2 . or . a > 1.7e2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = gamma ( a ) else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do gin = exp ( xam ) * s ga = gamma ( a ) gip = gin / ga rst = ga - gin else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do rst = exp ( xam ) / ( x + t0 ) end if end function ! ------------------------------------------------------------------------------ pure elemental module function incomplete_gamma_lower_real64 ( a , x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: a , x real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 ! Local Variables real ( real64 ) :: ga , gim , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0d2 . or . a > 1.7d2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = 0.0d0 else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do rst = exp ( xam ) * s else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do gim = exp ( xam ) / ( x + t0 ) ga = gamma ( a ) rst = ga - gim end if end function ! ------------------------------------------------------------------------------ pure elemental module function incomplete_gamma_lower_real32 ( a , x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: a , x real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: ten = 1.0e1 ! Local Variables real ( real32 ) :: ga , gim , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0e2 . or . a > 1.7e2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = 0.0d0 else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do rst = exp ( xam ) * s else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do gim = exp ( xam ) / ( x + t0 ) ga = gamma ( a ) rst = ga - gim end if end function ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\special_functions_gamma.f90.html"},{"title":"statistics_implementation.f90 – FSTATS","text":"Contents Submodules statistics_implementation Source Code statistics_implementation.f90 Source Code submodule ( fstats ) statistics_implementation use linalg , only : sort use ieee_arithmetic use fstats_errors contains ! ------------------------------------------------------------------------------ pure module function mean_real64 ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) if ( n == 0 ) then rst = zero else rst = x ( 1 ) do i = 2 , n rst = rst + ( x ( i ) - rst ) / i end do end if end function ! -------------------- pure module function mean_real32 ( x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x (:) real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: zero = 0.0 ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) if ( n == 0 ) then rst = zero else rst = x ( 1 ) do i = 2 , n rst = rst + ( x ( i ) - rst ) / i end do end if end function ! ------------------------------------------------------------------------------ pure module function variance_real64 ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: oldMean , newMean ! Process n = size ( x ) if ( n <= 1 ) then rst = zero else oldMean = x ( 1 ) rst = zero do i = 2 , n newMean = oldMean + ( x ( i ) - oldMean ) / i rst = rst + ( x ( i ) - oldMean ) * ( x ( i ) - newMean ) oldMean = newMean end do rst = rst / ( n - one ) end if end function ! -------------------- pure module function variance_real32 ( x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x (:) real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: one = 1.0 ! Local Variables integer ( int32 ) :: i , n real ( real32 ) :: oldMean , newMean ! Process n = size ( x ) if ( n <= 1 ) then rst = zero else oldMean = x ( 1 ) rst = zero do i = 2 , n newMean = oldMean + ( x ( i ) - oldMean ) / i rst = rst + ( x ( i ) - oldMean ) * ( x ( i ) - newMean ) oldMean = newMean end do rst = rst / ( n - one ) end if end function ! ------------------------------------------------------------------------------ pure module function standard_deviation_real64 ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:) real ( real64 ) :: rst ! Process rst = sqrt ( variance ( x )) end function ! -------------------- pure module function standard_deviation_real32 ( x ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x (:) real ( real32 ) :: rst ! Process rst = sqrt ( variance ( x )) end function ! ------------------------------------------------------------------------------ module function median_real64 ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( inout ) :: x (:) real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: half = 0.5d0 ! Local Variables integer ( int32 ) :: n , nmid , nmidp1 , flag , iflag ! Initialization n = size ( x ) nmid = n / 2 nmidp1 = nmid + 1 iflag = n - 2 * nmid ! Sort the array in ascending order call sort ( x , . true .) ! Find the median if ( iflag == 0 ) then rst = half * ( x ( nmid ) + x ( nmidp1 )) else rst = x ( nmidp1 ) end if end function ! -------------------- module function median_real32 ( x ) result ( rst ) ! Arguments real ( real32 ), intent ( inout ) :: x (:) real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: half = 0.5 ! Local Variables integer ( int32 ) :: n , nmid , nmidp1 , flag , iflag ! Initialization n = size ( x ) nmid = n / 2 nmidp1 = nmid + 1 iflag = n - 2 * nmid ! Sort the array in ascending order call r32_sort ( x ) ! Find the median if ( iflag == 0 ) then rst = half * ( x ( nmid ) + x ( nmidp1 )) else rst = x ( nmidp1 ) end if end function ! ------------------------------------------------------------------------------ module function r_squared_real64 ( x , xm , err ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:), xm (:) class ( errors ), intent ( inout ), optional , target :: err real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: esum , vt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check n = size ( x ) if ( size ( xm ) /= n ) then call report_array_size_error ( errmgr , \"r_squared_real64\" , \"XM\" , n , & size ( xm )) return end if ! Process esum = zero do i = 1 , n esum = esum + ( x ( i ) - xm ( i )) ** 2 end do vt = variance ( x ) * ( n - one ) rst = one - esum / vt end function ! -------------------- module function r_squared_real32 ( x , xm , err ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x (:), xm (:) class ( errors ), intent ( inout ), optional , target :: err real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: one = 1.0 ! Local Variables integer ( int32 ) :: i , n real ( real32 ) :: esum , vt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check n = size ( x ) if ( size ( xm ) /= n ) then call report_array_size_error ( errmgr , \"r_squared_real32\" , \"XM\" , n , & size ( xm )) return end if ! Process esum = zero do i = 1 , n esum = esum + ( x ( i ) - xm ( i )) ** 2 end do vt = variance ( x ) * ( n - one ) rst = one - esum / vt end function ! ------------------------------------------------------------------------------ module function adjusted_r_squared_real64 ( p , x , xm , err ) result ( rst ) ! Arguments integer ( int32 ), intent ( in ) :: p real ( real64 ), intent ( in ) :: x (:), xm (:) class ( errors ), intent ( inout ), optional , target :: err real ( real64 ) :: rst ! Local Variables integer ( int32 ) :: n real ( real64 ) :: r2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) ! Process r2 = r_squared ( x , xm , errmgr ) if ( errmgr % has_error_occurred ()) return rst = one - ( one - r2 ) * ( n - one ) / ( n - p - one ) end function ! -------------------- module function adjusted_r_squared_real32 ( p , x , xm , err ) result ( rst ) ! Arguments integer ( int32 ), intent ( in ) :: p real ( real32 ), intent ( in ) :: x (:), xm (:) class ( errors ), intent ( inout ), optional , target :: err real ( real32 ) :: rst ! Local Variables integer ( int32 ) :: n real ( real32 ) :: r2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real32 ), parameter :: one = 1.0 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) ! Process r2 = r_squared ( x , xm , errmgr ) if ( errmgr % has_error_occurred ()) return rst = one - ( one - r2 ) * ( n - one ) / ( n - p - one ) end function ! ------------------------------------------------------------------------------ ! REF: https://fortranwiki.org/fortran/show/Quartiles ! ! This is the method used by Minitab pure module function quantile_real64 ( x , q ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:), q real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables real ( real64 ) :: a , b , c integer ( int32 ) :: n , ib ! Initialization tol = sqrt ( epsilon ( tol )) n = size ( x ) ! Process a = ( n + one ) * q b = mod ( a , one ) c = a - b ib = int ( c , int32 ) if (( ib + 1 ) > n ) then rst = ( one - b ) * x ( ib ) + b * x ( n ) else rst = ( one - b ) * x ( ib ) + b * x ( ib + 1 ) end if end function ! -------------------- pure module function quantile_real32 ( x , q ) result ( rst ) ! Arguments real ( real32 ), intent ( in ) :: x (:), q real ( real32 ) :: rst ! Parameters real ( real32 ), parameter :: one = 1.0 ! Local Variables real ( real32 ) :: a , b , c integer ( int32 ) :: n , ib ! Initialization tol = sqrt ( epsilon ( tol )) n = size ( x ) ! Process a = ( n + one ) * q b = mod ( a , one ) c = a - b ib = int ( c , int32 ) if (( ib + 1 ) > n ) then rst = ( one - b ) * x ( ib ) + b * x ( n ) else rst = ( one - b ) * x ( ib ) + b * x ( ib + 1 ) end if end function ! ------------------------------------------------------------------------------ pure module function confidence_interval_real64 ( dist , alpha , s , n ) result ( rst ) ! Arguments class ( distribution ), intent ( in ) :: dist real ( real64 ), intent ( in ) :: alpha , s integer ( int32 ), intent ( in ) :: n real ( real64 ) :: rst ! Local Variables integer ( int32 ), parameter :: maxiter = 100 real ( real64 ), parameter :: tol = 1.0d-6 integer ( int32 ) :: i real ( real64 ) :: x , f , df , h , twoh , dy ! Process ! ! We use a simplified Newton's method to solve for the independent variable ! of the CDF function where it equals 1 - alpha / 2. h = 1.0d-6 twoh = 2.0d0 * h x = 1.0d0 - alpha / 2.0d0 rst = 0.5d0 do i = 1 , maxiter ! Compute the CDF and its derivative at y f = dist % cdf ( rst ) - x df = ( dist % cdf ( rst + h ) - dist % cdf ( rst - h )) / twoh dy = f / df rst = rst - dy if ( abs ( dy ) < tol ) exit end do end function ! ------------------ pure module function confidence_interval_real32 ( dist , alpha , s , n ) result ( rst ) ! Arguments class ( distribution ), intent ( in ) :: dist real ( real32 ), intent ( in ) :: alpha , s integer ( int32 ), intent ( in ) :: n real ( real32 ) :: rst ! Process real ( real64 ) a , sd a = real ( alpha , real64 ) sd = real ( s , real64 ) rst = real ( confidence_interval_real64 ( dist , a , sd , n ), real32 ) end function ! ------------------------------------------------------------------------------ pure module function confidence_interval_real64_array ( dist , alpha , x ) result ( rst ) ! Arguments class ( distribution ), intent ( in ) :: dist real ( real64 ), intent ( in ) :: alpha , x (:) real ( real64 ) :: rst ! Process rst = confidence_interval ( dist , alpha , standard_deviation ( x ), size ( x )) end function ! ------------------ pure module function confidence_interval_real32_array ( dist , alpha , x ) result ( rst ) ! Arguments class ( distribution ), intent ( in ) :: dist real ( real32 ), intent ( in ) :: alpha , x (:) real ( real32 ) :: rst ! Process rst = confidence_interval ( dist , alpha , standard_deviation ( x ), size ( x )) end function ! ------------------------------------------------------------------------------ module subroutine t_test_equal_var_real64 ( x1 , x2 , stat , p , dof ) ! Arguments real ( real64 ), intent ( in ) :: x1 (:), x2 (:) real ( real64 ), intent ( out ) :: stat , p , dof ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables real ( real64 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = n1 + n2 - two sv = (( n1 - one ) * v1 + ( n2 - one ) * v2 ) / dof stat = abs ( m1 - m2 ) / sqrt ( sv * ( one / real ( n1 ) + one / real ( n2 ))) ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------- module subroutine t_test_equal_var_real32 ( x1 , x2 , stat , p , dof ) ! Arguments real ( real32 ), intent ( in ) :: x1 (:), x2 (:) real ( real32 ), intent ( out ) :: stat , p , dof ! Parameters real ( real32 ), parameter :: half = 0.5 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: two = 2.0 ! Local Variables real ( real32 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = n1 + n2 - two sv = (( n1 - one ) * v1 + ( n2 - one ) * v2 ) / dof stat = abs ( m1 - m2 ) / sqrt ( sv * ( one / real ( n1 ) + one / real ( n2 ))) ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ module subroutine t_test_unequal_var_real64 ( x1 , x2 , stat , p , dof ) ! Arguments real ( real64 ), intent ( in ) :: x1 (:), x2 (:) real ( real64 ), intent ( out ) :: stat , p , dof ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables real ( real64 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = ( v1 / real ( n1 ) + v2 / real ( n2 )) ** 2 / (( v1 / n1 ) ** 2 / ( n1 - one ) + & ( v2 / n2 ) ** 2 / ( n2 - one )) sv = sqrt ( v1 / n1 + v2 / n2 ) stat = ( m1 - m2 ) / sv ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------- module subroutine t_test_unequal_var_real32 ( x1 , x2 , stat , p , dof ) ! Arguments real ( real32 ), intent ( in ) :: x1 (:), x2 (:) real ( real32 ), intent ( out ) :: stat , p , dof ! Parameters real ( real32 ), parameter :: half = 0.5 real ( real32 ), parameter :: one = 1.0 ! Local Variables real ( real32 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = ( v1 / real ( n1 ) + v2 / real ( n2 )) ** 2 / (( v1 / n1 ) ** 2 / ( n1 - one ) + & ( v2 / n2 ) ** 2 / ( n2 - one )) sv = sqrt ( v1 / n1 + v2 / n2 ) stat = ( m1 - m2 ) / sv ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ module subroutine t_test_paired_real64 ( x1 , x2 , stat , p , dof , err ) ! Arguments real ( real64 ), intent ( in ) :: x1 (:), x2 (:) real ( real64 ), intent ( out ) :: stat , p , dof class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr real ( real64 ) :: v1 , v2 , m1 , m2 , sd , cov , a , b , x integer ( int32 ) :: n1 , n2 , n ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n1 = size ( x1 ) n2 = size ( x2 ) n = min ( n1 , n2 ) ! Input Checking if ( n1 /= n2 ) then call report_arrays_not_same_size_error ( errmgr , \"t_test_paired_real64\" , & \"X1\" , \"X2\" , n1 , n2 ) return end if ! Compute the T-statistic m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = real ( n1 ) - one cov = zero do i = 1 , n cov = cov + ( x1 ( i ) - m1 ) * ( x2 ( i ) - m2 ) end do cov = cov / dof sd = sqrt (( v1 + v2 - two * cov ) / n ) stat = ( m1 - m2 ) / sd ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------- module subroutine t_test_paired_real32 ( x1 , x2 , stat , p , dof , err ) ! Arguments real ( real32 ), intent ( in ) :: x1 (:), x2 (:) real ( real32 ), intent ( out ) :: stat , p , dof class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real32 ), parameter :: zero = 0.0 real ( real32 ), parameter :: half = 0.5 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: two = 2.0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr real ( real32 ) :: v1 , v2 , m1 , m2 , sd , cov , a , b , x integer ( int32 ) :: n1 , n2 , n ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n1 = size ( x1 ) n2 = size ( x2 ) n = min ( n1 , n2 ) ! Input Checking if ( n1 /= n2 ) then call report_arrays_not_same_size_error ( errmgr , \"t_test_paired_real32\" , & \"X1\" , \"X2\" , n1 , n2 ) return end if ! Compute the T-statistic m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = real ( n1 ) - one cov = zero do i = 1 , n cov = cov + ( x1 ( i ) - m1 ) * ( x2 ( i ) - m2 ) end do cov = cov / dof sd = sqrt (( v1 + v2 - two * cov ) / n ) stat = ( m1 - m2 ) / sd ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ module subroutine f_test_real64 ( x1 , x2 , stat , p , dof1 , dof2 ) ! Arguments real ( real64 ), intent ( in ) :: x1 (:), x2 (:) real ( real64 ), intent ( out ) :: stat , p , dof1 , dof2 ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables integer ( int32 ) :: n1 , n2 real ( real64 ) :: v1 , v2 , m1 , m2 , a , b , x ! Compute the F-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) if ( v1 > v2 ) then stat = v1 / v2 dof1 = n1 - one dof2 = n2 - one else stat = v2 / v1 dof1 = n2 - one dof2 = n1 - one end if ! Compute the probability a = half * dof2 b = half * dof1 x = dof2 / ( dof2 + dof1 * stat ) p = two * regularized_beta ( a , b , x ) if ( p > one ) p = two - p end subroutine ! ------------------- module subroutine f_test_real32 ( x1 , x2 , stat , p , dof1 , dof2 ) ! Arguments real ( real32 ), intent ( in ) :: x1 (:), x2 (:) real ( real32 ), intent ( out ) :: stat , p , dof1 , dof2 ! Parameters real ( real32 ), parameter :: half = 0.5 real ( real32 ), parameter :: one = 1.0 real ( real32 ), parameter :: two = 2.0 ! Local Variables integer ( int32 ) :: n1 , n2 real ( real32 ) :: v1 , v2 , m1 , m2 , a , b , x ! Compute the F-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) if ( v1 > v2 ) then stat = v1 / v2 dof1 = n1 - one dof2 = n2 - one else stat = v2 / v1 dof1 = n2 - one dof2 = n1 - one end if ! Compute the probability a = half * dof2 b = half * dof1 x = dof2 / ( dof2 + dof1 * stat ) p = two * regularized_beta ( a , b , x ) if ( p > one ) p = two - p end subroutine ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/root-cause-analysis/single-factor-anova module function anova_1_factor ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:,:) type ( single_factor_anova_table ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , a , n , nt real ( real64 ) :: sum_all , tssq , essq , bssq ! Initialization a = size ( x , 2 ) nt = size ( x , 1 ) n = nt * a rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Determine the degrees of freedom rst % main_factor % dof = a - 1 rst % within_factor % dof = n - a rst % total_dof = n - 1 ! Quick Return if ( a == 1 . or . nt == 1 ) then rst % main_factor % sum_of_squares = zero rst % main_factor % variance = zero rst % main_factor % f_statistic = zero rst % main_factor % probability = zero rst % within_factor % sum_of_squares = zero rst % within_factor % variance = zero rst % total_variance = variance ( pack ( x , . true .)) rst % total_sum_of_squares = rst % total_variance * rst % total_dof rst % overall_mean = mean ( pack ( x , . true .)) return end if ! Compute the sum of squares for all factors sum_all = sum ( x ) tssq = sum ( x ** 2 ) - ( sum_all ** 2 / n ) bssq = zero do j = 1 , a bssq = bssq + sum ( x (:, j )) ** 2 end do bssq = ( bssq / nt ) - ( sum_all ** 2 / n ) essq = tssq - bssq rst % main_factor % sum_of_squares = bssq rst % within_factor % sum_of_squares = essq rst % total_sum_of_squares = tssq ! Compute the variance terms rst % main_factor % variance = bssq / rst % main_factor % dof rst % within_factor % variance = essq / rst % within_factor % dof rst % total_variance = tssq / rst % total_dof ! Compute the overall mean rst % overall_mean = mean ( pack ( x , . true .)) ! Compute the F-statistic and probability term call anova_probability ( & rst % main_factor % variance , & rst % within_factor % variance , & rst % main_factor % dof , & rst % within_factor % dof , & rst % main_factor % f_statistic , & rst % main_factor % probability & ) end function ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/measurement-systems-analysis/anova-gage-rr-part-1 ! REF: https://www.itl.nist.gov/div898/handbook/prc/section4/prc427.htm ! Data set is expected as a 3D array with each of the K pages containing the R !   treatments of N tests such that the array size is N-by-R-by-K module function anova_2_factor ( x ) result ( rst ) ! Arguments real ( real64 ), intent ( in ) :: x (:,:,:) type ( two_factor_anova_table ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , j , jj , k , r , n real ( real64 ) :: factorMean real ( real64 ), allocatable :: xpack (:) ! Initialization n = size ( x , 3 ) k = size ( x , 2 ) r = size ( x , 1 ) rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Quick Return if ( k == 1 ) then ! This is a one-factor anova end if ! Determine the number of DOF rst % main_factor_1 % dof = k - one rst % main_factor_2 % dof = n - 1 rst % interaction % dof = ( k - 1 ) * ( n - 1 ) rst % within_factor % dof = n * k * ( r - 1 ) rst % total_dof = n * k * r - 1 ! Compute the overall mean, sum of squares, and variance xpack = pack ( x , . true .) rst % overall_mean = mean ( xpack ) rst % total_sum_of_squares = sum (( xpack - rst % overall_mean ) ** 2 ) rst % total_variance = rst % total_sum_of_squares / rst % total_dof ! Compute factor 1 results rst % main_factor_1 % sum_of_squares = zero do i = 1 , k factorMean = mean ( pack ( x (:, i ,:), . true .)) rst % main_factor_1 % sum_of_squares = rst % main_factor_1 % sum_of_squares + & ( factorMean - rst % overall_mean ) ** 2 end do rst % main_factor_1 % sum_of_squares = n * r * rst % main_factor_1 % sum_of_squares rst % main_factor_1 % variance = rst % main_factor_1 % sum_of_squares / & rst % main_factor_1 % dof ! Compute factor 2 results rst % main_factor_2 % sum_of_squares = zero do i = 1 , n factorMean = mean ( pack ( x (:,:, i ), . true .)) rst % main_factor_2 % sum_of_squares = rst % main_factor_2 % sum_of_squares + & ( factorMean - rst % overall_mean ) ** 2 end do rst % main_factor_2 % sum_of_squares = k * r * rst % main_factor_2 % sum_of_squares rst % main_factor_2 % variance = rst % main_factor_2 % sum_of_squares / & rst % main_factor_2 % dof ! Compute the within (error) term rst % within_factor % sum_of_squares = zero do j = 1 , k do i = 1 , n factorMean = mean ( x (:, j , i )) do jj = 1 , r rst % within_factor % sum_of_squares = & rst % within_factor % sum_of_squares + & ( x ( jj , j , i ) - factorMean ) ** 2 end do end do end do rst % within_factor % variance = rst % within_factor % sum_of_squares / & rst % within_factor % dof ! Compute the interaction term rst % interaction % sum_of_squares = rst % total_sum_of_squares - ( & rst % main_factor_1 % sum_of_squares + & rst % main_factor_2 % sum_of_squares + & rst % within_factor % sum_of_squares & ) rst % interaction % variance = rst % interaction % sum_of_squares / & rst % interaction % dof ! Compute the F-statistics call anova_probability ( & rst % main_factor_1 % variance , & rst % within_factor % variance , & rst % main_factor_1 % dof , & rst % within_factor % dof , & rst % main_factor_1 % f_statistic , & rst % main_factor_1 % probability & ) call anova_probability ( & rst % main_factor_2 % variance , & rst % within_factor % variance , & rst % main_factor_2 % dof , & rst % within_factor % dof , & rst % main_factor_2 % f_statistic , & rst % main_factor_2 % probability & ) call anova_probability ( & rst % interaction % variance , & rst % within_factor % variance , & rst % interaction % dof , & rst % within_factor % dof , & rst % interaction % f_statistic , & rst % interaction % probability & ) end function ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1 module function anova_model_fit ( nmodelparams , ymeas , ymod , err ) result ( rst ) ! Arguments integer ( int32 ), intent ( in ) :: nmodelparams real ( real64 ), intent ( in ) :: ymeas (:), ymod (:) class ( errors ), intent ( inout ), optional , target :: err type ( single_factor_anova_table ) :: rst ! Local Variables integer ( int32 ) :: n , flag real ( real64 ), allocatable :: ypack (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( ymeas ) if ( present ( err )) then errmgr => err else errmgr => deferr end if rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Input Checking if ( size ( ymod ) /= n ) then call report_arrays_not_same_size_error ( errmgr , \"anova_model_fit\" , & \"YMEAS\" , \"YMOD\" , n , size ( ymod )) return end if ! Memory Allocation allocate ( ypack ( 2 * n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"anova_model_fit\" , flag ) return end if ! Determine the number of DOF rst % main_factor % dof = nmodelparams - 1 rst % within_factor % dof = n - rst % main_factor % dof - 1 rst % total_dof = n - 1 ! Process ypack ( 1 : n ) = ymeas ypack ( n + 1 : 2 * n ) = ymod rst % overall_mean = mean ( ypack ) rst % total_sum_of_squares = sum (( ymeas - rst % overall_mean ) ** 2 ) rst % main_factor % sum_of_squares = sum (( ymod - rst % overall_mean ) ** 2 ) rst % within_factor % sum_of_squares = sum (( ymeas - ymod ) ** 2 ) rst % total_variance = rst % total_sum_of_squares / rst % total_dof rst % main_factor % variance = rst % main_factor % sum_of_squares / & rst % main_factor % dof rst % within_factor % variance = rst % within_factor % sum_of_squares / & rst % within_factor % dof ! Compute the F-statistic and probability term call anova_probability ( & rst % main_factor % variance , & rst % within_factor % variance , & rst % main_factor % dof , & rst % within_factor % dof , & rst % main_factor % f_statistic , & rst % main_factor % probability & ) ! Formatting 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 , A ) end function ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ ! This is a hack as the linalg library doesn't support 32-bit real32ing point ! routines subroutine r32_sort ( x ) ! Arguments real ( real32 ), intent ( inout ) :: x (:) ! Local Variables real ( real64 ), allocatable :: xc (:) ! Process xc = real ( x , real64 ) call sort ( xc , . true .) x = real ( xc , real32 ) end subroutine ! ------------------------------------------------------------------------------ subroutine anova_probability ( v1 , v2 , dof1 , dof2 , f , p ) ! Arguments real ( real64 ), intent ( in ) :: v1 , v2 , dof1 , dof2 real ( real64 ), intent ( out ) :: f , p ! Local Variables real ( real64 ) :: d1 , d2 , a , b , x ! Process f = v1 / v2 d1 = dof1 d2 = dof2 a = 0.5d0 * d2 b = 0.5d0 * d1 x = d2 / ( d2 + d1 * f ) p = regularized_beta ( a , b , x ) if ( p > 1.0d0 ) then p = 2.0d0 - p end if end subroutine ! ------------------------------------------------------------------------------ end submodule","tags":"","loc":"sourcefile\\statistics_implementation.f90.html"}]}