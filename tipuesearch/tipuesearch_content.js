var tipuesearch = {"pages":[{"title":" FSTATS ","text":"FSTATS Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"anova_factor – FSTATS ","text":"type, public :: anova_factor Defines an ANOVA factor result. Contents Variables dof f_statistic probability sum_of_squares variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedome. real(kind=real64), public :: f_statistic The F-statistic. real(kind=real64), public :: probability The variance probability term. real(kind=real64), public :: sum_of_squares The sum of the squares. real(kind=real64), public :: variance The estimate of variance.","tags":"","loc":"type\\anova_factor.html"},{"title":"single_factor_anova_table – FSTATS ","text":"type, public :: single_factor_anova_table Defines a single-factor ANOVA results table. Contents Variables main_factor overall_mean total_dof total_sum_of_squares total_variance within_factor Components Type Visibility Attributes Name Initial type( anova_factor ), public :: main_factor The main, or main factor, results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within-treatement (error) results.","tags":"","loc":"type\\single_factor_anova_table.html"},{"title":"two_factor_anova_table – FSTATS ","text":"type, public :: two_factor_anova_table Defines a two-factor ANOVA results table. Contents Variables interaction main_factor_1 main_factor_2 overall_mean total_dof total_sum_of_squares total_variance within_factor Components Type Visibility Attributes Name Initial type( anova_factor ), public :: interaction The interaction effects. type( anova_factor ), public :: main_factor_1 The first main-factor results. type( anova_factor ), public :: main_factor_2 The second main-factor results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within (error) factor results.","tags":"","loc":"type\\two_factor_anova_table.html"},{"title":"bootstrap_statistics – FSTATS ","text":"type, public :: bootstrap_statistics A collection of statistics resulting from the bootstrap process. Contents Variables bias lower_confidence_interval population standard_error statistic_value upper_confidence_interval Components Type Visibility Attributes Name Initial real(kind=real64), public :: bias The bias in the statistic. real(kind=real64), public :: lower_confidence_interval The lower confidence limit on the statistic. real(kind=real64), public, allocatable, dimension(:) :: population An array of the population values generated by the bootstrap\nprocess. real(kind=real64), public :: standard_error The standard error of the statistic. real(kind=real64), public :: statistic_value The value of the statistic of interest. real(kind=real64), public :: upper_confidence_interval The upper confidence limit on the statistic.","tags":"","loc":"type\\bootstrap_statistics.html"},{"title":"binomial_distribution – FSTATS ","text":"type, public, extends( distribution ) :: binomial_distribution Defines a binomial distribution.  The binomial distribution describes\nthe probability p of getting k successes in n independent trials. Contents Variables n p Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Components Type Visibility Attributes Name Initial integer(kind=int32), public :: n The number of independent trials. real(kind=real64), public :: p The success probability for each trial.  This parameter must\nexist on the set [0, 1]. Type-Bound Procedures procedure, public :: cdf => bd_cdf private pure elemental function bd_cdf(this, x) result(rst) Computes the cumulative distribution funtion. The CDF for a binomial distribution is given as , which is simply\nthe regularized incomplete beta function. Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function.  This parameter\nis the number k successes in the n independent trials.  As\nsuch, this parameter must exist on the set [0, n]. Return Value real(kind=real64) The value of the function. procedure, public :: mean => bd_mean private pure function bd_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => bd_median private pure function bd_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => bd_mode private pure function bd_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => bd_pdf private pure elemental function bd_pdf(this, x) result(rst) Computes the probability mass function. The PMF for a binomial distribution is given as . Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function.  This parameter\nis the number k successes in the n independent trials.  As\nsuch, this parameter must exist on the set [0, n]. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => bd_variance private pure function bd_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( binomial_distribution ), intent(in) :: this The binomial_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\binomial_distribution.html"},{"title":"chi_squared_distribution – FSTATS ","text":"type, public, extends( distribution ) :: chi_squared_distribution Defines a Chi-squared distribution. Contents Variables dof Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure, public :: cdf => cs_cdf private pure elemental function cs_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a Chi-squared distribution is given as . Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => cs_mean private pure function cs_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => cs_median private pure function cs_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => cs_mode private pure function cs_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => cs_pdf private pure elemental function cs_pdf(this, x) result(rst) Computes the probability density function. The PDF for a Chi-squared distribution is given as . Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => cs_variance private pure function cs_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( chi_squared_distribution ), intent(in) :: this The chi_squared_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\chi_squared_distribution.html"},{"title":"distribution – FSTATS ","text":"type, public, abstract :: distribution Defines a probability distribution. Contents Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Type-Bound Procedures procedure( distribution_function ), public, deferred, pass :: cdf Computes the cumulative distribution function. pure elemental function distribution_function(this, x) result(rst) Prototype Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure( distribution_property ), public, deferred, pass :: mean Computes the mean of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_property ), public, deferred, pass :: median Computes the median of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_property ), public, deferred, pass :: mode Computes the mode of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. procedure( distribution_function ), public, deferred, pass :: pdf Computes the probability density function. pure elemental function distribution_function(this, x) result(rst) Prototype Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure( distribution_property ), public, deferred, pass :: variance Computes the variance of the distribution. pure function distribution_property(this) result(rst) Prototype Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value.","tags":"","loc":"type\\distribution.html"},{"title":"f_distribution – FSTATS ","text":"type, public, extends( distribution ) :: f_distribution Defines an F-distribution. Contents Variables d1 d2 Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: d1 The measure of degrees of freedom for the first data set. real(kind=real64), public :: d2 The measure of degrees of freedom for the second data set. Type-Bound Procedures procedure, public :: cdf => fd_cdf private pure elemental function fd_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a F distribution is given as . Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => fd_mean private pure function fd_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => fd_median private pure function fd_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => fd_mode private pure function fd_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => fd_pdf private pure elemental function fd_pdf(this, x) result(rst) Computes the probability density function. The PDF for a F distribution is given as . Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => fd_variance private pure function fd_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( f_distribution ), intent(in) :: this The f_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\f_distribution.html"},{"title":"log_normal_distribution – FSTATS ","text":"type, public, extends( distribution ) :: log_normal_distribution Defines a normal distribution. Contents Variables mean_value standard_deviation Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure, public :: cdf => lnd_cdf private pure elemental function lnd_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a log-normal distribution is given as Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => lnd_mean private pure function lnd_mean(this) result(rst) Computes the mean of the distribution Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal distribution object. Return Value real(kind=real64) The mean procedure, public :: median => lnd_median private pure function lnd_median(this) result(rst) Computes the median of the distribution Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal distribution object. Return Value real(kind=real64) The median procedure, public :: mode => lnd_mode private pure function lnd_mode(this) result(rst) Computes the mode of the distribution Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal distribution object. Return Value real(kind=real64) The mode procedure, public :: pdf => lnd_pdf private pure elemental function lnd_pdf(this, x) result(rst) Computes the probability density function. The PDF for a log-normal distribution is given as Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => lnd_variance private pure function lnd_variance(this) result(rst) Computes the variance of the distribution Arguments Type Intent Optional Attributes Name class( log_normal_distribution ), intent(in) :: this The log_normal distribution object. Return Value real(kind=real64) The variance","tags":"","loc":"type\\log_normal_distribution.html"},{"title":"multivariate_distribution – FSTATS ","text":"type, public, abstract :: multivariate_distribution Defines a multivariate probability distribution. Contents Type-Bound Procedures pdf Type-Bound Procedures procedure( multivariate_distribution_function ), public, deferred, pass :: pdf Computes the probability density function. pure function multivariate_distribution_function(this, x) result(rst) Prototype Defines an interface for a multivariate probability distribution\nfunction. Arguments Type Intent Optional Attributes Name class( multivariate_distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in), dimension(:) :: x The values at which to evaluate the function. Return Value real(kind=real64) The value of the function.","tags":"","loc":"type\\multivariate_distribution.html"},{"title":"multivariate_normal_distribution – FSTATS ","text":"type, public, extends( multivariate_distribution ) :: multivariate_normal_distribution Defines a multivariate normal (Gaussian) distribution. Contents Type-Bound Procedures get_cholesky_factored_matrix get_covariance get_means initialize pdf set_means Type-Bound Procedures procedure, public :: get_cholesky_factored_matrix => mvnd_get_cholesky private pure function mvnd_get_cholesky(this) result(rst) Gets the lower triangular form of the Cholesky factorization of the\ncovariance matrix of the distribution. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: this The multivariate_normal_distribution object. Return Value real(kind=real64), allocatable, dimension(:,:) The Cholesky factored matrix. procedure, public :: get_covariance => mvnd_get_covariance private pure function mvnd_get_covariance(this) result(rst) Gets the covariance matrix of the distribution. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: this The multivariate_normal_distribution object. Return Value real(kind=real64), allocatable, dimension(:,:) The covariance matrix. procedure, public :: get_means => mvnd_get_means private pure function mvnd_get_means(this) result(rst) Gets the mean values of the distribution. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: this The multivariate_normal_distribution object. Return Value real(kind=real64), allocatable, dimension(:) The mean values. procedure, public :: initialize => mvnd_init private  subroutine mvnd_init(this, mu, sigma, err) Initializes the multivariate normal distribution by defining the mean\nvalues and covariance matrix. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(inout) :: this The multivariate_normal_distribution object. real(kind=real64), intent(in), dimension(:) :: mu An N-element array containing the mean values. real(kind=real64), intent(in), dimension(:,:) :: sigma The N-by-N covariance matrix.  The PDF exists only if this matrix\nis positive-definite; therefore, the positive-definite constraint \nis checked within this routine and enforced.  An error is thrown if\nthe supplied matrix is not positive-definite. class(errors), intent(inout), optional, target :: err The error handling object. procedure, public :: pdf => mvnd_pdf private pure function mvnd_pdf(this, x) result(rst) Evaluates the PDF for the multivariate normal distribution. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: this The multivariate_normal_distribution object. real(kind=real64), intent(in), dimension(:) :: x The values at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: set_means => mvnd_update_mean private  subroutine mvnd_update_mean(this, x, err) Updates the mean value array. Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(inout) :: this The multivariate_normal_distribution object. real(kind=real64), intent(in), dimension(:) :: x The N-element array of new mean values. class(errors), intent(inout), optional, target :: err The error handling object.  This is referenced only in the event that\nthe size of x is not compatible with the existing state.","tags":"","loc":"type\\multivariate_normal_distribution.html"},{"title":"normal_distribution – FSTATS ","text":"type, public, extends( distribution ) :: normal_distribution Defines a normal distribution. Contents Variables mean_value standard_deviation Type-Bound Procedures cdf mean median mode pdf standardize standardized_variable variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure, public :: cdf => nd_cdf private pure elemental function nd_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for a normal distribution is given as . Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => nd_mean private pure function nd_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The mean procedure, public :: median => nd_median private pure function nd_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The median. procedure, public :: mode => nd_mode private pure function nd_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => nd_pdf private pure elemental function nd_pdf(this, x) result(rst) Computes the probability density function. The PDF for a normal distribution is given as . Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardize => nd_standardize private  subroutine nd_standardize(this) Standardizes the normal distribution to a mean of 0 and a \nstandard deviation of 1. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(inout) :: this The normal_distribution object. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => nd_variance private pure function nd_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( normal_distribution ), intent(in) :: this The normal_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\normal_distribution.html"},{"title":"t_distribution – FSTATS ","text":"type, public, extends( distribution ) :: t_distribution Defines Student's T-Distribution. Contents Variables dof Type-Bound Procedures cdf mean median mode pdf standardized_variable variance Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure, public :: cdf => td_cdf private pure elemental function td_cdf(this, x) result(rst) Computes the cumulative distribution function. The CDF for Student's T-Distribution is given as where . Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: mean => td_mean private pure function td_mean(this) result(rst) Computes the mean of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The mean. procedure, public :: median => td_median private pure function td_median(this) result(rst) Computes the median of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) procedure, public :: mode => td_mode private pure function td_mode(this) result(rst) Computes the mode of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The mode. procedure, public :: pdf => td_pdf private pure elemental function td_pdf(this, x) result(rst) Computes the probability density function. The PDF for Student's T-Distribution is given as . Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. procedure, public :: standardized_variable => dist_std_var Computes the standardized variable for the distribution. private pure elemental function dist_std_var(this, x) result(rst) Computes the standardized variable for the distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value of interest. Return Value real(kind=real64) The result. procedure, public :: variance => td_variance private pure function td_variance(this) result(rst) Computes the variance of the distribution. Arguments Type Intent Optional Attributes Name class( t_distribution ), intent(in) :: this The t_distribution object. Return Value real(kind=real64) The variance.","tags":"","loc":"type\\t_distribution.html"},{"title":"doe_model – FSTATS ","text":"type, public :: doe_model A model used to represent a design of experiments result.  The model\nis of the following form. Contents Variables coefficients map nway stats Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: coefficients The model coefficients. logical, public, allocatable, dimension(:) :: map An array denoting if a model coefficient should be included\nas part of the model (true), or neglected (false). integer(kind=int32), public :: nway The number of interaction levels. type( regression_statistics ), public, allocatable, dimension(:) :: stats Statistical information for each model parameter.","tags":"","loc":"type\\doe_model.html"},{"title":"metropolis_hastings – FSTATS ","text":"type, public :: metropolis_hastings An implementation of the Metropolis-Hastings algorithm for the\ngeneration of a Markov chain.  This is a default implementation\nthat allows sampling of normally distributed posterior distributions\ncentered on zero with unit standard deviations.  Proposals are\ngenerated from a multivariate normal distribution with an identity\ncovariance matrix and centered on zero.  To alter these sampling\nand target distributions simply create a new class inheriting from \nthis class and override the appropriate routines. Contents Type-Bound Procedures compute_hastings_ratio evaluate_proposal_pdf generate_proposal get_accepted_count get_chain get_chain_length get_proposal_cholesky get_proposal_covariance get_proposal_initialized get_proposal_means get_state_variable_count initialize_proposal on_acceptance on_rejection push_new_state reset sample set_proposal_covariance set_proposal_means target_distribution Type-Bound Procedures procedure, public :: compute_hastings_ratio => mh_hastings_ratio private  function mh_hastings_ratio(this, xc, xp) result(rst) Evaluates the Hasting's ratio.  If the proposal distribution is \nsymmetric, this ratio is unity; however, in the case of an asymmetric\ndistribution this ratio is not ensured to be unity. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xc The current state vector. real(kind=real64), intent(in), dimension(size(xc)) :: xp The proposed state vector. Return Value real(kind=real64) The ratio. procedure, public :: evaluate_proposal_pdf => mh_eval_proposal private pure function mh_eval_proposal(this, xc) result(rst) Evaluates the proposal distribution PDF at the specified set of \nvariables. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xc The array of variables to evaluate. Return Value real(kind=real64) The value of the PDF at xc. procedure, public :: generate_proposal => mh_proposal private  function mh_proposal(this, xc) result(rst) Proposes a new sample set of variables.  The sample is generated by\nsampling a multivariate normal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xc The current set of variables. Return Value real(kind=real64), allocatable, dimension(:) The proposed set of variables. procedure, public :: get_accepted_count => mh_get_num_accepted private pure function mh_get_num_accepted(this) result(rst) Gets the number of accepted steps. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The number of accepted steps. procedure, public :: get_chain => mh_get_chain private  function mh_get_chain(this, bin, err) result(rst) Gets a copy of the stored Markov chain. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. real(kind=real64), intent(in), optional :: bin An optional input allowing for a burn-in region.  The parameter\nrepresents the amount (percentage-based) of the overall chain to \ndisregard as \"burn-in\" values.  The value shoud exist on [0, 1).\nThe default value is 0 such that no values are disregarded. class(errors), intent(inout), optional, target :: err The error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting chain with each parameter represented by a column. procedure, public :: get_chain_length => mh_get_chain_length private pure function mh_get_chain_length(this) result(rst) Gets the length of the chain (number of stored state variables). Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The chain length. procedure, public :: get_proposal_cholesky => mh_get_prop_chol_cov private pure function mh_get_prop_chol_cov(this) result(rst) Gets the Cholesky-factored (lower-triangular) form of the proposal\ncovariance matrix. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:,:) The Cholesky-factored form of the proposal covariance matrix store\nin lower-triangular form. procedure, public :: get_proposal_covariance => mh_get_prop_cov private pure function mh_get_prop_cov(this) result(rst) Gets the covariance matrix of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:,:) The covariance matrix. procedure, public :: get_proposal_initialized => mh_get_is_prop_init private pure function mh_get_is_prop_init(this) result(rst) Gets a value determining if the proposal distribution object has been\ninitialized. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value logical Returns true if the object has been initialized; else, false. procedure, public :: get_proposal_means => mh_get_prop_mean private pure function mh_get_prop_mean(this) result(rst) Gets the mean values of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:) An array containing the mean values. procedure, public :: get_state_variable_count => mh_get_nvars private pure function mh_get_nvars(this) result(rst) Gets the number of state variables. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The number of state variables. generic, public :: initialize_proposal => mh_init_proposal_1, mh_init_proposal_2 private  subroutine mh_init_proposal_1(this, mu, sigma, err) Initializes the multivariate normal distribution used to generate\nproposals. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: mu An N-element array containing the mean values for the distribution. real(kind=real64), intent(in), dimension(:,:) :: sigma An N-by-N covariance matrix for the distribution.  This matrix must\nbe positive-definite. class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine mh_init_proposal_2(this, n, err) Initializes the multivariate normal distribution to a mean of zero and\na variance of one. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. integer(kind=int32), intent(in) :: n The number of state variables. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: on_acceptance => mh_on_success private  subroutine mh_on_success(this, iter, alpha, xc, xp, err) Currently, this routine does nothing and is a placeholder for the user\nthat inherits this class to provide functionallity upon acceptance of\na proposed value. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in) :: alpha The proposal probabilty term used for acceptance criteria. real(kind=real64), intent(in), dimension(:) :: xc An N-element array containing the current state variables. real(kind=real64), intent(in), dimension(size(xc)) :: xp An N-element array containing the proposed state variables that\nwere just accepted. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: on_rejection => mh_on_rejection private  subroutine mh_on_rejection(this, iter, alpha, xc, xp, err) Currently, this routine does nothing and is a placeholder for the user\nthat inherits this class to provide functionallity upon rejection of\na proposed value. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in) :: alpha The proposal probabilty term used for acceptance criteria. real(kind=real64), intent(in), dimension(:) :: xc An N-element array containing the current state variables. real(kind=real64), intent(in), dimension(size(xc)) :: xp An N-element array containing the proposed state variables that\nwere just rejected. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: push_new_state => mh_push private  subroutine mh_push(this, x, err) Pushes a new set of state variables onto the buffer. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: x The new N-element state array. class(errors), intent(inout), optional, target :: err The error handling object. procedure, public :: reset => mh_clear_chain private  subroutine mh_clear_chain(this) Resets the object and clears out the buffer storing the chain values. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. procedure, public :: sample => mh_sample private  subroutine mh_sample(this, xi, niter, err) Samples the distribution using the Metropolis-Hastings algorithm. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xi An N-element array containing initial starting values of the state \nvariables. integer(kind=int32), intent(in), optional :: niter An optional input defining the number of iterations to take.  The\ndefault is 10,000. class(errors), intent(inout), optional, target :: err The error handling object. procedure, public :: set_proposal_covariance => mh_set_prop_cov private  subroutine mh_set_prop_cov(this, x, err) Sets the covariance matrix of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:,:) :: x The covariance matrix.  This matrix must be positive-definite. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: set_proposal_means => mh_set_prop_mean private  subroutine mh_set_prop_mean(this, x, err) Sets the mean values of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: x The updated mean values. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: target_distribution => mh_target private  function mh_target(this, x) result(rst) Returns the probability value from the target distribution at the\nspecified state.  The user is expected to overload this routine to\ndefine the desired distribution.  The default behavior of this\nroutine is to sample a multivariate normal distribution with a mean\nof zero and a variance of one (identity covariance matrix). Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: x The state vector. Return Value real(kind=real64) The value of the probability density function of the distribution\nbeing sampled.","tags":"","loc":"type\\metropolis_hastings.html"},{"title":"mcmc_regression – FSTATS ","text":"type, public, extends( metropolis_hastings ) :: mcmc_regression The mcmc_regression type extends the metropolis_hastings type to\nspecifically target regression problems.  The problem is formulated\nsuch that the target distribution takes the form , where is a normal\ndistribution with as the mean and the model variance, is determined by computing the variance for the current\nestimate of the model. Contents Variables fcn lower_limits upper_limits x y Type-Bound Procedures compute_fit_statistics compute_hastings_ratio covariance_matrix evaluate_proposal_pdf generate_proposal get_accepted_count get_chain get_chain_length get_data_variance get_proposal_cholesky get_proposal_covariance get_proposal_initialized get_proposal_means get_state_variable_count initialize_proposal likelihood on_acceptance on_rejection push_new_state reset sample set_data_variance set_proposal_covariance set_proposal_means target_distribution Components Type Visibility Attributes Name Initial procedure( regression_function ), public, pointer, nopass :: fcn The function to fit. real(kind=real64), public, allocatable, dimension(:) :: lower_limits An optional array that, if used, provides a lower limit to\neach parameter in the model.  If used, be sure this array is the\nsame dimension as the parameter array.  If not used, leave this\nalone and no lower limits will be placed on the parameters.\nIf used and the array is not sized correctly, it will be ignored. real(kind=real64), public, allocatable, dimension(:) :: upper_limits An optional array that, if used, provides an upper limit to\neach parameter in the model.  If used, be sure this array is the\nsame dimension as the parameter array.  If not used, leave this\nalone and no upper limits will be placed on the parameters.\nIf used and the array is not sized correctly, it will be ignored. real(kind=real64), public, allocatable, dimension(:) :: x The independent-variable data to fit. real(kind=real64), public, allocatable, dimension(:) :: y The dependent-variable data to fit. Type-Bound Procedures procedure, public :: compute_fit_statistics => mr_calc_regression_stats private  function mr_calc_regression_stats(this, xc, alpha, err) result(rst) Calculates statistics for the quality of fit for the regression. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: xc The model parameters.  Be sure to only include the model parameters. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence intervals.\nThe default value is 0.05 such that a 95% confidence interval is\ncalculated. class(errors), intent(inout), optional, target :: err An error handling object. Return Value type( regression_statistics ), allocatable, dimension(:) The resulting statistics for each parameter. procedure, public :: compute_hastings_ratio => mh_hastings_ratio private  function mh_hastings_ratio(this, xc, xp) result(rst) Evaluates the Hasting's ratio.  If the proposal distribution is \nsymmetric, this ratio is unity; however, in the case of an asymmetric\ndistribution this ratio is not ensured to be unity. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xc The current state vector. real(kind=real64), intent(in), dimension(size(xc)) :: xp The proposed state vector. Return Value real(kind=real64) The ratio. procedure, public :: covariance_matrix => mr_covariance private  function mr_covariance(this, xc, err) result(rst) Computes the covariance matrix for the model given the specified model\nparameters. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: xc The current set of model parameters. class(errors), intent(inout), optional, target :: err The error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The covariance matrix. procedure, public :: evaluate_proposal_pdf => mh_eval_proposal private pure function mh_eval_proposal(this, xc) result(rst) Evaluates the proposal distribution PDF at the specified set of \nvariables. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xc The array of variables to evaluate. Return Value real(kind=real64) The value of the PDF at xc. procedure, public :: generate_proposal => mr_proposal private  function mr_proposal(this, xc) result(rst) Arguments Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: xc The current model parameters. Return Value real(kind=real64), allocatable, dimension(:) The proposed set of model parameters. procedure, public :: get_accepted_count => mh_get_num_accepted private pure function mh_get_num_accepted(this) result(rst) Gets the number of accepted steps. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The number of accepted steps. procedure, public :: get_chain => mh_get_chain private  function mh_get_chain(this, bin, err) result(rst) Gets a copy of the stored Markov chain. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. real(kind=real64), intent(in), optional :: bin An optional input allowing for a burn-in region.  The parameter\nrepresents the amount (percentage-based) of the overall chain to \ndisregard as \"burn-in\" values.  The value shoud exist on [0, 1).\nThe default value is 0 such that no values are disregarded. class(errors), intent(inout), optional, target :: err The error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting chain with each parameter represented by a column. procedure, public :: get_chain_length => mh_get_chain_length private pure function mh_get_chain_length(this) result(rst) Gets the length of the chain (number of stored state variables). Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The chain length. procedure, public :: get_data_variance => mr_get_data_variance private pure function mr_get_data_variance(this) result(rst) Gets the variance of the observed data. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(in) :: this The mcmc_regression object. Return Value real(kind=real64) The variance. procedure, public :: get_proposal_cholesky => mh_get_prop_chol_cov private pure function mh_get_prop_chol_cov(this) result(rst) Gets the Cholesky-factored (lower-triangular) form of the proposal\ncovariance matrix. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:,:) The Cholesky-factored form of the proposal covariance matrix store\nin lower-triangular form. procedure, public :: get_proposal_covariance => mh_get_prop_cov private pure function mh_get_prop_cov(this) result(rst) Gets the covariance matrix of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:,:) The covariance matrix. procedure, public :: get_proposal_initialized => mh_get_is_prop_init private pure function mh_get_is_prop_init(this) result(rst) Gets a value determining if the proposal distribution object has been\ninitialized. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value logical Returns true if the object has been initialized; else, false. procedure, public :: get_proposal_means => mh_get_prop_mean private pure function mh_get_prop_mean(this) result(rst) Gets the mean values of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value real(kind=real64), allocatable, dimension(:) An array containing the mean values. procedure, public :: get_state_variable_count => mh_get_nvars private pure function mh_get_nvars(this) result(rst) Gets the number of state variables. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(in) :: this The metropolis_hastings object. Return Value integer(kind=int32) The number of state variables. generic, public :: initialize_proposal => mh_init_proposal_1, mh_init_proposal_2 private  subroutine mh_init_proposal_1(this, mu, sigma, err) Initializes the multivariate normal distribution used to generate\nproposals. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: mu An N-element array containing the mean values for the distribution. real(kind=real64), intent(in), dimension(:,:) :: sigma An N-by-N covariance matrix for the distribution.  This matrix must\nbe positive-definite. class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine mh_init_proposal_2(this, n, err) Initializes the multivariate normal distribution to a mean of zero and\na variance of one. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. integer(kind=int32), intent(in) :: n The number of state variables. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: likelihood => mr_likelihood private  function mr_likelihood(this, x) result(rst) Estimates the likelihood of the model. The likelihood is computed as follows assuming is known\na priori. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: x The current set of model parameters. Return Value real(kind=real64) The likelihood value. procedure, public :: on_acceptance => mr_on_success private  subroutine mr_on_success(this, iter, alpha, xc, xp, err) Updates the covariance matrix of the proposal distribution upon a \nsuccessful step.  If overloaded, be sure to call the base method to\nretain the functionallity required to keep the covariance matrix \nup-to-date. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in) :: alpha The proposal probability term used for acceptance criteria. real(kind=real64), intent(in), dimension(:) :: xc The current model parameter estimates. real(kind=real64), intent(in), dimension(size(xc)) :: xp The recently accepted model parameter estimates. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: on_rejection => mh_on_rejection private  subroutine mh_on_rejection(this, iter, alpha, xc, xp, err) Currently, this routine does nothing and is a placeholder for the user\nthat inherits this class to provide functionallity upon rejection of\na proposed value. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in) :: alpha The proposal probabilty term used for acceptance criteria. real(kind=real64), intent(in), dimension(:) :: xc An N-element array containing the current state variables. real(kind=real64), intent(in), dimension(size(xc)) :: xp An N-element array containing the proposed state variables that\nwere just rejected. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: push_new_state => mr_push private  subroutine mr_push(this, x, err) Pushes a new set of parameters onto the end of the chain buffer. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: x The new N-element state array. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: reset => mh_clear_chain private  subroutine mh_clear_chain(this) Resets the object and clears out the buffer storing the chain values. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. procedure, public :: sample => mh_sample private  subroutine mh_sample(this, xi, niter, err) Samples the distribution using the Metropolis-Hastings algorithm. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: xi An N-element array containing initial starting values of the state \nvariables. integer(kind=int32), intent(in), optional :: niter An optional input defining the number of iterations to take.  The\ndefault is 10,000. class(errors), intent(inout), optional, target :: err The error handling object. procedure, public :: set_data_variance => mr_set_data_variance private  subroutine mr_set_data_variance(this, x) Sets the variance of the observed data. Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in) :: x The variance. procedure, public :: set_proposal_covariance => mh_set_prop_cov private  subroutine mh_set_prop_cov(this, x, err) Sets the covariance matrix of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:,:) :: x The covariance matrix.  This matrix must be positive-definite. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: set_proposal_means => mh_set_prop_mean private  subroutine mh_set_prop_mean(this, x, err) Sets the mean values of the proposal distribution. Arguments Type Intent Optional Attributes Name class( metropolis_hastings ), intent(inout) :: this The metropolis_hastings object. real(kind=real64), intent(in), dimension(:) :: x The updated mean values. class(errors), intent(inout), optional, target :: err An error handling object. procedure, public :: target_distribution => mr_target private  function mr_target(this, x) result(rst) Returns the probability value from the target distribution given the\ncurrent set of model parameters. The probability value is determined as follows, assuming is the function value. . Arguments Type Intent Optional Attributes Name class( mcmc_regression ), intent(inout) :: this The mcmc_regression object. real(kind=real64), intent(in), dimension(:) :: x The current set of model parameters. Return Value real(kind=real64) The value of the probability density function being sampled.","tags":"","loc":"type\\mcmc_regression.html"},{"title":"convergence_info – FSTATS ","text":"type, public :: convergence_info Provides information regarding convergence status. Contents Variables converge_on_gradient converge_on_residual_parameter converge_on_solution_change function_evaluation_count gradient_value iteration_count reach_function_evaluation_limit reach_iteration_limit residual_value solution_change_value user_requested_stop Components Type Visibility Attributes Name Initial logical, public :: converge_on_gradient True if convergence on the gradient was achieved; else, false. logical, public :: converge_on_residual_parameter True if convergence on the residual error parameter was achieved; \nelse, false. logical, public :: converge_on_solution_change True if convergence on the change in solution was achieved; else,\nfalse. integer(kind=int32), public :: function_evaluation_count The function evaluation count. real(kind=real64), public :: gradient_value The value of the gradient test parameter. integer(kind=int32), public :: iteration_count The iteration count. logical, public :: reach_function_evaluation_limit True if the solution did not converge in the allowed number of\nfunction evaluations. logical, public :: reach_iteration_limit True if the solution did not converge in the allowed number of \niterations. real(kind=real64), public :: residual_value The value of the residual error parameter. real(kind=real64), public :: solution_change_value The value of the change in solution parameter. logical, public :: user_requested_stop True if the user requested the stop; else, false.","tags":"","loc":"type\\convergence_info.html"},{"title":"iteration_controls – FSTATS ","text":"type, public :: iteration_controls Provides a collection of iteration control parameters. Contents Variables change_in_solution_tolerance gradient_tolerance iteration_improvement_tolerance max_function_evaluations max_iteration_between_updates max_iteration_count residual_tolerance Type-Bound Procedures set_to_default Components Type Visibility Attributes Name Initial real(kind=real64), public :: change_in_solution_tolerance Defines a tolerance on the change in parameter values. real(kind=real64), public :: gradient_tolerance Defines a tolerance on the gradient of the fitted function. real(kind=real64), public :: iteration_improvement_tolerance Defines a tolerance to ensure adequate improvement on each \niteration. integer(kind=int32), public :: max_function_evaluations Defines the maximum number of function evaluations allowed. integer(kind=int32), public :: max_iteration_between_updates Defines how many iterations can pass before a re-evaluation of \nthe Jacobian matrix is forced. integer(kind=int32), public :: max_iteration_count Defines the maximum number of iterations allowed. real(kind=real64), public :: residual_tolerance Defines a tolerance on the metric associated with the residual \nerror. Type-Bound Procedures procedure, public :: set_to_default => lm_set_default_tolerances private  subroutine lm_set_default_tolerances(x) Arguments Type Intent Optional Attributes Name class( iteration_controls ), intent(inout) :: x","tags":"","loc":"type\\iteration_controls.html"},{"title":"lm_solver_options – FSTATS ","text":"type, public :: lm_solver_options Options to control the Levenberg-Marquardt solver. Contents Variables damping_decrease_factor damping_increase_factor finite_difference_step_size method Type-Bound Procedures set_to_default Components Type Visibility Attributes Name Initial real(kind=real64), public :: damping_decrease_factor The factor to use when decreasing the damping parameter. real(kind=real64), public :: damping_increase_factor The factor to use when increasing the damping parameter. real(kind=real64), public :: finite_difference_step_size The step size used for the finite difference calculations of the\nJacobian matrix. integer(kind=int32), public :: method The solver method to utilize.\n- FS_LEVENBERG_MARQUARDT_UPDATE:\n- FS_QUADRATIC_UPDATE:\n- FS_NIELSEN_UDPATE: Type-Bound Procedures procedure, public :: set_to_default => lm_set_default_settings private  subroutine lm_set_default_settings(x) Arguments Type Intent Optional Attributes Name class( lm_solver_options ), intent(inout) :: x","tags":"","loc":"type\\lm_solver_options.html"},{"title":"regression_statistics – FSTATS ","text":"type, public :: regression_statistics A container for regression-related statistical information. Contents Variables confidence_interval probability standard_error t_statistic Components Type Visibility Attributes Name Initial real(kind=real64), public :: confidence_interval The confidence interval for the parameter at the level \ndetermined by the regression process. real(kind=real64), public :: probability The probability that the coefficient is not statistically \nimportant.  A statistically important coefficient will have a \nlow probability (p-value), typically 0.05 or lower; however, a \np-value of up to ~0.2 may be acceptable dependent upon the \nproblem.  Typically any p-value larger than ~0.2 indicates the \nparameter is not statistically important for the model. real(kind=real64), public :: standard_error The standard error for the model coefficient. real(kind=real64), public :: t_statistic The T-statistic for the model coefficient.","tags":"","loc":"type\\regression_statistics.html"},{"title":"array_container – FSTATS ","text":"type, public :: array_container Provides a container for a real-valued array.  A practical use of\nthis construct is in the construction of jagged arrays. Contents Variables x Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: x The array.","tags":"","loc":"type\\array_container.html"},{"title":"allan_variance – FSTATS","text":"public  function allan_variance(x, dt, err) result(rst) Computes the Allan variance of a data set. Remarks This implementation computes the fully overlapped Allan variance \nusing the method presented by Yadav et. al. Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, \nViraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm \nfor Fully Overlapped Allan Variance and Total Variance for Analysis and \nModeling of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. \n10.1109/LSENS.2018.2829799. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element data set to analyze. real(kind=real64), intent(in), optional :: dt An optional input specifying the time increment between \nsamples in x.  If not specified, this value is set to 1. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-2 array containing the results where M is N / 2 - 1\nif N is even; else, M is (N - 1) / 2 - 1 if N is odd.  The \nfirst column contains the averaging times associated with \nthe M results stored in the second column. Contents","tags":"","loc":"proc\\allan_variance.html"},{"title":"anova – FSTATS","text":"public interface anova Performs an analysis of variance (ANOVA) on the supplied data \nset. The following example illustrates a single-factor ANOVA on a \ndata set. program example use iso_fortran_env use fstats implicit none ! Local Variables character , parameter :: tab = achar ( 9 ) real ( real64 ) :: x ( 10 , 2 ) type ( single_factor_anova_table ) :: tbl ! Define the data x = reshape ( & [ & 3.086d3 , 3.082d3 , 3.069d3 , 3.072d3 , 3.045d3 , 3.070d3 , 3.079d3 , & 3.050d3 , 3.062d3 , 3.062d3 , 3.075d3 , 3.061d3 , 3.063d3 , 3.038d3 , & 3.070d3 , 3.062d3 , 3.070d3 , 3.049d3 , 3.042d3 , 3.063d3 & ], & [ 10 , 2 ] & ) ! Perform the ANOVA tbl = anova ( x ) ! Print out the table print '(A)' , \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" print '(AF2.0AF5.1AF5.1AF5.3AF5.3)' , \"Main Factor: \" // tab , & tbl % main_factor % dof , tab , & tbl % main_factor % sum_of_squares , tab // tab , & tbl % main_factor % variance , tab // tab , & tbl % main_factor % f_statistic , tab , & tbl % main_factor % probability print '(AF3.0AF6.1AF5.1)' , \"Within: \" // tab , & tbl % within_factor % dof , tab , & tbl % within_factor % sum_of_squares , tab // tab , & tbl % within_factor % variance print '(AF3.0AF6.1AF5.1)' , \"Total: \" // tab // tab , & tbl % total_dof , tab , & tbl % total_sum_of_squares , tab // tab , & tbl % total_variance print '(AF6.1)' , \"Overall Mean: \" , tbl % overall_mean end program The above program produces the following output. Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value\nMain Factor:    1.      352.8           352.8           2.147   0.160\nWithin:         18.     2958.2          164.3\nTotal:          19.     3311.0          174.3\nOverall Mean: 3063.5 See Also Wikipedia SPC Excel Single Factor ANOVA SPC Excel Gage R&R SPC Excel Understanding Regression Statistics NIST - Two Way ANOVA Contents Module Procedures anova_1_factor anova_2_factor anova_model_fit Module Procedures private  function anova_1_factor(x) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:) An M-by-N matrix containing the M replications of the N test \npoints of interest. Return Value type( single_factor_anova_table ) A single_factor_anova_table instance containing the ANOVA results. private  function anova_2_factor(x) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:,:) An M-by-N-by-K array containing the M replications of the\nN first factor results, and the K second factor results. Return Value type( two_factor_anova_table ) A two_factor_anova_table instance containing the ANOVA results. private  function anova_model_fit(nmodelparams, ymeas, ymod, err) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmodelparams The number of model parameters. real(kind=real64), intent(in) :: ymeas (:) An N-element array containing the measured dependent variable data. real(kind=real64), intent(in) :: ymod (:) An N-element array containing the modeled dependent variable data. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if ymeas and ymod are not the \n  same length.\n- FS_MEMORY_ERROR: Occurs if a memory error is encountered. Return Value type( single_factor_anova_table ) A single_factor_anova_table instance containing the ANOVA results.","tags":"","loc":"interface\\anova.html"},{"title":"bootstrap – FSTATS","text":"public  function bootstrap(stat, x, method, nsamples, alpha) result(rst) Performs a bootstrap calculation on the supplied data set for the given\nstatistic.  The default implementation utlizes a random resampling with \nreplacement.  Other resampling methods may be defined by specifying an \nappropriate routine by means of the method input. Arguments Type Intent Optional Attributes Name procedure( bootstrap_statistic_routine ), intent(in), pointer :: stat The routine used to compute the desired statistic. real(kind=real64), intent(in), dimension(:) :: x The N-element data set. procedure( bootstrap_resampling_routine ), intent(in), optional, pointer :: method An optional pointer to the method to use for resampling of the data.\nIf no method is supplied, a random resampling is utilized. integer(kind=int32), intent(in), optional :: nsamples An optional input, that if supplied, specifies the number of \nresampling runs to perform.  The default is 10 000. real(kind=real64), intent(in), optional :: alpha An optional input, that if supplied, defines the significance level\nto use for the analysis.  The default is 0.05. Return Value type( bootstrap_statistics ) The resulting bootstrap_statistics type containing the confidence\nintervals, bias, standard error, etc. for the analyzed statistic. Contents","tags":"","loc":"proc\\bootstrap.html"},{"title":"random_resample – FSTATS","text":"public  subroutine random_resample(x, xn) Random resampling, with replacement, based upon a normal distribution. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be written. Contents","tags":"","loc":"proc\\random_resample.html"},{"title":"scaled_random_resample – FSTATS","text":"public  subroutine scaled_random_resample(x, xn) A random resampling, scaled by the standard deviation of the original\ndata, but based upon a normal distribution. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be written. Contents","tags":"","loc":"proc\\scaled_random_resample.html"},{"title":"bootstrap_resampling_routine – FSTATS","text":"interface public  subroutine bootstrap_resampling_routine(x, xn) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be \nwritten. Description Defines the signature of a subroutine used to compute a \nresampling of data for bootstrapping purposes.","tags":"","loc":"interface\\bootstrap_resampling_routine.html"},{"title":"bootstrap_statistic_routine – FSTATS","text":"interface public  function bootstrap_statistic_routine(x) result(rst) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The array of data to analyze. Return Value real(kind=real64) The resulting statistic. Description Defines the signature of a function for computing the desired\nbootstrap statistic.","tags":"","loc":"interface\\bootstrap_statistic_routine.html"},{"title":"covariance – FSTATS","text":"public pure function covariance(x, y) result(rst) Computes the sample covariance of two data sets. The covariance computed is the sample covariance such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The first N-element data set. real(kind=real64), intent(in), dimension(size(x)) :: y The second N-element data set. Return Value real(kind=real64) The covariance. Contents","tags":"","loc":"proc\\covariance.html"},{"title":"mean – FSTATS","text":"public pure function mean(x) result(rst) Computes the mean of the values in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\mean.html"},{"title":"median – FSTATS","text":"public  function median(x) result(rst) Computes the median of the values in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: x (:) The array of values to analyze.  On output, this array is sorted into\nascending order. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\median.html"},{"title":"quantile – FSTATS","text":"public pure function quantile(x, q) result(rst) Computes the specified quantile of a data set using the SAS \nMethod 4. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the data. real(kind=real64), intent(in) :: q The quantile to compute (e.g. 0.25 computes the 25% quantile). Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\quantile.html"},{"title":"standard_deviation – FSTATS","text":"public pure function standard_deviation(x) result(rst) Computes the sample standard deviation of the values in an array. The value computed is the sample standard deviation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\standard_deviation.html"},{"title":"trimmed_mean – FSTATS","text":"public  function trimmed_mean(x, p) result(rst) Computes the trimmed mean of a data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x An N-element array containing the data.  On output, the\narray is sorted into ascending order. real(kind=real64), intent(in), optional :: p An optional parameter specifying the percentage of values\nfrom either end of the distribution to remove.  The default\nis 0.05 such that the bottom 5% and top 5% are removed. Return Value real(kind=real64) The trimmed mean. Contents","tags":"","loc":"proc\\trimmed_mean.html"},{"title":"variance – FSTATS","text":"public pure function variance(x) result(rst) Computes the sample variance of the values in an array. The variance computed is the sample variance such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64) Contents","tags":"","loc":"proc\\variance.html"},{"title":"pooled_variance – FSTATS","text":"public interface pooled_variance Computes the pooled estimate of variance. Contents Module Procedures pooled_variance_1 pooled_variance_2 Module Procedures private pure function pooled_variance_1(si, ni) result(rst) Computes the pooled estimate of variance. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: si An N-element array containing the estimates for each of the N\nvariances. integer(kind=int32), intent(in), dimension(size(si)) :: ni An N-element array containing the number of data points in each\nof the data sets used to compute the variances in si. Return Value real(kind=real64) The pooled variance. private pure function pooled_variance_2(x) result(rst) Computes the pooled estimate of variance. Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x An array of arrays of data. Return Value real(kind=real64) The pooled variance.","tags":"","loc":"interface\\pooled_variance.html"},{"title":"distribution_function – FSTATS","text":"interface public pure elemental function distribution_function(this, x) result(rst) Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. Description Defines the interface for a probability distribution function.","tags":"","loc":"interface\\distribution_function.html"},{"title":"distribution_property – FSTATS","text":"interface public pure function distribution_property(this) result(rst) Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. Description Computes the value of a distribution property.","tags":"","loc":"interface\\distribution_property.html"},{"title":"multivariate_distribution_function – FSTATS","text":"interface public pure function multivariate_distribution_function(this, x) result(rst) Arguments Type Intent Optional Attributes Name class( multivariate_distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in), dimension(:) :: x The values at which to evaluate the function. Return Value real(kind=real64) The value of the function. Description Defines an interface for a multivariate probability distribution\nfunction.","tags":"","loc":"interface\\multivariate_distribution_function.html"},{"title":"report_array_size_error – FSTATS","text":"public  subroutine report_array_size_error(err, fname, name, expect, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expect The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_arrays_not_same_size_error – FSTATS","text":"public  subroutine report_arrays_not_same_size_error(err, fname, name1, name2, size1, size2) Reports an error relating to two arrays not being the same size\nwhen they should be the same size. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name1 The name of the first array. character(len=*), intent(in) :: name2 The name of the second array. integer(kind=int32), intent(in) :: size1 The size of the first array. integer(kind=int32), intent(in) :: size2 The size of the second array. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_arrays_not_same_size_error.html"},{"title":"report_iteration_count_error – FSTATS","text":"public  subroutine report_iteration_count_error(err, fname, msg, mincount) Reports an iteration count error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*) :: fname The name of the routine in which the error occurred. character(len=*) :: msg The error message. integer(kind=int32), intent(in) :: mincount The minimum iteration count expected. Contents Variables emsg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: emsg","tags":"","loc":"proc\\report_iteration_count_error.html"},{"title":"report_matrix_size_error – FSTATS","text":"public  subroutine report_matrix_size_error(err, fname, name, expect_rows, expect_cols, actual_rows, actual_cols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expect_rows The expected number of rows. integer(kind=int32), intent(in) :: expect_cols The expected number of columns. integer(kind=int32), intent(in) :: actual_rows The actual number of rows. integer(kind=int32), intent(in) :: actual_cols The actual number of columns. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_memory_error – FSTATS","text":"public  subroutine report_memory_error(err, fname, code) Reports a memory allocation related error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. integer(kind=int32), intent(in) :: code The error code returned by the allocation routine. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_underdefined_error – FSTATS","text":"public  subroutine report_underdefined_error(err, fname, expect, actual) Reports an underdefined problem error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. integer(kind=int32), intent(in) :: expect The expected minimum number of equations. integer(kind=int32), intent(in) :: actual The actual number of equations. Contents Variables msg Variables Type Visibility Attributes Name Initial character(len=MESSAGE_SIZE), public :: msg","tags":"","loc":"proc\\report_underdefined_error.html"},{"title":"doe_fit_model – FSTATS","text":"public  function doe_fit_model(nway, x, y, map, alpha, err) result(rst) Uses ieee_arithmetic blas Fits a Taylor series model to the provided data. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nway The number of interaction levels. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nused to produce the results. real(kind=real64), intent(in), dimension(:) :: y An M-element array containing the results from the M experiments. logical, intent(in), optional, target, dimension(:) :: map An optional array of the same size as beta that can be used to\neliminate a parameter from the model (false), or keep a parameter\nin the model (true).  If not supplied, all parameters will be assumed\nto be part of the model as if the array were filled with all true\nvalues. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and y are not properly sized\n     relative to one another.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error.\n- FS_INVALID_ARGUMENT_ERROR: Occurs if nway is out of range, or if\n     map is used to \"turn off\" all model parameters. Return Value type( doe_model ) The resulting model. Contents","tags":"","loc":"proc\\doe_fit_model.html"},{"title":"full_factorial – FSTATS","text":"public  subroutine full_factorial(vars, tbl, err) Computes a table with values scaled from 1 to N describing a \nfull-factorial design. program example use iso_fortran_env use fstats implicit none ! Local Variables integer ( int32 ) :: i , vars ( 3 ), tbl ( 24 , 3 ) ! Define the number of design points for each of the 3 factors to study vars = [ 2 , 4 , 3 ] ! Determine the design table call full_factorial ( vars , tbl ) ! Display the table do i = 1 , size ( tbl , 1 ) print * , tbl ( i ,:) end do end program The above program produces the following output. 1           1           1\n1           1           2\n1           1           3\n1           2           1\n1           2           2\n1           2           3\n1           3           1\n1           3           2\n1           3           3\n1           4           1\n1           4           2\n1           4           3\n2           1           1\n2           1           2\n2           1           3\n2           2           1\n2           2           2\n2           2           3\n2           3           1\n2           3           2\n2           3           3\n2           4           1\n2           4           2\n2           4           3 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vars (:) An M-element array containing the M factors to study. Each of the M entries to the array is expected to contain \nthe number of options for that particular factor to explore. \nThis value must be greater than or equal to 1. integer(kind=int32), intent(out) :: tbl (:,:) A table where the design will be written.  Use \nget_full_factorial_matrix_size to determine the appropriate \ntable size. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_INVALID_INPUT_ERROR: Occurs if any items in vars are \n     less than 1.\n- FS_ARRAY_SIZE_ERROR: Occurs if tbl is not properly sized. Contents","tags":"","loc":"proc\\full_factorial.html"},{"title":"get_full_factorial_matrix_size – FSTATS","text":"public  subroutine get_full_factorial_matrix_size(vars, m, n, err) Computes the appropriate size for a full-factorial design table. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vars (:) An M-element array containing the M factors to study.  Each \nof the M entries to the array is expected to contain the \nnumber of options for that particular factor to explore. This value must be greater than or equal to 1. integer(kind=int32), intent(out) :: m The number of rows for the table. integer(kind=int32), intent(out) :: n The number of columns for the table. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_INVALID_INPUT_ERROR: Occurs if any items in vars are \n     less than 1. Contents","tags":"","loc":"proc\\get_full_factorial_matrix_size.html"},{"title":"doe_evaluate_model – FSTATS","text":"public interface doe_evaluate_model Contents Module Procedures doe_evaluate_model_1 doe_evaluate_model_2 Module Procedures private  function doe_evaluate_model_1(nway, beta, x, map, err) result(rst) Evaluates the model of the following form. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nway The number of interaction levels.  Currently, this algorithm supports\na maximum of three-way interaction. real(kind=real64), intent(in), dimension(:) :: beta The model coefficients. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nat which to evaluate the model. logical, intent(in), optional, target, dimension(:) :: map An optional array of the same size as beta that can be used to\neliminate a parameter from the model (false), or keep a parameter\nin the model (true).  If not supplied, all parameters will be assumed\nto be part of the model as if the array were filled with all true\nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if beta and map are not properly sized\n     relative to one another.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error.\n- FS_INVALID_INPUT_ERROR: Occurs if nway is less than 1 or greater\n     than 3. Return Value real(kind=real64), allocatable, dimension(:) The resulting M-element array. private  function doe_evaluate_model_2(mdl, x, err) result(rst) Evaluates the model of the following form. Arguments Type Intent Optional Attributes Name class( doe_model ), intent(in) :: mdl The model to evaluate. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nat which to evaluate the model. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value real(kind=real64), allocatable, dimension(:) The resulting M-element array.","tags":"","loc":"interface\\doe_evaluate_model.html"},{"title":"difference – FSTATS","text":"public pure function difference(x) result(rst) Computes the difference between elements in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array on which to operate. Return Value real(kind=real64), allocatable, dimension(:) The (N-1)-element array containing the differences between adjacent\nelements. Contents","tags":"","loc":"proc\\difference.html"},{"title":"factorial – FSTATS","text":"public pure elemental function factorial(x) result(rst) Computes the factorial of X. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The value whose factorial is to be computed. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\factorial.html"},{"title":"sample_size – FSTATS","text":"public pure function sample_size(dist, var, delta, bet, alpha) result(rst) Estimates the sample size required to achieve an experiment with the\ndesired power and significance levels to ascertain the desired \ndifference in parameter. See Also Wikipedia Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution to utilize as a measure. real(kind=real64), intent(in) :: var An estimate of the population variance. real(kind=real64), intent(in) :: delta The parameter difference that is desired. real(kind=real64), intent(in), optional :: bet The desired power level.  The default for this value is 0.2, for a \npower of 80%. real(kind=real64), intent(in), optional :: alpha The desired significance level.  The default for this value is 0.05\nfor a confidence level of 95%. Return Value real(kind=real64) The minimum sample size requried to achieve the desired experimental\noutcome. Contents","tags":"","loc":"proc\\sample_size.html"},{"title":"bartletts_test – FSTATS","text":"public  subroutine bartletts_test(x, stat, p) Computes Bartlett's test statistic and associated probability. The statistic is calculated as follows. Where and is the pooled\nvariance. The probability is calculated as the right-tail probability of the\nchi-squared distribution. Bartlett's test is most relevant for distributions showing strong \nnormality.  For distributions lacking strong normality, consider \nLevene's test instead. See Also Wikipedia Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x The arrays of data to analyze. real(kind=real64), intent(out) :: stat The Bartlett's test statistic. real(kind=real64), intent(out) :: p The probability value that the variances of each data set are\nequivalent.  A low p-value, less than some significance level,\nindicates a non-equivalance of variances. Contents","tags":"","loc":"proc\\bartletts_test.html"},{"title":"f_test – FSTATS","text":"public  subroutine f_test(x1, x2, stat, p, dof1, dof2) Computes the F-test and returns the probability (two-tailed) that\nthe variances of two data sets are not significantly different. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The F-statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from the two underlying populations that \nhave the same variance. real(kind=real64), intent(out) :: dof1 A measure of the degrees of freedom. real(kind=real64), intent(out) :: dof2 A measure of the degrees of freedom. Contents","tags":"","loc":"proc\\f_test.html"},{"title":"levenes_test – FSTATS","text":"public  subroutine levenes_test(x, stat, p, err) Computes Levene's test statistic and associated probability. The statistic is calculated as follows. Where: As the test statistic is approximately F-distributed, the F-distribution\nis used to calculate the probability term. See Also Wikipedia Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x The arrays of data to analyze. real(kind=real64), intent(out) :: stat The Bartlett's test statistic. real(kind=real64), intent(out) :: p The probability value that the variances of each data set are\nequivalent.  A low p-value, less than some significance level,\nindicates a non-equivalance of variances. class(errors), intent(inout), optional, target :: err Contents","tags":"","loc":"proc\\levenes_test.html"},{"title":"t_test_equal_variance – FSTATS","text":"public  subroutine t_test_equal_variance(x1, x2, stat, p, dof) Computes the 2-tailed Student's T-Test for two data sets of \nassumed equivalent variances. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom. Contents","tags":"","loc":"proc\\t_test_equal_variance.html"},{"title":"t_test_paired – FSTATS","text":"public  subroutine t_test_paired(x1, x2, stat, p, dof, err) Computes the 2-tailed Student's T-Test for two paired data sets. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An N-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from  two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x1 and x2 are not the same \n  length. Contents","tags":"","loc":"proc\\t_test_paired.html"},{"title":"t_test_unequal_variance – FSTATS","text":"public  subroutine t_test_unequal_variance(x1, x2, stat, p, dof) Computes the 2-tailed Student's T-Test for two data sets of \nassumed non-equivalent variances. See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom. Contents","tags":"","loc":"proc\\t_test_unequal_variance.html"},{"title":"confidence_interval – FSTATS","text":"public interface confidence_interval Computes the confidence interval for the specified distribution. See Also Wikipedia Contents Module Procedures confidence_interval_scalar confidence_interval_array Module Procedures private pure function confidence_interval_scalar(dist, alpha, s, n) result(rst) Computes the confidence interval for the specified distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution object defining the probability distribution\nto establish the confidence level. real(kind=real64), intent(in) :: alpha The probability value of interest.  For instance, use a value of 0.05\nfor a confidence level of 95%. real(kind=real64), intent(in) :: s The sample standard deviation. integer(kind=int32), intent(in) :: n The number of samples in the data set. Return Value real(kind=real64) The result. private pure function confidence_interval_array(dist, alpha, x) result(rst) Computes the confidence interval for the specified distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution object defining the probability distribution\nto establish the confidence level. real(kind=real64), intent(in) :: alpha The probability value of interest.  For instance, use a value of 0.05\nfor a confidence level of 95%. real(kind=real64), intent(in) :: x (:) An N-element array containing the data to analyze. Return Value real(kind=real64) The result.","tags":"","loc":"interface\\confidence_interval.html"},{"title":"adjusted_r_squared – FSTATS","text":"public  function adjusted_r_squared(p, x, xm, err) result(rst) Computes the adjusted R-squared value for a data set. The adjusted R-squared provides a mechanism for tempering the effects\nof extra explanatory variables on the traditional R-squared \ncalculation.  It is computed by noting the sample size and \nthe number of variables . . See Also: Wikipedia Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: p The number of variables. real(kind=real64), intent(in) :: x (:) An N-element array containing the dependent variables from \nthe data set. real(kind=real64), intent(in) :: xm (:) An N-element array containing the corresponding modeled \nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings\nto the caller.  Possible warning and error codes are as \nfollows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the \n  same size. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\adjusted_r_squared.html"},{"title":"calculate_regression_statistics – FSTATS","text":"public  function calculate_regression_statistics(resid, params, c, alpha, err) result(rst) Computes statistics for the quality of fit for a regression \nmodel. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: resid (:) An M-element array containing the model residual errors. real(kind=real64), intent(in) :: params (:) An N-element array containing the model parameters. real(kind=real64), intent(in) :: c (:,:) The N-by-N covariance matrix. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if c is not sized correctly.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value type( regression_statistics ), allocatable, (:) A regression_statistics object containing the analysis results. Contents","tags":"","loc":"proc\\calculate_regression_statistics.html"},{"title":"correlation – FSTATS","text":"public pure function correlation(x, y) result(rst) Computes the sample correlation coefficient (an estimate to the \npopulation Pearson correlation) as follows. . Where, & are the sample standard deviations of\nx and y respectively. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The first N-element data set. real(kind=real64), intent(in), dimension(size(x)) :: y The second N-element data set. Return Value real(kind=real64) The correlation coefficient. Contents","tags":"","loc":"proc\\correlation.html"},{"title":"r_squared – FSTATS","text":"public  function r_squared(x, xm, err) result(rst) Computes the R-squared value for a data set. The R-squared value is computed by determining the sum of the squares\nof the residuals: The total sum of the squares: . \nThe R-squared value is then: . See Also: Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the dependent variables from \nthe data set. real(kind=real64), intent(in) :: xm (:) An N-element array containing the corresponding modeled \nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings\nto the caller.  Possible warning and error codes are as \nfollows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the \n  same size. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\r_squared.html"},{"title":"covariance_matrix – FSTATS","text":"public  subroutine covariance_matrix(x, c, err) Computes the covariance matrix where and is computed\nby design_matrix. See Also Wikipedia Wikipedia - Regression Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:) An M-by-N matrix containing the formatted independent data\n matrix as computed by design_matrix. real(kind=real64), intent(out) :: c (:,:) The N-by-N covariance matrix. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the matrices are not \n     sized correctly.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Contents","tags":"","loc":"proc\\covariance_matrix.html"},{"title":"design_matrix – FSTATS","text":"public  subroutine design_matrix(order, intercept, x, c, err) Computes the design matrix for the linear \nleast-squares regression problem of , where is the matrix computed here, is \nthe vector of coefficients to be determined, and is the \nvector of measured dependent variables. See Also Wikipedia Wikipedia Wikipedia Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: order The order of the equation to fit.  This value must be\nat least one (linear equation), but can be higher as desired. logical, intent(in) :: intercept Set to true if the intercept is being computed\nas part of the regression; else, false. real(kind=real64), intent(in) :: x (:) An N-element array containing the independent variable\nmeasurement points. real(kind=real64), intent(out) :: c (:,:) An N-by-K matrix where the results will be written.  K\nmust equal order + 1 in the event intercept is true; \nhowever, if intercept is false, K must equal order. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if c is not properly sized.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. Contents","tags":"","loc":"proc\\design_matrix.html"},{"title":"jacobian – FSTATS","text":"public  subroutine jacobian(fun, xdata, params, jac, stop, f0, f1, step, err) Computes the Jacobian matrix for a nonlinear regression problem. Arguments Type Intent Optional Attributes Name procedure( regression_function ), intent(in), pointer :: fun A pointer to the regression_function to evaluate. real(kind=real64), intent(in) :: xdata (:) The M-element array containing x-coordinate data. real(kind=real64), intent(in) :: params (:) The N-element array containing the model parameters. real(kind=real64), intent(out) :: jac (:,:) The M-by-N matrix where the Jacobian will be written. logical, intent(out) :: stop A value that the user can set in fun forcing the\nevaluation process to stop prior to completion. real(kind=real64), intent(in), optional, target :: f0 (:) An optional M-element array containing the model values\n using the current parameters as defined in m.  This input \ncan be used to prevent the routine from performing a \nfunction evaluation at the model parameter state defined in \nparams. real(kind=real64), intent(out), optional, target :: f1 (:) An optional M-element workspace array used for function\nevaluations. real(kind=real64), intent(in), optional :: step The differentiation step size.  The default is the square \nroot of machine precision. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     properly sized.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Contents","tags":"","loc":"proc\\jacobian.html"},{"title":"linear_least_squares – FSTATS","text":"public  subroutine linear_least_squares(order, intercept, x, y, coeffs, ymod, resid, stats, alpha, err) Computes a linear least-squares regression to fit a set of data. See Also Wikipedia SPC Excel Understanding Regression Statistics Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: order The order of the equation to fit.  This value must be at \nleast one (linear equation), but can be higher as desired, \nas long as there is sufficient data. logical, intent(in) :: intercept Set to true if the intercept is being computed as part of \nthe regression; else, false. real(kind=real64), intent(in) :: x (:) An N-element array containing the independent variable\nmeasurement points. real(kind=real64), intent(in) :: y (:) An N-element array containing the dependent variable\nmeasurement points. real(kind=real64), intent(out) :: coeffs (:) An ORDER+1 element array where the coefficients will be written. real(kind=real64), intent(out) :: ymod (:) An N-element array where the modeled data will be written. real(kind=real64), intent(out) :: resid (:) An N-element array where the residual error data will be \nwritten (modeled - actual). type( regression_statistics ), intent(out), optional :: stats (:) An M-element array of regression_statistics items where \nM = ORDER + 1 when intercept is set to true; however, if \nintercept is set to false, M = ORDER. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     approriately sized.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Contents","tags":"","loc":"proc\\linear_least_squares.html"},{"title":"nonlinear_least_squares – FSTATS","text":"public  subroutine nonlinear_least_squares(fun, x, y, params, ymod, resid, weights, maxp, minp, stats, alpha, controls, settings, info, status, cov, err) Performs a nonlinear regression to fit a model using a version\nof the Levenberg-Marquardt algorithm. Arguments Type Intent Optional Attributes Name procedure( regression_function ), intent(in), pointer :: fun A pointer to the regression_function to evaluate. real(kind=real64), intent(in) :: x (:) The M-element array containing independent data. real(kind=real64), intent(in) :: y (:) The M-element array containing dependent data. real(kind=real64), intent(inout) :: params (:) On input, the N-element array containing the initial estimate\nof the model parameters.  On output, the computed model \nparameters. real(kind=real64), intent(out) :: ymod (:) An M-element array where the modeled dependent data will\nbe written. real(kind=real64), intent(out) :: resid (:) An M-element array where the model residuals will be\nwritten. real(kind=real64), intent(in), optional, target :: weights (:) An optional M-element array allowing the weighting of\nindividual points. real(kind=real64), intent(in), optional, target :: maxp (:) An optional N-element array that can be used as upper limits \non the parameter values.  If no upper limit is requested for\na particular parameter, utilize a very large value.  The \ninternal default is to utilize huge() as a value. real(kind=real64), intent(in), optional, target :: minp (:) An optional N-element array that can be used as lower limits \non the parameter values.  If no lower limit is requested for\na particalar parameter, utilize a very large magnitude, but \nnegative, value.  The internal default is to utilize -huge() \nas a value. type( regression_statistics ), intent(out), optional :: stats (:) An optional N-element array that, if supplied, will be used \nto return statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. type( iteration_controls ), intent(in), optional :: controls An optional input providing custom iteration controls. type( lm_solver_options ), intent(in), optional :: settings An optional input providing custom settings for the solver. type( convergence_info ), intent(out), optional, target :: info An optional output that can be used to gain information about\nthe iterative solution and the nature of the convergence. procedure( iteration_update ), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract\niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return\nthe covariance matrix. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows. FS_NO_ERROR: No errors encountered. FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     properly sized. FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. FS_UNDERDEFINED_PROBLEM_ERROR: Occurs if the problem posed \n     is underdetetermined (M < N). FS_TOLERANCE_TOO_SMALL_ERROR: Occurs if any supplied \n     tolerances are too small to be practical. FS_TOO_FEW_ITERATION_ERROR: Occurs if too few iterations \n     are allowed. Contents","tags":"","loc":"proc\\nonlinear_least_squares.html"},{"title":"iteration_update – FSTATS","text":"interface public  subroutine iteration_update(iter, funvals, resid, params, step) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in), dimension(:) :: funvals The function values. real(kind=real64), intent(in), dimension(:) :: resid The residuals. real(kind=real64), intent(in), dimension(:) :: params The model parameters. real(kind=real64), intent(in), dimension(:) :: step Step sizes for each parameter. Description Defines a routine for providing updates about an iteration\nprocess.","tags":"","loc":"interface\\iteration_update.html"},{"title":"regression_function – FSTATS","text":"interface public  subroutine regression_function(xdata, params, f, stop) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xdata An N-element array containing the N independent data points. real(kind=real64), intent(in), dimension(:) :: params An M-element array containing the M model parameters. real(kind=real64), intent(out), dimension(:) :: f An N-element array where the results of the N function \nevaluations will be written. logical, intent(out) :: stop A mechanism to force a stop to the iteration process.  If\nset to true, the iteration process will terminate.  If set\nto false, the iteration process will continue along as \nnormal. Description Defines the interface of a subroutine computing the function\nvalues at each of the N data points as part of a regression\nanalysis.","tags":"","loc":"interface\\regression_function.html"},{"title":"rejection_sample – FSTATS","text":"public  function rejection_sample(tdist, n, xmin, xmax) result(rst) Uses rejection sampling to randomly sample a target distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: tdist The distribution to sample integer(kind=int32), intent(in) :: n The number of samples to make. real(kind=real64), intent(in) :: xmin The minimum range to explore. real(kind=real64), intent(in) :: xmax The maximum range to explore. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the N samples from the \ndistribution. Contents","tags":"","loc":"proc\\rejection_sample.html"},{"title":"sample_normal_multivariate – FSTATS","text":"public  function sample_normal_multivariate(dist) result(rst) Samples a multivariate normal distribution such that , where is the lower form of the Cholesky \nfactorization of the covariance matrix, and is a randomly \ngenerated vector that exists on the set Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: dist The multivariate normal distribution to sample. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. Contents","tags":"","loc":"proc\\sample_normal_multivariate.html"},{"title":"box_muller_sample – FSTATS","text":"public interface box_muller_sample Generates random, normally distributed values via the Box-Muller \ntransform. Contents Module Procedures box_muller_sample_scalar box_muller_array Module Procedures private  function box_muller_sample_scalar(mu, sigma) result(rst) Generates a pair of independent, standard, normally distributed\nrandom values using the Box-Muller transform. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: mu The mean of the distribution. real(kind=real64), intent(in) :: sigma The standard deviation of the distribution. Return Value real(kind=real64), (2) The pair of random values. private  function box_muller_array(mu, sigma, n) result(rst) Generates an array of normally distributed random values sampled\nby the Box-Muller transform. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: mu The mean of the distribution. real(kind=real64), intent(in) :: sigma The standard deviation of the distribution. integer(kind=int32), intent(in) :: n The number of Box-Muller pairs to generate. Return Value real(kind=real64), allocatable, dimension(:) A 2N-element array containing the N Box-Muller pairs.","tags":"","loc":"interface\\box_muller_sample.html"},{"title":"lowess – FSTATS","text":"public  subroutine lowess(x, y, ys, fsmooth, nstps, del, rweights, resid, err) Computes the smoothing of a data set using a robust locally weighted\nscatterplot smoothing (LOWESS) algorithm.  Fitted values are computed at\neach of the supplied x values. Remarks The code is a reimplementation of the LOWESS library.  For a detailed\nunderstanding, see [this]\n(http://www.aliquote.org/cours/2012_biomed/biblio/Cleveland1979.pdf) \npaper by William Cleveland. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variable data.  This\narray must be monotonically increasing. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the dependent variable data. real(kind=real64), intent(out), dimension(:) :: ys An N-element array where the smoothed results will be written. real(kind=real64), intent(in), optional :: fsmooth An optional input that specifies the amount of smoothing. Specifically, this value is the fraction of points used to compute\neach value.  As this value increases, the output becomes smoother.\nChoosing a value in the range of 0.2 to 0.8 typically results in a\ngood fit.  The default value is 0.2. integer(kind=int32), intent(in), optional :: nstps An optional input that specifies the numb of iterations.  If set to\nzero, a non-robust fit is returned.  The default value is set to 2. real(kind=real64), intent(in), optional :: del real(kind=real64), intent(out), optional, dimension(:), target :: rweights An optional N-element array, that if supplied, will be used to\nreturn the weights given to each data point. real(kind=real64), intent(out), optional, dimension(:), target :: resid An optional N-element array, that if supplied, will be used to \nreturn the residual. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     approriately sized.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation error. Contents","tags":"","loc":"proc\\lowess.html"},{"title":"beta – FSTATS","text":"public pure elemental function beta(a, b) result(rst) Computes the beta function. The beta function is related to the gamma function\nby the following relationship. . See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. Return Value real(kind=real64) The value of the beta function at and . Contents","tags":"","loc":"proc\\beta.html"},{"title":"digamma – FSTATS","text":"public pure elemental function digamma(x) result(rst) Computes the digamma function. The digamma function is defined as: See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. Contents","tags":"","loc":"proc\\digamma.html"},{"title":"incomplete_beta – FSTATS","text":"public pure elemental function incomplete_beta(a, b, x) result(rst) Computes the incomplete beta function. The incomplete beta function is defind as: . See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. real(kind=real64), intent(in) :: x The upper limit of the integration. Return Value real(kind=real64) The value of the incomplete beta function. Contents","tags":"","loc":"proc\\incomplete_beta.html"},{"title":"incomplete_gamma_lower – FSTATS","text":"public pure elemental function incomplete_gamma_lower(a, x) result(rst) Computes the lower incomplete gamma function. The lower incomplete gamma function is defined as: See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The coefficient value. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. Contents","tags":"","loc":"proc\\incomplete_gamma_lower.html"},{"title":"incomplete_gamma_upper – FSTATS","text":"public pure elemental function incomplete_gamma_upper(a, x) result(rst) Computes the upper incomplete gamma function. The upper incomplete gamma function is defined as: See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The coefficient value. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. Contents","tags":"","loc":"proc\\incomplete_gamma_upper.html"},{"title":"regularized_beta – FSTATS","text":"public pure elemental function regularized_beta(a, b, x) result(rst) Computes the regularized beta function. The regularized beta function is defined as the ratio between\nthe incomplete beta function and the beta function. . See Also Wikipedia Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. real(kind=real64), intent(in) :: x The upper limit of the integration. Return Value real(kind=real64) The value of the regularized beta function. Contents","tags":"","loc":"proc\\regularized_beta.html"},{"title":"fstats – FSTATS","text":"FSTATS is a modern Fortran statistical library containing routines for \ncomputing basic statistical properties, hypothesis testing, regression, \nspecial functions, and experimental design. Uses fstats_mcmc_fitting fstats_anova fstats_allan fstats_special_functions iso_fortran_env fstats_bootstrap fstats_regression fstats_experimental_design fstats_helper_routines fstats_sampling fstats_distributions fstats_smoothing fstats_descriptive_statistics fstats_hypothesis fstats_mcmc Contents None","tags":"","loc":"module\\fstats.html"},{"title":"fstats_allan – FSTATS","text":"Uses iso_fortran_env fstats_errors Contents Functions allan_variance Functions public  function allan_variance (x, dt, err) result(rst) Computes the Allan variance of a data set. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element data set to analyze. real(kind=real64), intent(in), optional :: dt An optional input specifying the time increment between \nsamples in x.  If not specified, this value is set to 1. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value real(kind=real64), allocatable, dimension(:,:) An M-by-2 array containing the results where M is N / 2 - 1\nif N is even; else, M is (N - 1) / 2 - 1 if N is odd.  The \nfirst column contains the averaging times associated with \nthe M results stored in the second column.","tags":"","loc":"module\\fstats_allan.html"},{"title":"fstats_anova – FSTATS","text":"Uses ieee_arithmetic fstats_special_functions ferror iso_fortran_env fstats_errors fstats_distributions fstats_descriptive_statistics Contents Interfaces anova Derived Types anova_factor single_factor_anova_table two_factor_anova_table Interfaces public        interface anova Performs an analysis of variance (ANOVA) on the supplied data \nset. The following example illustrates a single-factor ANOVA on a \ndata set. program example use iso_fortran_env use fstats implicit none ! Local Variables character , parameter :: tab = achar ( 9 ) real ( real64 ) :: x ( 10 , 2 ) type ( single_factor_anova_table ) :: tbl ! Define the data x = reshape ( & [ & 3.086d3 , 3.082d3 , 3.069d3 , 3.072d3 , 3.045d3 , 3.070d3 , 3.079d3 , & 3.050d3 , 3.062d3 , 3.062d3 , 3.075d3 , 3.061d3 , 3.063d3 , 3.038d3 , & 3.070d3 , 3.062d3 , 3.070d3 , 3.049d3 , 3.042d3 , 3.063d3 & ], & [ 10 , 2 ] & ) ! Perform the ANOVA tbl = anova ( x ) ! Print out the table print '(A)' , \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" print '(AF2.0AF5.1AF5.1AF5.3AF5.3)' , \"Main Factor: \" // tab , & tbl % main_factor % dof , tab , & tbl % main_factor % sum_of_squares , tab // tab , & tbl % main_factor % variance , tab // tab , & tbl % main_factor % f_statistic , tab , & tbl % main_factor % probability print '(AF3.0AF6.1AF5.1)' , \"Within: \" // tab , & tbl % within_factor % dof , tab , & tbl % within_factor % sum_of_squares , tab // tab , & tbl % within_factor % variance print '(AF3.0AF6.1AF5.1)' , \"Total: \" // tab // tab , & tbl % total_dof , tab , & tbl % total_sum_of_squares , tab // tab , & tbl % total_variance print '(AF6.1)' , \"Overall Mean: \" , tbl % overall_mean end program The above program produces the following output. Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value\nMain Factor:    1.      352.8           352.8           2.147   0.160\nWithin:         18.     2958.2          164.3\nTotal:          19.     3311.0          174.3\nOverall Mean: 3063.5 See Also Wikipedia SPC Excel Single Factor ANOVA SPC Excel Gage R&R SPC Excel Understanding Regression Statistics NIST - Two Way ANOVA private  function anova_1_factor(x) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:) An M-by-N matrix containing the M replications of the N test \npoints of interest. Return Value type( single_factor_anova_table ) A single_factor_anova_table instance containing the ANOVA results. private  function anova_2_factor(x) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:,:) An M-by-N-by-K array containing the M replications of the\nN first factor results, and the K second factor results. Return Value type( two_factor_anova_table ) A two_factor_anova_table instance containing the ANOVA results. private  function anova_model_fit(nmodelparams, ymeas, ymod, err) result(rst) Performs an analysis of variance (ANOVA) on the supplied data set. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nmodelparams The number of model parameters. real(kind=real64), intent(in) :: ymeas (:) An N-element array containing the measured dependent variable data. real(kind=real64), intent(in) :: ymod (:) An N-element array containing the modeled dependent variable data. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if ymeas and ymod are not the \n  same length.\n- FS_MEMORY_ERROR: Occurs if a memory error is encountered. Return Value type( single_factor_anova_table ) A single_factor_anova_table instance containing the ANOVA results. Derived Types type, public :: anova_factor Defines an ANOVA factor result. Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedome. real(kind=real64), public :: f_statistic The F-statistic. real(kind=real64), public :: probability The variance probability term. real(kind=real64), public :: sum_of_squares The sum of the squares. real(kind=real64), public :: variance The estimate of variance. type, public :: single_factor_anova_table Defines a single-factor ANOVA results table. Components Type Visibility Attributes Name Initial type( anova_factor ), public :: main_factor The main, or main factor, results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within-treatement (error) results. type, public :: two_factor_anova_table Defines a two-factor ANOVA results table. Components Type Visibility Attributes Name Initial type( anova_factor ), public :: interaction The interaction effects. type( anova_factor ), public :: main_factor_1 The first main-factor results. type( anova_factor ), public :: main_factor_2 The second main-factor results. real(kind=real64), public :: overall_mean The overall mean value. real(kind=real64), public :: total_dof The total number of degrees of freedom. real(kind=real64), public :: total_sum_of_squares The total sum of squares. real(kind=real64), public :: total_variance The total variance estimate. type( anova_factor ), public :: within_factor The within (error) factor results.","tags":"","loc":"module\\fstats_anova.html"},{"title":"fstats_bootstrap – FSTATS","text":"Uses fstats_special_functions linalg iso_fortran_env fstats_regression fstats_errors omp_lib fstats_distributions fstats_descriptive_statistics Contents Interfaces bootstrap_resampling_routine bootstrap_statistic_routine Derived Types bootstrap_statistics Functions bootstrap Subroutines random_resample scaled_random_resample Interfaces interface public  subroutine bootstrap_resampling_routine(x, xn) Defines the signature of a subroutine used to compute a \nresampling of data for bootstrapping purposes. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be \nwritten. interface public  function bootstrap_statistic_routine(x) result(rst) Defines the signature of a function for computing the desired\nbootstrap statistic. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The array of data to analyze. Return Value real(kind=real64) The resulting statistic. Derived Types type, public :: bootstrap_statistics A collection of statistics resulting from the bootstrap process. Components Type Visibility Attributes Name Initial real(kind=real64), public :: bias The bias in the statistic. real(kind=real64), public :: lower_confidence_interval The lower confidence limit on the statistic. real(kind=real64), public, allocatable, dimension(:) :: population An array of the population values generated by the bootstrap\nprocess. real(kind=real64), public :: standard_error The standard error of the statistic. real(kind=real64), public :: statistic_value The value of the statistic of interest. real(kind=real64), public :: upper_confidence_interval The upper confidence limit on the statistic. Functions public  function bootstrap (stat, x, method, nsamples, alpha) result(rst) Performs a bootstrap calculation on the supplied data set for the given\nstatistic.  The default implementation utlizes a random resampling with \nreplacement.  Other resampling methods may be defined by specifying an \nappropriate routine by means of the method input. Arguments Type Intent Optional Attributes Name procedure( bootstrap_statistic_routine ), intent(in), pointer :: stat The routine used to compute the desired statistic. real(kind=real64), intent(in), dimension(:) :: x The N-element data set. procedure( bootstrap_resampling_routine ), intent(in), optional, pointer :: method An optional pointer to the method to use for resampling of the data.\nIf no method is supplied, a random resampling is utilized. integer(kind=int32), intent(in), optional :: nsamples An optional input, that if supplied, specifies the number of \nresampling runs to perform.  The default is 10 000. real(kind=real64), intent(in), optional :: alpha An optional input, that if supplied, defines the significance level\nto use for the analysis.  The default is 0.05. Return Value type( bootstrap_statistics ) The resulting bootstrap_statistics type containing the confidence\nintervals, bias, standard error, etc. for the analyzed statistic. Subroutines public  subroutine random_resample (x, xn) Random resampling, with replacement, based upon a normal distribution. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be written. public  subroutine scaled_random_resample (x, xn) A random resampling, scaled by the standard deviation of the original\ndata, but based upon a normal distribution. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array to resample. real(kind=real64), intent(out), dimension(size(x)) :: xn An N-element array where the resampled data set will be written.","tags":"","loc":"module\\fstats_bootstrap.html"},{"title":"fstats_descriptive_statistics – FSTATS","text":"Uses linalg ferror iso_fortran_env fstats_types fstats_errors Contents Interfaces pooled_variance Functions covariance mean median quantile standard_deviation trimmed_mean variance Interfaces public        interface pooled_variance Computes the pooled estimate of variance. private pure function pooled_variance_1(si, ni) result(rst) Computes the pooled estimate of variance. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: si An N-element array containing the estimates for each of the N\nvariances. integer(kind=int32), intent(in), dimension(size(si)) :: ni An N-element array containing the number of data points in each\nof the data sets used to compute the variances in si. Return Value real(kind=real64) The pooled variance. private pure function pooled_variance_2(x) result(rst) Computes the pooled estimate of variance. Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x An array of arrays of data. Return Value real(kind=real64) The pooled variance. Functions public pure function covariance (x, y) result(rst) Computes the sample covariance of two data sets. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The first N-element data set. real(kind=real64), intent(in), dimension(size(x)) :: y The second N-element data set. Return Value real(kind=real64) The covariance. public pure function mean (x) result(rst) Computes the mean of the values in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64) The result. public  function median (x) result(rst) Computes the median of the values in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout) :: x (:) The array of values to analyze.  On output, this array is sorted into\nascending order. Return Value real(kind=real64) The result. public pure function quantile (x, q) result(rst) Computes the specified quantile of a data set using the SAS \nMethod 4. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the data. real(kind=real64), intent(in) :: q The quantile to compute (e.g. 0.25 computes the 25% quantile). Return Value real(kind=real64) The result. public pure function standard_deviation (x) result(rst) Computes the sample standard deviation of the values in an array. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64) The result. public  function trimmed_mean (x, p) result(rst) Computes the trimmed mean of a data set. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:) :: x An N-element array containing the data.  On output, the\narray is sorted into ascending order. real(kind=real64), intent(in), optional :: p An optional parameter specifying the percentage of values\nfrom either end of the distribution to remove.  The default\nis 0.05 such that the bottom 5% and top 5% are removed. Return Value real(kind=real64) The trimmed mean. public pure function variance (x) result(rst) Computes the sample variance of the values in an array. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) The array of values to analyze. Return Value real(kind=real64)","tags":"","loc":"module\\fstats_descriptive_statistics.html"},{"title":"fstats_distributions – FSTATS","text":"Uses ieee_arithmetic fstats_special_functions ferror iso_fortran_env fstats_errors fstats_helper_routines Contents Interfaces distribution_function distribution_property multivariate_distribution_function Derived Types binomial_distribution chi_squared_distribution distribution f_distribution log_normal_distribution multivariate_distribution multivariate_normal_distribution normal_distribution t_distribution Interfaces interface public pure elemental function distribution_function(this, x) result(rst) Defines the interface for a probability distribution function. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The value of the function. interface public pure function distribution_property(this) result(rst) Computes the value of a distribution property. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: this The distribution object. Return Value real(kind=real64) The property value. interface public pure function multivariate_distribution_function(this, x) result(rst) Defines an interface for a multivariate probability distribution\nfunction. Arguments Type Intent Optional Attributes Name class( multivariate_distribution ), intent(in) :: this The distribution object. real(kind=real64), intent(in), dimension(:) :: x The values at which to evaluate the function. Return Value real(kind=real64) The value of the function. Derived Types type, public, extends( distribution ) :: binomial_distribution Defines a binomial distribution.  The binomial distribution describes\nthe probability p of getting k successes in n independent trials. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: n The number of independent trials. real(kind=real64), public :: p The success probability for each trial.  This parameter must\nexist on the set [0, 1]. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    bd_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    bd_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    bd_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    bd_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    bd_pdf Function procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    bd_variance Function type, public, extends( distribution ) :: chi_squared_distribution Defines a Chi-squared distribution. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    cs_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    cs_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    cs_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    cs_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    cs_pdf Function procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    cs_variance Function type, public :: distribution Defines a probability distribution. Type-Bound Procedures procedure\n(distribution_function)                    ,                  public\n, pass                  :: cdf Computes the cumulative distribution function. procedure\n(distribution_property)                    ,                  public\n, pass                  :: mean Computes the mean of the distribution. procedure\n(distribution_property)                    ,                  public\n, pass                  :: median Computes the median of the distribution. procedure\n(distribution_property)                    ,                  public\n, pass                  :: mode Computes the mode of the distribution. procedure\n(distribution_function)                    ,                  public\n, pass                  :: pdf Computes the probability density function. procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n(distribution_property)                    ,                  public\n, pass                  :: variance Computes the variance of the distribution. type, public, extends( distribution ) :: f_distribution Defines an F-distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: d1 The measure of degrees of freedom for the first data set. real(kind=real64), public :: d2 The measure of degrees of freedom for the second data set. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    fd_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    fd_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    fd_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    fd_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    fd_pdf Function procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    fd_variance Function type, public, extends( distribution ) :: log_normal_distribution Defines a normal distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    lnd_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    lnd_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    lnd_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    lnd_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    lnd_pdf Function procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    lnd_variance Function type, public :: multivariate_distribution Defines a multivariate probability distribution. Type-Bound Procedures procedure\n(multivariate_distribution_function)                    ,                  public\n, pass                  :: pdf Computes the probability density function. type, public, extends( multivariate_distribution ) :: multivariate_normal_distribution Defines a multivariate normal (Gaussian) distribution. Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_cholesky_factored_matrix =>\n                    mvnd_get_cholesky Function procedure\n                    ,                  public\n                  :: get_covariance =>\n                    mvnd_get_covariance Function procedure\n                    ,                  public\n                  :: get_means =>\n                    mvnd_get_means Function procedure\n                    ,                  public\n                  :: initialize =>\n                    mvnd_init Subroutine procedure\n                    ,                  public\n                  :: pdf =>\n                    mvnd_pdf Function procedure\n                    ,                  public\n                  :: set_means =>\n                    mvnd_update_mean Subroutine type, public, extends( distribution ) :: normal_distribution Defines a normal distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: mean_value The mean value of the distribution. real(kind=real64), public :: standard_deviation The standard deviation of the distribution. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    nd_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    nd_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    nd_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    nd_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    nd_pdf Function procedure\n                    ,                  public\n                  :: standardize =>\n                    nd_standardize Subroutine procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    nd_variance Function type, public, extends( distribution ) :: t_distribution Defines Student's T-Distribution. Components Type Visibility Attributes Name Initial real(kind=real64), public :: dof The number of degrees of freedom. Type-Bound Procedures procedure\n                    ,                  public\n                  :: cdf =>\n                    td_cdf Function procedure\n                    ,                  public\n                  :: mean =>\n                    td_mean Function procedure\n                    ,                  public\n                  :: median =>\n                    td_median Function procedure\n                    ,                  public\n                  :: mode =>\n                    td_mode Function procedure\n                    ,                  public\n                  :: pdf =>\n                    td_pdf Function procedure\n                    ,                  public\n                  :: standardized_variable =>\n                    dist_std_var Function Computes the standardized variable for the distribution. procedure\n                    ,                  public\n                  :: variance =>\n                    td_variance Function","tags":"","loc":"module\\fstats_distributions.html"},{"title":"fstats_errors – FSTATS","text":"Uses iso_fortran_env ferror Contents Variables FS_ARRAY_SIZE_ERROR FS_INVALID_ARGUMENT_ERROR FS_INVALID_INPUT_ERROR FS_MATRIX_SIZE_ERROR FS_MEMORY_ERROR FS_NO_ERROR FS_TOLERANCE_TOO_SMALL_ERROR FS_TOO_FEW_ITERATION_ERROR FS_UNDERDEFINED_PROBLEM_ERROR Subroutines report_array_size_error report_arrays_not_same_size_error report_iteration_count_error report_matrix_size_error report_memory_error report_underdefined_error Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: FS_ARRAY_SIZE_ERROR = 10000 integer(kind=int32), public, parameter :: FS_INVALID_ARGUMENT_ERROR = 10007 integer(kind=int32), public, parameter :: FS_INVALID_INPUT_ERROR = 10002 integer(kind=int32), public, parameter :: FS_MATRIX_SIZE_ERROR = 10001 integer(kind=int32), public, parameter :: FS_MEMORY_ERROR = 10003 integer(kind=int32), public, parameter :: FS_NO_ERROR = 0 integer(kind=int32), public, parameter :: FS_TOLERANCE_TOO_SMALL_ERROR = 10005 integer(kind=int32), public, parameter :: FS_TOO_FEW_ITERATION_ERROR = 10006 integer(kind=int32), public, parameter :: FS_UNDERDEFINED_PROBLEM_ERROR = 10004 Subroutines public  subroutine report_array_size_error (err, fname, name, expect, actual) Reports an array size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name The name of the array. integer(kind=int32), intent(in) :: expect The expected size of the array. integer(kind=int32), intent(in) :: actual The actual size of the array. public  subroutine report_arrays_not_same_size_error (err, fname, name1, name2, size1, size2) Reports an error relating to two arrays not being the same size\nwhen they should be the same size. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name1 The name of the first array. character(len=*), intent(in) :: name2 The name of the second array. integer(kind=int32), intent(in) :: size1 The size of the first array. integer(kind=int32), intent(in) :: size2 The size of the second array. public  subroutine report_iteration_count_error (err, fname, msg, mincount) Reports an iteration count error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*) :: fname The name of the routine in which the error occurred. character(len=*) :: msg The error message. integer(kind=int32), intent(in) :: mincount The minimum iteration count expected. public  subroutine report_matrix_size_error (err, fname, name, expect_rows, expect_cols, actual_rows, actual_cols) Reports a matrix size error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. character(len=*), intent(in) :: name The name of the matrix. integer(kind=int32), intent(in) :: expect_rows The expected number of rows. integer(kind=int32), intent(in) :: expect_cols The expected number of columns. integer(kind=int32), intent(in) :: actual_rows The actual number of rows. integer(kind=int32), intent(in) :: actual_cols The actual number of columns. public  subroutine report_memory_error (err, fname, code) Reports a memory allocation related error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. integer(kind=int32), intent(in) :: code The error code returned by the allocation routine. public  subroutine report_underdefined_error (err, fname, expect, actual) Reports an underdefined problem error. Arguments Type Intent Optional Attributes Name class(errors), intent(inout) :: err The error handling object. character(len=*), intent(in) :: fname The name of the routine in which the error occurred. integer(kind=int32), intent(in) :: expect The expected minimum number of equations. integer(kind=int32), intent(in) :: actual The actual number of equations.","tags":"","loc":"module\\fstats_errors.html"},{"title":"fstats_experimental_design – FSTATS","text":"Uses iso_fortran_env fstats_regression fstats_errors Contents Interfaces doe_evaluate_model Derived Types doe_model Functions doe_fit_model Subroutines full_factorial get_full_factorial_matrix_size Interfaces public        interface doe_evaluate_model private  function doe_evaluate_model_1(nway, beta, x, map, err) result(rst) Evaluates the model of the following form. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nway The number of interaction levels.  Currently, this algorithm supports\na maximum of three-way interaction. real(kind=real64), intent(in), dimension(:) :: beta The model coefficients. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nat which to evaluate the model. logical, intent(in), optional, target, dimension(:) :: map An optional array of the same size as beta that can be used to\neliminate a parameter from the model (false), or keep a parameter\nin the model (true).  If not supplied, all parameters will be assumed\nto be part of the model as if the array were filled with all true\nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if beta and map are not properly sized\n     relative to one another.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error.\n- FS_INVALID_INPUT_ERROR: Occurs if nway is less than 1 or greater\n     than 3. Return Value real(kind=real64), allocatable, dimension(:) The resulting M-element array. private  function doe_evaluate_model_2(mdl, x, err) result(rst) Evaluates the model of the following form. Arguments Type Intent Optional Attributes Name class( doe_model ), intent(in) :: mdl The model to evaluate. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nat which to evaluate the model. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value real(kind=real64), allocatable, dimension(:) The resulting M-element array. Derived Types type, public :: doe_model A model used to represent a design of experiments result.  The model\nis of the following form. Read more… Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: coefficients The model coefficients. logical, public, allocatable, dimension(:) :: map An array denoting if a model coefficient should be included\nas part of the model (true), or neglected (false). integer(kind=int32), public :: nway The number of interaction levels. type( regression_statistics ), public, allocatable, dimension(:) :: stats Statistical information for each model parameter. Functions public  function doe_fit_model (nway, x, y, map, alpha, err) result(rst) Fits a Taylor series model to the provided data. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: nway The number of interaction levels. real(kind=real64), intent(in), dimension(:,:) :: x The M-by-N matrix containing the M values of each of the N factors\nused to produce the results. real(kind=real64), intent(in), dimension(:) :: y An M-element array containing the results from the M experiments. logical, intent(in), optional, target, dimension(:) :: map An optional array of the same size as beta that can be used to\neliminate a parameter from the model (false), or keep a parameter\nin the model (true).  If not supplied, all parameters will be assumed\nto be part of the model as if the array were filled with all true\nvalues. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and y are not properly sized\n     relative to one another.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error.\n- FS_INVALID_ARGUMENT_ERROR: Occurs if nway is out of range, or if\n     map is used to \"turn off\" all model parameters. Return Value type( doe_model ) The resulting model. Subroutines public  subroutine full_factorial (vars, tbl, err) Computes a table with values scaled from 1 to N describing a \nfull-factorial design. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vars (:) An M-element array containing the M factors to study. Each of the M entries to the array is expected to contain \nthe number of options for that particular factor to explore. \nThis value must be greater than or equal to 1. integer(kind=int32), intent(out) :: tbl (:,:) A table where the design will be written.  Use \nget_full_factorial_matrix_size to determine the appropriate \ntable size. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_INVALID_INPUT_ERROR: Occurs if any items in vars are \n     less than 1.\n- FS_ARRAY_SIZE_ERROR: Occurs if tbl is not properly sized. public  subroutine get_full_factorial_matrix_size (vars, m, n, err) Computes the appropriate size for a full-factorial design table. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vars (:) An M-element array containing the M factors to study.  Each \nof the M entries to the array is expected to contain the \nnumber of options for that particular factor to explore. This value must be greater than or equal to 1. integer(kind=int32), intent(out) :: m The number of rows for the table. integer(kind=int32), intent(out) :: n The number of columns for the table. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_INVALID_INPUT_ERROR: Occurs if any items in vars are \n     less than 1.","tags":"","loc":"module\\fstats_experimental_design.html"},{"title":"fstats_helper_routines – FSTATS","text":"Uses iso_fortran_env Contents Functions difference factorial Functions public pure function difference (x) result(rst) Computes the difference between elements in an array. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The N-element array on which to operate. Return Value real(kind=real64), allocatable, dimension(:) The (N-1)-element array containing the differences between adjacent\nelements. public pure elemental function factorial (x) result(rst) Computes the factorial of X. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The value whose factorial is to be computed. Return Value real(kind=real64) The result.","tags":"","loc":"module\\fstats_helper_routines.html"},{"title":"fstats_hypothesis – FSTATS","text":"Uses ieee_arithmetic fstats_special_functions iso_fortran_env fstats_errors fstats_types fstats_distributions fstats_descriptive_statistics Contents Interfaces confidence_interval Functions sample_size Subroutines bartletts_test f_test levenes_test t_test_equal_variance t_test_paired t_test_unequal_variance Interfaces public        interface confidence_interval Computes the confidence interval for the specified distribution. See Also Wikipedia private pure function confidence_interval_scalar(dist, alpha, s, n) result(rst) Computes the confidence interval for the specified distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution object defining the probability distribution\nto establish the confidence level. real(kind=real64), intent(in) :: alpha The probability value of interest.  For instance, use a value of 0.05\nfor a confidence level of 95%. real(kind=real64), intent(in) :: s The sample standard deviation. integer(kind=int32), intent(in) :: n The number of samples in the data set. Return Value real(kind=real64) The result. private pure function confidence_interval_array(dist, alpha, x) result(rst) Computes the confidence interval for the specified distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution object defining the probability distribution\nto establish the confidence level. real(kind=real64), intent(in) :: alpha The probability value of interest.  For instance, use a value of 0.05\nfor a confidence level of 95%. real(kind=real64), intent(in) :: x (:) An N-element array containing the data to analyze. Return Value real(kind=real64) The result. Functions public pure function sample_size (dist, var, delta, bet, alpha) result(rst) Estimates the sample size required to achieve an experiment with the\ndesired power and significance levels to ascertain the desired \ndifference in parameter. Read more… Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: dist The distribution to utilize as a measure. real(kind=real64), intent(in) :: var An estimate of the population variance. real(kind=real64), intent(in) :: delta The parameter difference that is desired. real(kind=real64), intent(in), optional :: bet The desired power level.  The default for this value is 0.2, for a \npower of 80%. real(kind=real64), intent(in), optional :: alpha The desired significance level.  The default for this value is 0.05\nfor a confidence level of 95%. Return Value real(kind=real64) The minimum sample size requried to achieve the desired experimental\noutcome. Subroutines public  subroutine bartletts_test (x, stat, p) Computes Bartlett's test statistic and associated probability. Read more… Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x The arrays of data to analyze. real(kind=real64), intent(out) :: stat The Bartlett's test statistic. real(kind=real64), intent(out) :: p The probability value that the variances of each data set are\nequivalent.  A low p-value, less than some significance level,\nindicates a non-equivalance of variances. public  subroutine f_test (x1, x2, stat, p, dof1, dof2) Computes the F-test and returns the probability (two-tailed) that\nthe variances of two data sets are not significantly different. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The F-statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from the two underlying populations that \nhave the same variance. real(kind=real64), intent(out) :: dof1 A measure of the degrees of freedom. real(kind=real64), intent(out) :: dof2 A measure of the degrees of freedom. public  subroutine levenes_test (x, stat, p, err) Computes Levene's test statistic and associated probability. Read more… Arguments Type Intent Optional Attributes Name type( array_container ), intent(in), dimension(:) :: x The arrays of data to analyze. real(kind=real64), intent(out) :: stat The Bartlett's test statistic. real(kind=real64), intent(out) :: p The probability value that the variances of each data set are\nequivalent.  A low p-value, less than some significance level,\nindicates a non-equivalance of variances. class(errors), intent(inout), optional, target :: err public  subroutine t_test_equal_variance (x1, x2, stat, p, dof) Computes the 2-tailed Student's T-Test for two data sets of \nassumed equivalent variances. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom. public  subroutine t_test_paired (x1, x2, stat, p, dof, err) Computes the 2-tailed Student's T-Test for two paired data sets. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An N-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from  two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x1 and x2 are not the same \n  length. public  subroutine t_test_unequal_variance (x1, x2, stat, p, dof) Computes the 2-tailed Student's T-Test for two data sets of \nassumed non-equivalent variances. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 (:) An N-element array containing the first data set. real(kind=real64), intent(in) :: x2 (:) An M-element array containing the second data set. real(kind=real64), intent(out) :: stat The Student-'s T-Test statistic. real(kind=real64), intent(out) :: p The probability value that the two samples are likely to\nhave come from two underlying populations that \nhave the same mean. real(kind=real64), intent(out) :: dof The degrees of freedom.","tags":"","loc":"module\\fstats_hypothesis.html"},{"title":"fstats_mcmc – FSTATS","text":"Uses ferror iso_fortran_env fstats_regression fstats_errors fstats_sampling fstats_types fstats_distributions fstats_descriptive_statistics Contents Derived Types metropolis_hastings Derived Types type, public :: metropolis_hastings An implementation of the Metropolis-Hastings algorithm for the\ngeneration of a Markov chain.  This is a default implementation\nthat allows sampling of normally distributed posterior distributions\ncentered on zero with unit standard deviations.  Proposals are\ngenerated from a multivariate normal distribution with an identity\ncovariance matrix and centered on zero.  To alter these sampling\nand target distributions simply create a new class inheriting from \nthis class and override the appropriate routines. Type-Bound Procedures procedure\n                    ,                  public\n                  :: compute_hastings_ratio =>\n                    mh_hastings_ratio Function procedure\n                    ,                  public\n                  :: evaluate_proposal_pdf =>\n                    mh_eval_proposal Function procedure\n                    ,                  public\n                  :: generate_proposal =>\n                    mh_proposal Function procedure\n                    ,                  public\n                  :: get_accepted_count =>\n                    mh_get_num_accepted Function procedure\n                    ,                  public\n                  :: get_chain =>\n                    mh_get_chain Function procedure\n                    ,                  public\n                  :: get_chain_length =>\n                    mh_get_chain_length Function procedure\n                    ,                  public\n                  :: get_proposal_cholesky =>\n                    mh_get_prop_chol_cov Function procedure\n                    ,                  public\n                  :: get_proposal_covariance =>\n                    mh_get_prop_cov Function procedure\n                    ,                  public\n                  :: get_proposal_initialized =>\n                    mh_get_is_prop_init Function procedure\n                    ,                  public\n                  :: get_proposal_means =>\n                    mh_get_prop_mean Function procedure\n                    ,                  public\n                  :: get_state_variable_count =>\n                    mh_get_nvars Function generic,\n                  public\n                  :: initialize_proposal =>\n                    mh_init_proposal_1, mh_init_proposal_2 procedure\n                    ,                  public\n                  :: on_acceptance =>\n                    mh_on_success Subroutine procedure\n                    ,                  public\n                  :: on_rejection =>\n                    mh_on_rejection Subroutine procedure\n                    ,                  public\n                  :: push_new_state =>\n                    mh_push Subroutine procedure\n                    ,                  public\n                  :: reset =>\n                    mh_clear_chain Subroutine procedure\n                    ,                  public\n                  :: sample =>\n                    mh_sample Subroutine procedure\n                    ,                  public\n                  :: set_proposal_covariance =>\n                    mh_set_prop_cov Subroutine procedure\n                    ,                  public\n                  :: set_proposal_means =>\n                    mh_set_prop_mean Subroutine procedure\n                    ,                  public\n                  :: target_distribution =>\n                    mh_target Function","tags":"","loc":"module\\fstats_mcmc.html"},{"title":"fstats_mcmc_fitting – FSTATS","text":"Uses ieee_arithmetic ferror iso_fortran_env fstats_regression fstats_errors fstats_sampling fstats_distributions fstats_descriptive_statistics fstats_mcmc Contents Derived Types mcmc_regression Derived Types type, public, extends( metropolis_hastings ) :: mcmc_regression The mcmc_regression type extends the metropolis_hastings type to\nspecifically target regression problems.  The problem is formulated\nsuch that the target distribution takes the form , where is a normal\ndistribution with as the mean and the model variance, is determined by computing the variance for the current\nestimate of the model. Components Type Visibility Attributes Name Initial procedure( regression_function ), public, pointer, nopass :: fcn The function to fit. real(kind=real64), public, allocatable, dimension(:) :: lower_limits An optional array that, if used, provides a lower limit to\neach parameter in the model.  If used, be sure this array is the\nsame dimension as the parameter array.  If not used, leave this\nalone and no lower limits will be placed on the parameters.\nIf used and the array is not sized correctly, it will be ignored. real(kind=real64), public, allocatable, dimension(:) :: upper_limits An optional array that, if used, provides an upper limit to\neach parameter in the model.  If used, be sure this array is the\nsame dimension as the parameter array.  If not used, leave this\nalone and no upper limits will be placed on the parameters.\nIf used and the array is not sized correctly, it will be ignored. real(kind=real64), public, allocatable, dimension(:) :: x The independent-variable data to fit. real(kind=real64), public, allocatable, dimension(:) :: y The dependent-variable data to fit. Type-Bound Procedures procedure\n                    ,                  public\n                  :: compute_fit_statistics =>\n                    mr_calc_regression_stats Function procedure\n                    ,                  public\n                  :: compute_hastings_ratio =>\n                    mh_hastings_ratio Function procedure\n                    ,                  public\n                  :: covariance_matrix =>\n                    mr_covariance Function procedure\n                    ,                  public\n                  :: evaluate_proposal_pdf =>\n                    mh_eval_proposal Function procedure\n                    ,                  public\n                  :: generate_proposal =>\n                    mr_proposal Function procedure\n                    ,                  public\n                  :: get_accepted_count =>\n                    mh_get_num_accepted Function procedure\n                    ,                  public\n                  :: get_chain =>\n                    mh_get_chain Function procedure\n                    ,                  public\n                  :: get_chain_length =>\n                    mh_get_chain_length Function procedure\n                    ,                  public\n                  :: get_data_variance =>\n                    mr_get_data_variance Function procedure\n                    ,                  public\n                  :: get_proposal_cholesky =>\n                    mh_get_prop_chol_cov Function procedure\n                    ,                  public\n                  :: get_proposal_covariance =>\n                    mh_get_prop_cov Function procedure\n                    ,                  public\n                  :: get_proposal_initialized =>\n                    mh_get_is_prop_init Function procedure\n                    ,                  public\n                  :: get_proposal_means =>\n                    mh_get_prop_mean Function procedure\n                    ,                  public\n                  :: get_state_variable_count =>\n                    mh_get_nvars Function generic,\n                  public\n                  :: initialize_proposal =>\n                    mh_init_proposal_1, mh_init_proposal_2 procedure\n                    ,                  public\n                  :: likelihood =>\n                    mr_likelihood Function procedure\n                    ,                  public\n                  :: on_acceptance =>\n                    mr_on_success Subroutine procedure\n                    ,                  public\n                  :: on_rejection =>\n                    mh_on_rejection Subroutine procedure\n                    ,                  public\n                  :: push_new_state =>\n                    mr_push Subroutine procedure\n                    ,                  public\n                  :: reset =>\n                    mh_clear_chain Subroutine procedure\n                    ,                  public\n                  :: sample =>\n                    mh_sample Subroutine procedure\n                    ,                  public\n                  :: set_data_variance =>\n                    mr_set_data_variance Subroutine procedure\n                    ,                  public\n                  :: set_proposal_covariance =>\n                    mh_set_prop_cov Subroutine procedure\n                    ,                  public\n                  :: set_proposal_means =>\n                    mh_set_prop_mean Subroutine procedure\n                    ,                  public\n                  :: target_distribution =>\n                    mr_target Function","tags":"","loc":"module\\fstats_mcmc_fitting.html"},{"title":"fstats_regression – FSTATS","text":"Uses fstats_special_functions linalg ferror iso_fortran_env blas fstats_errors fstats_distributions fstats_descriptive_statistics fstats_hypothesis Contents Variables FS_LEVENBERG_MARQUARDT_UPDATE FS_NIELSEN_UPDATE FS_QUADRATIC_UPDATE Interfaces iteration_update regression_function Derived Types convergence_info iteration_controls lm_solver_options regression_statistics Functions adjusted_r_squared calculate_regression_statistics correlation r_squared Subroutines covariance_matrix design_matrix jacobian linear_least_squares nonlinear_least_squares Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: FS_LEVENBERG_MARQUARDT_UPDATE = 1 integer(kind=int32), public, parameter :: FS_NIELSEN_UPDATE = 3 integer(kind=int32), public, parameter :: FS_QUADRATIC_UPDATE = 2 Interfaces interface public  subroutine iteration_update(iter, funvals, resid, params, step) Defines a routine for providing updates about an iteration\nprocess. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: iter The current iteration number. real(kind=real64), intent(in), dimension(:) :: funvals The function values. real(kind=real64), intent(in), dimension(:) :: resid The residuals. real(kind=real64), intent(in), dimension(:) :: params The model parameters. real(kind=real64), intent(in), dimension(:) :: step Step sizes for each parameter. interface public  subroutine regression_function(xdata, params, f, stop) Defines the interface of a subroutine computing the function\nvalues at each of the N data points as part of a regression\nanalysis. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xdata An N-element array containing the N independent data points. real(kind=real64), intent(in), dimension(:) :: params An M-element array containing the M model parameters. real(kind=real64), intent(out), dimension(:) :: f An N-element array where the results of the N function \nevaluations will be written. logical, intent(out) :: stop A mechanism to force a stop to the iteration process.  If\nset to true, the iteration process will terminate.  If set\nto false, the iteration process will continue along as \nnormal. Derived Types type, public :: convergence_info Provides information regarding convergence status. Components Type Visibility Attributes Name Initial logical, public :: converge_on_gradient True if convergence on the gradient was achieved; else, false. logical, public :: converge_on_residual_parameter True if convergence on the residual error parameter was achieved; \nelse, false. logical, public :: converge_on_solution_change True if convergence on the change in solution was achieved; else,\nfalse. integer(kind=int32), public :: function_evaluation_count The function evaluation count. real(kind=real64), public :: gradient_value The value of the gradient test parameter. integer(kind=int32), public :: iteration_count The iteration count. logical, public :: reach_function_evaluation_limit True if the solution did not converge in the allowed number of\nfunction evaluations. logical, public :: reach_iteration_limit True if the solution did not converge in the allowed number of \niterations. real(kind=real64), public :: residual_value The value of the residual error parameter. real(kind=real64), public :: solution_change_value The value of the change in solution parameter. logical, public :: user_requested_stop True if the user requested the stop; else, false. type, public :: iteration_controls Provides a collection of iteration control parameters. Components Type Visibility Attributes Name Initial real(kind=real64), public :: change_in_solution_tolerance Defines a tolerance on the change in parameter values. real(kind=real64), public :: gradient_tolerance Defines a tolerance on the gradient of the fitted function. real(kind=real64), public :: iteration_improvement_tolerance Defines a tolerance to ensure adequate improvement on each \niteration. integer(kind=int32), public :: max_function_evaluations Defines the maximum number of function evaluations allowed. integer(kind=int32), public :: max_iteration_between_updates Defines how many iterations can pass before a re-evaluation of \nthe Jacobian matrix is forced. integer(kind=int32), public :: max_iteration_count Defines the maximum number of iterations allowed. real(kind=real64), public :: residual_tolerance Defines a tolerance on the metric associated with the residual \nerror. Type-Bound Procedures procedure\n                    ,                  public\n                  :: set_to_default =>\n                    lm_set_default_tolerances Subroutine type, public :: lm_solver_options Options to control the Levenberg-Marquardt solver. Components Type Visibility Attributes Name Initial real(kind=real64), public :: damping_decrease_factor The factor to use when decreasing the damping parameter. real(kind=real64), public :: damping_increase_factor The factor to use when increasing the damping parameter. real(kind=real64), public :: finite_difference_step_size The step size used for the finite difference calculations of the\nJacobian matrix. integer(kind=int32), public :: method The solver method to utilize.\n- FS_LEVENBERG_MARQUARDT_UPDATE:\n- FS_QUADRATIC_UPDATE:\n- FS_NIELSEN_UDPATE: Type-Bound Procedures procedure\n                    ,                  public\n                  :: set_to_default =>\n                    lm_set_default_settings Subroutine type, public :: regression_statistics A container for regression-related statistical information. Components Type Visibility Attributes Name Initial real(kind=real64), public :: confidence_interval The confidence interval for the parameter at the level \ndetermined by the regression process. Read more… real(kind=real64), public :: probability The probability that the coefficient is not statistically \nimportant.  A statistically important coefficient will have a \nlow probability (p-value), typically 0.05 or lower; however, a \np-value of up to ~0.2 may be acceptable dependent upon the \nproblem.  Typically any p-value larger than ~0.2 indicates the \nparameter is not statistically important for the model. Read more… real(kind=real64), public :: standard_error The standard error for the model coefficient. Read more… real(kind=real64), public :: t_statistic The T-statistic for the model coefficient. Read more… Functions public  function adjusted_r_squared (p, x, xm, err) result(rst) Computes the adjusted R-squared value for a data set. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: p The number of variables. real(kind=real64), intent(in) :: x (:) An N-element array containing the dependent variables from \nthe data set. real(kind=real64), intent(in) :: xm (:) An N-element array containing the corresponding modeled \nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings\nto the caller.  Possible warning and error codes are as \nfollows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the \n  same size. Return Value real(kind=real64) The result. public  function calculate_regression_statistics (resid, params, c, alpha, err) result(rst) Computes statistics for the quality of fit for a regression \nmodel. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: resid (:) An M-element array containing the model residual errors. real(kind=real64), intent(in) :: params (:) An N-element array containing the model parameters. real(kind=real64), intent(in) :: c (:,:) The N-by-N covariance matrix. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if c is not sized correctly.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. Return Value type( regression_statistics ), allocatable, (:) A regression_statistics object containing the analysis results. public pure function correlation (x, y) result(rst) Computes the sample correlation coefficient (an estimate to the \npopulation Pearson correlation) as follows. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The first N-element data set. real(kind=real64), intent(in), dimension(size(x)) :: y The second N-element data set. Return Value real(kind=real64) The correlation coefficient. public  function r_squared (x, xm, err) result(rst) Computes the R-squared value for a data set. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:) An N-element array containing the dependent variables from \nthe data set. real(kind=real64), intent(in) :: xm (:) An N-element array containing the corresponding modeled \nvalues. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings\nto the caller.  Possible warning and error codes are as \nfollows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the \n  same size. Return Value real(kind=real64) The result. Subroutines public  subroutine covariance_matrix (x, c, err) Computes the covariance matrix where and is computed\nby design_matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (:,:) An M-by-N matrix containing the formatted independent data\n matrix as computed by design_matrix. real(kind=real64), intent(out) :: c (:,:) The N-by-N covariance matrix. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the matrices are not \n     sized correctly.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. public  subroutine design_matrix (order, intercept, x, c, err) Computes the design matrix for the linear \nleast-squares regression problem of , where is the matrix computed here, is \nthe vector of coefficients to be determined, and is the \nvector of measured dependent variables. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: order The order of the equation to fit.  This value must be\nat least one (linear equation), but can be higher as desired. logical, intent(in) :: intercept Set to true if the intercept is being computed\nas part of the regression; else, false. real(kind=real64), intent(in) :: x (:) An N-element array containing the independent variable\nmeasurement points. real(kind=real64), intent(out) :: c (:,:) An N-by-K matrix where the results will be written.  K\nmust equal order + 1 in the event intercept is true; \nhowever, if intercept is false, K must equal order. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if c is not properly sized.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. public  subroutine jacobian (fun, xdata, params, jac, stop, f0, f1, step, err) Computes the Jacobian matrix for a nonlinear regression problem. Arguments Type Intent Optional Attributes Name procedure( regression_function ), intent(in), pointer :: fun A pointer to the regression_function to evaluate. real(kind=real64), intent(in) :: xdata (:) The M-element array containing x-coordinate data. real(kind=real64), intent(in) :: params (:) The N-element array containing the model parameters. real(kind=real64), intent(out) :: jac (:,:) The M-by-N matrix where the Jacobian will be written. logical, intent(out) :: stop A value that the user can set in fun forcing the\nevaluation process to stop prior to completion. real(kind=real64), intent(in), optional, target :: f0 (:) An optional M-element array containing the model values\n using the current parameters as defined in m.  This input \ncan be used to prevent the routine from performing a \nfunction evaluation at the model parameter state defined in \nparams. real(kind=real64), intent(out), optional, target :: f1 (:) An optional M-element workspace array used for function\nevaluations. real(kind=real64), intent(in), optional :: step The differentiation step size.  The default is the square \nroot of machine precision. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     properly sized.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. public  subroutine linear_least_squares (order, intercept, x, y, coeffs, ymod, resid, stats, alpha, err) Computes a linear least-squares regression to fit a set of data. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: order The order of the equation to fit.  This value must be at \nleast one (linear equation), but can be higher as desired, \nas long as there is sufficient data. logical, intent(in) :: intercept Set to true if the intercept is being computed as part of \nthe regression; else, false. real(kind=real64), intent(in) :: x (:) An N-element array containing the independent variable\nmeasurement points. real(kind=real64), intent(in) :: y (:) An N-element array containing the dependent variable\nmeasurement points. real(kind=real64), intent(out) :: coeffs (:) An ORDER+1 element array where the coefficients will be written. real(kind=real64), intent(out) :: ymod (:) An N-element array where the modeled data will be written. real(kind=real64), intent(out) :: resid (:) An N-element array where the residual error data will be \nwritten (modeled - actual). type( regression_statistics ), intent(out), optional :: stats (:) An M-element array of regression_statistics items where \nM = ORDER + 1 when intercept is set to true; however, if \nintercept is set to false, M = ORDER. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     approriately sized.\n- FS_INVALID_INPUT_ERROR: Occurs if order is less than 1.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation \n     error. public  subroutine nonlinear_least_squares (fun, x, y, params, ymod, resid, weights, maxp, minp, stats, alpha, controls, settings, info, status, cov, err) Performs a nonlinear regression to fit a model using a version\nof the Levenberg-Marquardt algorithm. Arguments Type Intent Optional Attributes Name procedure( regression_function ), intent(in), pointer :: fun A pointer to the regression_function to evaluate. real(kind=real64), intent(in) :: x (:) The M-element array containing independent data. real(kind=real64), intent(in) :: y (:) The M-element array containing dependent data. real(kind=real64), intent(inout) :: params (:) On input, the N-element array containing the initial estimate\nof the model parameters.  On output, the computed model \nparameters. real(kind=real64), intent(out) :: ymod (:) An M-element array where the modeled dependent data will\nbe written. real(kind=real64), intent(out) :: resid (:) An M-element array where the model residuals will be\nwritten. real(kind=real64), intent(in), optional, target :: weights (:) An optional M-element array allowing the weighting of\nindividual points. real(kind=real64), intent(in), optional, target :: maxp (:) An optional N-element array that can be used as upper limits \non the parameter values.  If no upper limit is requested for\na particular parameter, utilize a very large value.  The \ninternal default is to utilize huge() as a value. real(kind=real64), intent(in), optional, target :: minp (:) An optional N-element array that can be used as lower limits \non the parameter values.  If no lower limit is requested for\na particalar parameter, utilize a very large magnitude, but \nnegative, value.  The internal default is to utilize -huge() \nas a value. type( regression_statistics ), intent(out), optional :: stats (:) An optional N-element array that, if supplied, will be used \nto return statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals.  The default value is 0.05 such that a 95% \nconfidence interval is calculated. type( iteration_controls ), intent(in), optional :: controls An optional input providing custom iteration controls. type( lm_solver_options ), intent(in), optional :: settings An optional input providing custom settings for the solver. type( convergence_info ), intent(out), optional, target :: info An optional output that can be used to gain information about\nthe iterative solution and the nature of the convergence. procedure( iteration_update ), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract\niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return\nthe covariance matrix. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows. Read more…","tags":"","loc":"module\\fstats_regression.html"},{"title":"fstats_sampling – FSTATS","text":"Uses iso_fortran_env linalg fstats_distributions Contents Interfaces box_muller_sample Functions rejection_sample sample_normal_multivariate Interfaces public        interface box_muller_sample Generates random, normally distributed values via the Box-Muller \ntransform. private  function box_muller_sample_scalar(mu, sigma) result(rst) Generates a pair of independent, standard, normally distributed\nrandom values using the Box-Muller transform. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: mu The mean of the distribution. real(kind=real64), intent(in) :: sigma The standard deviation of the distribution. Return Value real(kind=real64), (2) The pair of random values. private  function box_muller_array(mu, sigma, n) result(rst) Generates an array of normally distributed random values sampled\nby the Box-Muller transform. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: mu The mean of the distribution. real(kind=real64), intent(in) :: sigma The standard deviation of the distribution. integer(kind=int32), intent(in) :: n The number of Box-Muller pairs to generate. Return Value real(kind=real64), allocatable, dimension(:) A 2N-element array containing the N Box-Muller pairs. Functions public  function rejection_sample (tdist, n, xmin, xmax) result(rst) Uses rejection sampling to randomly sample a target distribution. Arguments Type Intent Optional Attributes Name class( distribution ), intent(in) :: tdist The distribution to sample integer(kind=int32), intent(in) :: n The number of samples to make. real(kind=real64), intent(in) :: xmin The minimum range to explore. real(kind=real64), intent(in) :: xmax The maximum range to explore. Return Value real(kind=real64), allocatable, dimension(:) An N-element array containing the N samples from the \ndistribution. public  function sample_normal_multivariate (dist) result(rst) Samples a multivariate normal distribution such that , where is the lower form of the Cholesky \nfactorization of the covariance matrix, and is a randomly \ngenerated vector that exists on the set Arguments Type Intent Optional Attributes Name class( multivariate_normal_distribution ), intent(in) :: dist The multivariate normal distribution to sample. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector.","tags":"","loc":"module\\fstats_sampling.html"},{"title":"fstats_smoothing – FSTATS","text":"Uses iso_fortran_env fstats_errors linalg ferror Contents Subroutines lowess Subroutines public  subroutine lowess (x, y, ys, fsmooth, nstps, del, rweights, resid, err) Computes the smoothing of a data set using a robust locally weighted\nscatterplot smoothing (LOWESS) algorithm.  Fitted values are computed at\neach of the supplied x values. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the independent variable data.  This\narray must be monotonically increasing. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the dependent variable data. real(kind=real64), intent(out), dimension(:) :: ys An N-element array where the smoothed results will be written. real(kind=real64), intent(in), optional :: fsmooth An optional input that specifies the amount of smoothing. Specifically, this value is the fraction of points used to compute\neach value.  As this value increases, the output becomes smoother.\nChoosing a value in the range of 0.2 to 0.8 typically results in a\ngood fit.  The default value is 0.2. integer(kind=int32), intent(in), optional :: nstps An optional input that specifies the numb of iterations.  If set to\nzero, a non-robust fit is returned.  The default value is set to 2. real(kind=real64), intent(in), optional :: del real(kind=real64), intent(out), optional, dimension(:), target :: rweights An optional N-element array, that if supplied, will be used to\nreturn the weights given to each data point. real(kind=real64), intent(out), optional, dimension(:), target :: resid An optional N-element array, that if supplied, will be used to \nreturn the residual. class(errors), intent(inout), optional, target :: err A mechanism for communicating errors and warnings to the \ncaller.  Possible warning and error codes are as follows.\n- FS_NO_ERROR: No errors encountered.\n- FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not \n     approriately sized.\n- FS_MEMORY_ERROR: Occurs if there is a memory allocation error.","tags":"","loc":"module\\fstats_smoothing.html"},{"title":"fstats_special_functions – FSTATS","text":"Uses iso_fortran_env ieee_arithmetic Contents Functions beta digamma incomplete_beta incomplete_gamma_lower incomplete_gamma_upper regularized_beta Functions public pure elemental function beta (a, b) result(rst) Computes the beta function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. Return Value real(kind=real64) The value of the beta function at and . public pure elemental function digamma (x) result(rst) Computes the digamma function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. public pure elemental function incomplete_beta (a, b, x) result(rst) Computes the incomplete beta function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. real(kind=real64), intent(in) :: x The upper limit of the integration. Return Value real(kind=real64) The value of the incomplete beta function. public pure elemental function incomplete_gamma_lower (a, x) result(rst) Computes the lower incomplete gamma function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The coefficient value. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. public pure elemental function incomplete_gamma_upper (a, x) result(rst) Computes the upper incomplete gamma function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The coefficient value. real(kind=real64), intent(in) :: x The value at which to evaluate the function. Return Value real(kind=real64) The function value. public pure elemental function regularized_beta (a, b, x) result(rst) Computes the regularized beta function. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The first argument of the function. real(kind=real64), intent(in) :: b The second argument of the function. real(kind=real64), intent(in) :: x The upper limit of the integration. Return Value real(kind=real64) The value of the regularized beta function.","tags":"","loc":"module\\fstats_special_functions.html"},{"title":"fstats_types – FSTATS","text":"Uses iso_fortran_env Contents Derived Types array_container Derived Types type, public :: array_container Provides a container for a real-valued array.  A practical use of\nthis construct is in the construction of jagged arrays. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: x The array.","tags":"","loc":"module\\fstats_types.html"},{"title":"fstats.f90 – FSTATS","text":"Contents Modules fstats Source Code fstats.f90 Source Code module fstats !! FSTATS is a modern Fortran statistical library containing routines for !! computing basic statistical properties, hypothesis testing, regression, !! special functions, and experimental design. use iso_fortran_env use fstats_special_functions use fstats_descriptive_statistics use fstats_hypothesis use fstats_distributions use fstats_anova use fstats_helper_routines use fstats_regression use fstats_experimental_design use fstats_allan use fstats_bootstrap use fstats_sampling use fstats_smoothing use fstats_mcmc use fstats_mcmc_fitting implicit none private ! FSTATS_DISTRIBUTION.F90 public :: distribution public :: distribution_function public :: distribution_property public :: t_distribution public :: normal_distribution public :: f_distribution public :: chi_squared_distribution public :: binomial_distribution public :: multivariate_distribution public :: multivariate_distribution_function public :: multivariate_normal_distribution public :: log_normal_distribution public :: mean public :: variance public :: standard_deviation public :: median public :: covariance public :: r_squared public :: adjusted_r_squared public :: correlation public :: quantile public :: t_test_equal_variance public :: t_test_unequal_variance public :: t_test_paired public :: f_test public :: anova public :: anova_factor public :: single_factor_anova_table public :: two_factor_anova_table public :: confidence_interval public :: beta public :: regularized_beta public :: incomplete_beta public :: digamma public :: incomplete_gamma_upper public :: incomplete_gamma_lower public :: design_matrix public :: covariance_matrix public :: linear_least_squares public :: regression_statistics public :: get_full_factorial_matrix_size public :: full_factorial public :: iteration_controls public :: lm_solver_options public :: convergence_info public :: regression_function public :: iteration_update public :: jacobian public :: nonlinear_least_squares public :: allan_variance public :: trimmed_mean public :: difference public :: factorial public :: bootstrap_resampling_routine public :: bootstrap_statistic_routine public :: random_resample public :: scaled_random_resample public :: bootstrap_statistics public :: bootstrap public :: lowess public :: pooled_variance public :: bartletts_test public :: levenes_test public :: sample_size public :: FS_LEVENBERG_MARQUARDT_UPDATE public :: FS_QUADRATIC_UPDATE public :: FS_NIELSEN_UPDATE public :: doe_fit_model public :: doe_evaluate_model public :: doe_model ! FSTATS_SAMPLING.F90 public :: box_muller_sample public :: rejection_sample public :: sample_normal_multivariate ! FSTATS_MCMC.F90 public :: metropolis_hastings ! FSTATS_MCMC_FITTING.F90 public :: mcmc_regression end module","tags":"","loc":"sourcefile\\fstats.f90.html"},{"title":"fstats_allan.f90 – FSTATS","text":"Contents Modules fstats_allan Source Code fstats_allan.f90 Source Code module fstats_allan use iso_fortran_env use fstats_errors implicit none private public :: allan_variance contains ! ------------------------------------------------------------------------------ ! REF: Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, ! Viraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm for ! Fully Overlapped Allan Variance and Total Variance for Analysis and Modeling ! of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. ! 10.1109/LSENS.2018.2829799. ! ! https://www.researchgate.net/publication/324738301_A_Fast_Parallel_Algorithm_for_Fully_Overlapped_Allan_Variance_and_Total_Variance_for_Analysis_and_Modeling_of_Noise_in_Inertial_Sensors ! https://github.com/shrikanth95/Fast-Parallel-Fully-Overlapped-Allan-Variance-and-Total-Variance/blob/master/fast_FOAV.m function allan_variance ( x , dt , err ) result ( rst ) !! Computes the Allan variance of a data set. !! !! Remarks !! !! This implementation computes the fully overlapped Allan variance !! using the method presented by Yadav et. al. !! !! Yadav, Shrikanth & Shastri, Saurav & Chakravarthi, Ghanashyam & Kumar, !! Viraj & Rao, Divya & Agrawal, Vinod. (2018). A Fast, Parallel Algorithm !! for Fully Overlapped Allan Variance and Total Variance for Analysis and !! Modeling of Noise in Inertial Sensors. IEEE Sensors Letters. PP. 1-1. !! 10.1109/LSENS.2018.2829799. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element data set to analyze. real ( real64 ), intent ( in ), optional :: dt !! An optional input specifying the time increment between !! samples in x.  If not specified, this value is set to 1. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. real ( real64 ), allocatable , dimension (:,:) :: rst !! An M-by-2 array containing the results where M is N / 2 - 1 !! if N is even; else, M is (N - 1) / 2 - 1 if N is odd.  The !! first column contains the averaging times associated with !! the M results stored in the second column. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: flag , j , m , n , limit , nr real ( real64 ), allocatable , dimension (:) :: tall1 , tall2 real ( real64 ) :: temp , deltaT ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( dt )) then deltaT = dt else deltaT = 1.0d0 end if ! Initialization n = size ( x ) limit = n nr = floor ( 0.5 * n ) - 1 allocate ( tall1 ( n - 1 ), source = x (: n - 1 ), stat = flag ) if ( flag == 0 ) allocate ( tall2 ( n - 1 ), source = x ( 2 : n )) if ( flag == 0 ) allocate ( rst ( nr , 2 ), source = 0.0d0 ) if ( flag /= 0 ) go to 10 ! Process do m = 1 , nr temp = 0.0d0 do j = 1 , limit - 1 temp = temp + ( tall2 ( j ) - tall1 ( j )) ** 2 tall1 ( j ) = tall1 ( j ) + x ( min ( n , m + j )) tall2 ( j ) = tall2 ( min ( n - 1 , j + 1 )) + x ( min ( n , 2 * m + j + 1 )) end do limit = limit - 2 rst ( m , 1 ) = dt * m rst ( m , 2 ) = temp / ( 2.0d0 * ( n - 2 * m + 1 ) * m ** 2 ) end do ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"allan_variance\" , flag ) return end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_allan.f90.html"},{"title":"fstats_anova.f90 – FSTATS","text":"Contents Modules fstats_anova Source Code fstats_anova.f90 Source Code module fstats_anova use iso_fortran_env use ieee_arithmetic use fstats_special_functions use fstats_descriptive_statistics use ferror use fstats_errors use fstats_distributions implicit none private public :: anova_factor public :: single_factor_anova_table public :: two_factor_anova_table public :: anova type anova_factor !! Defines an ANOVA factor result. real ( real64 ) :: dof !! The number of degrees of freedome. real ( real64 ) :: variance !! The estimate of variance. real ( real64 ) :: sum_of_squares !! The sum of the squares. real ( real64 ) :: f_statistic !! The F-statistic. real ( real64 ) :: probability !! The variance probability term. end type type single_factor_anova_table !! Defines a single-factor ANOVA results table. type ( anova_factor ) :: main_factor !! The main, or main factor, results. type ( anova_factor ) :: within_factor !! The within-treatement (error) results. real ( real64 ) :: total_dof !! The total number of degrees of freedom. real ( real64 ) :: total_sum_of_squares !! The total sum of squares. real ( real64 ) :: total_variance !! The total variance estimate. real ( real64 ) :: overall_mean !! The overall mean value. end type type two_factor_anova_table !! Defines a two-factor ANOVA results table. type ( anova_factor ) :: main_factor_1 !! The first main-factor results. type ( anova_factor ) :: main_factor_2 !! The second main-factor results. type ( anova_factor ) :: interaction !! The interaction effects. type ( anova_factor ) :: within_factor !! The within (error) factor results. real ( real64 ) :: total_dof !! The total number of degrees of freedom. real ( real64 ) :: total_sum_of_squares !! The total sum of squares. real ( real64 ) :: total_variance !! The total variance estimate. real ( real64 ) :: overall_mean !! The overall mean value. end type interface anova !! Performs an analysis of variance (ANOVA) on the supplied data !! set. !! !! The following example illustrates a single-factor ANOVA on a !! data set. !! ```fortran !! program example !!     use iso_fortran_env !!     use fstats !!     implicit none !! !!     ! Local Variables !!     character, parameter :: tab = achar(9) !!     real(real64) :: x(10, 2) !!     type(single_factor_anova_table) :: tbl !! !!     ! Define the data !!     x = reshape( & !!         [ & !!             3.086d3, 3.082d3, 3.069d3, 3.072d3, 3.045d3, 3.070d3, 3.079d3, & !!             3.050d3, 3.062d3, 3.062d3, 3.075d3, 3.061d3, 3.063d3, 3.038d3, & !!             3.070d3, 3.062d3, 3.070d3, 3.049d3, 3.042d3, 3.063d3 & !!         ], & !!         [10, 2] & !!     ) !! !!     ! Perform the ANOVA !!     tbl = anova(x) !! !!     ! Print out the table !!     print '(A)', \"Description\" // tab // \"DOF\" // tab // \"Sum of Sq.\" // & !!         tab // \"Variance\" // tab // \"F-Stat\" // tab // \"P-Value\" !!     print '(AF2.0AF5.1AF5.1AF5.3AF5.3)', \"Main Factor: \" // tab, & !!         tbl%main_factor%dof, tab, & !!         tbl%main_factor%sum_of_squares, tab // tab, & !!         tbl%main_factor%variance, tab // tab, & !!         tbl%main_factor%f_statistic, tab, & !!         tbl%main_factor%probability !! !!     print '(AF3.0AF6.1AF5.1)', \"Within: \" // tab, & !!         tbl%within_factor%dof, tab, & !!         tbl%within_factor%sum_of_squares, tab // tab, & !!         tbl%within_factor%variance !! !!     print '(AF3.0AF6.1AF5.1)', \"Total: \" // tab // tab, & !!         tbl%total_dof, tab, & !!         tbl%total_sum_of_squares, tab // tab, & !!         tbl%total_variance !! !!     print '(AF6.1)', \"Overall Mean: \", tbl%overall_mean !! end program !! ``` !! The above program produces the following output. !! ```text !! Description     DOF     Sum of Sq.      Variance        F-Stat  P-Value !! Main Factor:    1.      352.8           352.8           2.147   0.160 !! Within:         18.     2958.2          164.3 !! Total:          19.     3311.0          174.3 !! Overall Mean: 3063.5 !! ``` !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Analysis_of_variance) !! - [SPC Excel Single Factor ANOVA](https://www.spcforexcel.com/knowledge/root-cause-analysis/single-factor-anova) !! - [SPC Excel Gage R&R](https://www.spcforexcel.com/knowledge/measurement-systems-analysis/anova-gage-rr-part-1) !! - [SPC Excel Understanding Regression Statistics](https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1) !! - [NIST - Two Way ANOVA](https://www.itl.nist.gov/div898/handbook/prc/section4/prc427.htm) module procedure :: anova_1_factor module procedure :: anova_2_factor module procedure :: anova_model_fit end interface contains ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/root-cause-analysis/single-factor-anova function anova_1_factor ( x ) result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data set. real ( real64 ), intent ( in ) :: x (:,:) !! An M-by-N matrix containing the M replications of the N test !! points of interest. type ( single_factor_anova_table ) :: rst !! A single_factor_anova_table instance containing the ANOVA results. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: j , a , n , nt real ( real64 ) :: sum_all , tssq , essq , bssq ! Initialization a = size ( x , 2 ) nt = size ( x , 1 ) n = nt * a rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Determine the degrees of freedom rst % main_factor % dof = a - 1 rst % within_factor % dof = n - a rst % total_dof = n - 1 ! Quick Return if ( a == 1 . or . nt == 1 ) then rst % main_factor % sum_of_squares = zero rst % main_factor % variance = zero rst % main_factor % f_statistic = zero rst % main_factor % probability = zero rst % within_factor % sum_of_squares = zero rst % within_factor % variance = zero rst % total_variance = variance ( pack ( x , . true .)) rst % total_sum_of_squares = rst % total_variance * rst % total_dof rst % overall_mean = mean ( pack ( x , . true .)) return end if ! Compute the sum of squares for all factors sum_all = sum ( x ) tssq = sum ( x ** 2 ) - ( sum_all ** 2 / n ) bssq = zero do j = 1 , a bssq = bssq + sum ( x (:, j )) ** 2 end do bssq = ( bssq / nt ) - ( sum_all ** 2 / n ) essq = tssq - bssq rst % main_factor % sum_of_squares = bssq rst % within_factor % sum_of_squares = essq rst % total_sum_of_squares = tssq ! Compute the variance terms rst % main_factor % variance = bssq / rst % main_factor % dof rst % within_factor % variance = essq / rst % within_factor % dof rst % total_variance = tssq / rst % total_dof ! Compute the overall mean rst % overall_mean = mean ( pack ( x , . true .)) ! Compute the F-statistic and probability term call anova_probability ( & rst % main_factor % variance , & rst % within_factor % variance , & rst % main_factor % dof , & rst % within_factor % dof , & rst % main_factor % f_statistic , & rst % main_factor % probability & ) end function ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/measurement-systems-analysis/anova-gage-rr-part-1 ! REF: https://www.itl.nist.gov/div898/handbook/prc/section4/prc427.htm ! Data set is expected as a 3D array with each of the K pages containing the R !   treatments of N tests such that the array size is N-by-R-by-K function anova_2_factor ( x ) result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data set. real ( real64 ), intent ( in ) :: x (:,:,:) !! An M-by-N-by-K array containing the M replications of the !! N first factor results, and the K second factor results. type ( two_factor_anova_table ) :: rst !! A two_factor_anova_table instance containing the ANOVA results. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , j , jj , k , r , n real ( real64 ) :: factorMean , sum_all real ( real64 ), allocatable :: xpack (:) ! Initialization n = size ( x , 3 ) k = size ( x , 2 ) r = size ( x , 1 ) rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Quick Return if ( k == 1 ) then ! This is a one-factor anova end if ! Determine the number of DOF rst % main_factor_1 % dof = k - one rst % main_factor_2 % dof = n - 1 rst % interaction % dof = ( k - 1 ) * ( n - 1 ) rst % within_factor % dof = n * k * ( r - 1 ) rst % total_dof = n * k * r - 1 ! Compute the overall mean, sum of squares, and variance xpack = pack ( x , . true .) rst % overall_mean = mean ( xpack ) rst % total_sum_of_squares = sum (( xpack - rst % overall_mean ) ** 2 ) rst % total_variance = rst % total_sum_of_squares / rst % total_dof ! Compute factor 1 results rst % main_factor_1 % sum_of_squares = zero do i = 1 , k factorMean = mean ( pack ( x (:, i ,:), . true .)) rst % main_factor_1 % sum_of_squares = rst % main_factor_1 % sum_of_squares + & ( factorMean - rst % overall_mean ) ** 2 end do rst % main_factor_1 % sum_of_squares = n * r * rst % main_factor_1 % sum_of_squares rst % main_factor_1 % variance = rst % main_factor_1 % sum_of_squares / & rst % main_factor_1 % dof ! Compute factor 2 results rst % main_factor_2 % sum_of_squares = zero do i = 1 , n factorMean = mean ( pack ( x (:,:, i ), . true .)) rst % main_factor_2 % sum_of_squares = rst % main_factor_2 % sum_of_squares + & ( factorMean - rst % overall_mean ) ** 2 end do rst % main_factor_2 % sum_of_squares = k * r * rst % main_factor_2 % sum_of_squares rst % main_factor_2 % variance = rst % main_factor_2 % sum_of_squares / & rst % main_factor_2 % dof ! Compute the within (error) term rst % within_factor % sum_of_squares = zero do j = 1 , k do i = 1 , n factorMean = mean ( x (:, j , i )) do jj = 1 , r rst % within_factor % sum_of_squares = & rst % within_factor % sum_of_squares + & ( x ( jj , j , i ) - factorMean ) ** 2 end do end do end do rst % within_factor % variance = rst % within_factor % sum_of_squares / & rst % within_factor % dof ! Compute the interaction term rst % interaction % sum_of_squares = rst % total_sum_of_squares - ( & rst % main_factor_1 % sum_of_squares + & rst % main_factor_2 % sum_of_squares + & rst % within_factor % sum_of_squares & ) rst % interaction % variance = rst % interaction % sum_of_squares / & rst % interaction % dof ! Compute the F-statistics call anova_probability ( & rst % main_factor_1 % variance , & rst % within_factor % variance , & rst % main_factor_1 % dof , & rst % within_factor % dof , & rst % main_factor_1 % f_statistic , & rst % main_factor_1 % probability & ) call anova_probability ( & rst % main_factor_2 % variance , & rst % within_factor % variance , & rst % main_factor_2 % dof , & rst % within_factor % dof , & rst % main_factor_2 % f_statistic , & rst % main_factor_2 % probability & ) call anova_probability ( & rst % interaction % variance , & rst % within_factor % variance , & rst % interaction % dof , & rst % within_factor % dof , & rst % interaction % f_statistic , & rst % interaction % probability & ) end function ! ------------------------------------------------------------------------------ ! REF: https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1 function anova_model_fit ( nmodelparams , ymeas , ymod , err ) result ( rst ) !! Performs an analysis of variance (ANOVA) on the supplied data set. integer ( int32 ), intent ( in ) :: nmodelparams !! The number of model parameters. real ( real64 ), intent ( in ) :: ymeas (:) !! An N-element array containing the measured dependent variable data. real ( real64 ), intent ( in ) :: ymod (:) !! An N-element array containing the modeled dependent variable data. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if ymeas and ymod are not the !!   same length. !! - FS_MEMORY_ERROR: Occurs if a memory error is encountered. type ( single_factor_anova_table ) :: rst !! A single_factor_anova_table instance containing the ANOVA results. ! Local Variables integer ( int32 ) :: n , flag real ( real64 ), allocatable :: ypack (:) real ( real64 ) :: sum_all class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization n = size ( ymeas ) if ( present ( err )) then errmgr => err else errmgr => deferr end if rst % within_factor % f_statistic = ieee_value ( sum_all , IEEE_QUIET_NAN ) rst % within_factor % probability = ieee_value ( sum_all , IEEE_QUIET_NAN ) ! Input Checking if ( size ( ymod ) /= n ) then call report_arrays_not_same_size_error ( errmgr , \"anova_model_fit\" , & \"YMEAS\" , \"YMOD\" , n , size ( ymod )) return end if ! Memory Allocation allocate ( ypack ( 2 * n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"anova_model_fit\" , flag ) return end if ! Determine the number of DOF rst % main_factor % dof = nmodelparams - 1 rst % within_factor % dof = n - rst % main_factor % dof - 1 rst % total_dof = n - 1 ! Process ypack ( 1 : n ) = ymeas ypack ( n + 1 : 2 * n ) = ymod rst % overall_mean = mean ( ypack ) rst % total_sum_of_squares = sum (( ymeas - rst % overall_mean ) ** 2 ) rst % main_factor % sum_of_squares = sum (( ymod - rst % overall_mean ) ** 2 ) rst % within_factor % sum_of_squares = sum (( ymeas - ymod ) ** 2 ) rst % total_variance = rst % total_sum_of_squares / rst % total_dof rst % main_factor % variance = rst % main_factor % sum_of_squares / & rst % main_factor % dof rst % within_factor % variance = rst % within_factor % sum_of_squares / & rst % within_factor % dof ! Compute the F-statistic and probability term call anova_probability ( & rst % main_factor % variance , & rst % within_factor % variance , & rst % main_factor % dof , & rst % within_factor % dof , & rst % main_factor % f_statistic , & rst % main_factor % probability & ) ! Formatting 100 format ( A , I0 , A , I0 , A ) 101 format ( A , I0 , A ) end function ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ subroutine anova_probability ( v1 , v2 , dof1 , dof2 , f , p ) ! Arguments real ( real64 ), intent ( in ) :: v1 , v2 , dof1 , dof2 real ( real64 ), intent ( out ) :: f , p ! Local Variables type ( f_distribution ) :: dist ! Process f = v1 / v2 dist % d1 = dof1 dist % d2 = dof2 p = 1.0d0 - dist % cdf ( f ) if ( p > 1.0d0 ) then p = 2.0d0 - p end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_anova.f90.html"},{"title":"fstats_bootstrap.f90 – FSTATS","text":"Contents Modules fstats_bootstrap Source Code fstats_bootstrap.f90 Source Code module fstats_bootstrap use iso_fortran_env use fstats_errors use omp_lib use fstats_distributions use fstats_descriptive_statistics use fstats_special_functions use fstats_regression use linalg , only : sort implicit none private public :: bootstrap_resampling_routine public :: bootstrap_statistic_routine public :: random_resample public :: scaled_random_resample public :: bootstrap_statistics public :: bootstrap ! REFERENCES: ! - https://medium.com/@m21413108/bootstrapping-maximum-entropy-non-parametric-boot-python-3b1e23ea589d ! - https://cran.r-project.org/web/packages/meboot/vignettes/meboot.pdf ! - https://gist.github.com/christianjauregui/314456688a3c2fead43a48be3a47dad6 type bootstrap_statistics !! A collection of statistics resulting from the bootstrap process. real ( real64 ) :: statistic_value !! The value of the statistic of interest. real ( real64 ) :: upper_confidence_interval !! The upper confidence limit on the statistic. real ( real64 ) :: lower_confidence_interval !! The lower confidence limit on the statistic. real ( real64 ) :: bias !! The bias in the statistic. real ( real64 ) :: standard_error !! The standard error of the statistic. real ( real64 ), allocatable , dimension (:) :: population !! An array of the population values generated by the bootstrap !! process. end type interface subroutine bootstrap_resampling_routine ( x , xn ) !! Defines the signature of a subroutine used to compute a !! resampling of data for bootstrapping purposes. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element array to resample. real ( real64 ), intent ( out ), dimension ( size ( x )) :: xn !! An N-element array where the resampled data set will be !! written. end subroutine function bootstrap_statistic_routine ( x ) result ( rst ) !! Defines the signature of a function for computing the desired !! bootstrap statistic. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: x !! The array of data to analyze. real ( real64 ) :: rst !! The resulting statistic. end function end interface contains ! ****************************************************************************** ! RESAMPLING ! ------------------------------------------------------------------------------ subroutine random_resample ( x , xn ) !! Random resampling, with replacement, based upon a normal distribution. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element array to resample. real ( real64 ), intent ( out ), dimension ( size ( x )) :: xn !! An N-element array where the resampled data set will be written. ! Parameters real ( real64 ), parameter :: scale = 1.25d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: xmin , xmax , rng ! Process n = size ( x ) xmin = x ( 1 ) xmax = x ( 1 ) do i = 2 , n xmin = min ( xmin , x ( i )) xmax = max ( xmax , x ( i )) end do rng = ( xmax - xmin ) call random_number ( xn ) xn = xn * rng + xmin end subroutine ! ------------------------------------------------------------------------------ subroutine scaled_random_resample ( x , xn ) !! A random resampling, scaled by the standard deviation of the original !! data, but based upon a normal distribution. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element array to resample. real ( real64 ), intent ( out ), dimension ( size ( x )) :: xn !! An N-element array where the resampled data set will be written. ! Parameters real ( real64 ), parameter :: half = 0.5d0 ! Local Variables integer ( int32 ) :: n real ( real64 ) :: eps ! Process n = size ( x ) eps = standard_deviation ( x ) / sqrt ( real ( n , real64 )) call random_number ( xn ) xn = eps * ( xn - half ) + x end subroutine ! ****************************************************************************** ! BOOTSTRAPPING ! ------------------------------------------------------------------------------ function bootstrap ( stat , x , method , nsamples , alpha ) result ( rst ) !! Performs a bootstrap calculation on the supplied data set for the given !! statistic.  The default implementation utlizes a random resampling with !! replacement.  Other resampling methods may be defined by specifying an !! appropriate routine by means of the method input. procedure ( bootstrap_statistic_routine ), pointer , intent ( in ) :: stat !! The routine used to compute the desired statistic. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element data set. procedure ( bootstrap_resampling_routine ), pointer , intent ( in ), optional :: method !! An optional pointer to the method to use for resampling of the data. !! If no method is supplied, a random resampling is utilized. integer ( int32 ), intent ( in ), optional :: nsamples !! An optional input, that if supplied, specifies the number of !! resampling runs to perform.  The default is 10 000. real ( real64 ), intent ( in ), optional :: alpha !! An optional input, that if supplied, defines the significance level !! to use for the analysis.  The default is 0.05. type ( bootstrap_statistics ) :: rst !! The resulting bootstrap_statistics type containing the confidence !! intervals, bias, standard error, etc. for the analyzed statistic. ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: p05 = 5.0d-2 ! Local Variables integer ( int32 ) :: i , i1 , i2 , n , ns real ( real64 ) :: a real ( real64 ), allocatable , dimension (:) :: xn procedure ( bootstrap_resampling_routine ), pointer :: resample ! Initialization n = size ( x ) if ( present ( method )) then resample => method else resample => random_resample end if if ( present ( nsamples )) then ns = nsamples else ns = 10000 end if if ( present ( alpha )) then a = alpha else a = p05 end if allocate ( rst % population ( ns )) i1 = floor ( half * a * ns , int32 ) i2 = ns - i1 + 1 ! Analyze the basic data set rst % statistic_value = stat ( x ) rst % population ( 1 ) = rst % statistic_value ! Resampling Process #ifdef USEOPENMP ! Use OpenMP to run operations in parallel !$OMP PARALLEL DO PRIVATE(xn) SHARED(rst) do i = 2 , ns ! Per-thread memory allocation if (. not . allocated ( xn )) allocate ( xn ( n )) ! Resample the data call resample ( x , xn ) ! Compute the statistic rst % population ( i ) = stat ( xn ) end do !$OMP END PARALLEL DO #else ! OpenMP is not available - run in a serial manner allocate ( xn ( n )) do i = 2 , ns ! Resample the data call resample ( x , xn ) ! Compute the statistic for the resampled data rst % population ( i ) = stat ( xn ) end do #endif ! Compute the relevant quantities on the resampled statistic call sort ( rst % population , . true .) rst % upper_confidence_interval = rst % population ( i2 ) rst % lower_confidence_interval = rst % population ( i1 ) rst % bias = mean ( rst % population ) - rst % statistic_value rst % standard_error = standard_deviation ( rst % population ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_bootstrap.f90.html"},{"title":"fstats_descriptive_statistics.f90 – FSTATS","text":"Contents Modules fstats_descriptive_statistics Source Code fstats_descriptive_statistics.f90 Source Code module fstats_descriptive_statistics use iso_fortran_env use linalg , only : sort use ferror use fstats_errors use fstats_types implicit none private public :: mean public :: variance public :: standard_deviation public :: median public :: quantile public :: trimmed_mean public :: covariance public :: pooled_variance interface pooled_variance !! Computes the pooled estimate of variance. module procedure :: pooled_variance_1 module procedure :: pooled_variance_2 end interface contains ! ------------------------------------------------------------------------------ pure function mean ( x ) result ( rst ) !! Computes the mean of the values in an array. real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst !! The result. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) if ( n == 0 ) then rst = zero else rst = x ( 1 ) do i = 2 , n rst = rst + ( x ( i ) - rst ) / i end do end if end function ! ------------------------------------------------------------------------------ pure function variance ( x ) result ( rst ) !! Computes the sample variance of the values in an array. !! !! The variance computed is the sample variance such that !!  s&#94;2 = \\frac{\\Sigma \\left( x_{i} - \\bar{x} \\right)&#94;2}{n - 1} . real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: oldMean , newMean ! Process n = size ( x ) if ( n <= 1 ) then rst = zero else oldMean = x ( 1 ) rst = zero do i = 2 , n newMean = oldMean + ( x ( i ) - oldMean ) / i rst = rst + ( x ( i ) - oldMean ) * ( x ( i ) - newMean ) oldMean = newMean end do rst = rst / ( n - one ) end if end function ! ------------------------------------------------------------------------------ pure function standard_deviation ( x ) result ( rst ) !! Computes the sample standard deviation of the values in an array. !! !! The value computed is the sample standard deviation. !!  s = \\sqrt{ \\frac{\\Sigma \\left( x_{i} - \\bar{x} \\right)&#94;2}{n - 1} }  real ( real64 ), intent ( in ) :: x (:) !! The array of values to analyze. real ( real64 ) :: rst !! The result. ! Process rst = sqrt ( variance ( x )) end function ! ------------------------------------------------------------------------------ function median ( x ) result ( rst ) !! Computes the median of the values in an array. real ( real64 ), intent ( inout ) :: x (:) !! The array of values to analyze.  On output, this array is sorted into !! ascending order. real ( real64 ) :: rst !! The result. ! Parameters real ( real64 ), parameter :: half = 0.5d0 ! Local Variables integer ( int32 ) :: n , nmid , nmidp1 , flag , iflag ! Initialization n = size ( x ) nmid = n / 2 nmidp1 = nmid + 1 iflag = n - 2 * nmid ! Sort the array in ascending order call sort ( x , . true .) ! Find the median if ( iflag == 0 ) then rst = half * ( x ( nmid ) + x ( nmidp1 )) else rst = x ( nmidp1 ) end if end function ! ------------------------------------------------------------------------------ ! REF: https://fortranwiki.org/fortran/show/Quartiles ! ! This is the method used by Minitab pure function quantile ( x , q ) result ( rst ) !! Computes the specified quantile of a data set using the SAS !! Method 4. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Quantile) real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the data. real ( real64 ), intent ( in ) :: q !! The quantile to compute (e.g. 0.25 computes the 25% quantile). real ( real64 ) :: rst !! The result. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables real ( real64 ) :: a , b , c , tol integer ( int32 ) :: n , ib ! Initialization tol = sqrt ( epsilon ( tol )) n = size ( x ) ! Process a = ( n + one ) * q b = mod ( a , one ) c = a - b ib = int ( c , int32 ) if (( ib + 1 ) > n ) then rst = ( one - b ) * x ( ib ) + b * x ( n ) else rst = ( one - b ) * x ( ib ) + b * x ( ib + 1 ) end if end function ! ------------------------------------------------------------------------------ function trimmed_mean ( x , p ) result ( rst ) !! Computes the trimmed mean of a data set. real ( real64 ), intent ( inout ), dimension (:) :: x !! An N-element array containing the data.  On output, the !! array is sorted into ascending order. real ( real64 ), intent ( in ), optional :: p !! An optional parameter specifying the percentage of values !! from either end of the distribution to remove.  The default !! is 0.05 such that the bottom 5% and top 5% are removed. real ( real64 ) :: rst !! The trimmed mean. ! Local Variables integer ( int32 ) :: i1 , i2 , n real ( real64 ) :: pv ! Initialization if ( present ( p )) then pv = abs ( p ) else pv = 0.05d0 end if ! Sort the array into ascending order call sort ( x , . true .) ! Find the limiting indices n = size ( x ) i1 = max ( floor ( n * pv , int32 ), 1 ) i2 = min ( n , n - i1 + 1 ) rst = mean ( x ( i1 : i2 )) end function ! ------------------------------------------------------------------------------ pure function covariance ( x , y ) result ( rst ) !! Computes the sample covariance of two data sets. !! !! The covariance computed is the sample covariance such that !!  q_{jk} = \\frac{\\Sigma \\left( x_{i} - \\bar{x} \\right) !! \\left( y_{i} - \\bar{y} \\right)}{n - 1} . real ( real64 ), intent ( in ), dimension (:) :: x !! The first N-element data set. real ( real64 ), intent ( in ), dimension ( size ( x )) :: y !! The second N-element data set. real ( real64 ) :: rst !! The covariance. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: meanX , meanY ! Process n = size ( x ) if ( n <= 1 ) then rst = zero else ! Compute the means meanX = x ( 1 ) meanY = y ( 1 ) do i = 2 , n meanX = meanX + ( x ( i ) - meanX ) / i meanY = meanY + ( y ( i ) - meanY ) / i end do ! Compute the covariance rst = sum (( x - meanX ) * ( y - meanY )) / ( n - one ) end if end function ! ------------------------------------------------------------------------------ pure function pooled_variance_1 ( si , ni ) result ( rst ) !! Computes the pooled estimate of variance. real ( real64 ), intent ( in ), dimension (:) :: si !! An N-element array containing the estimates for each of the N !! variances. integer ( int32 ), intent ( in ), dimension ( size ( si )) :: ni !! An N-element array containing the number of data points in each !! of the data sets used to compute the variances in si. real ( real64 ) :: rst !! The pooled variance. ! Local Variables integer ( int32 ) :: i , k , n ! Process k = size ( si ) rst = 0.0d0 n = 0 do i = 1 , k n = n + ni ( i ) rst = rst + ( ni ( i ) - 1.0d0 ) * si ( i ) end do rst = rst / real ( n - k , real64 ) end function pure function pooled_variance_2 ( x ) result ( rst ) !! Computes the pooled estimate of variance. type ( array_container ), intent ( in ), dimension (:) :: x !! An array of arrays of data. real ( real64 ) :: rst !! The pooled variance. ! Local Variables integer ( int32 ) :: i , k , n , ni ! Process k = size ( x ) n = 0 rst = 0.0d0 do i = 1 , k ni = size ( x ( i )% x ) n = n + ni rst = rst + variance ( x ( i )% x ) * ( ni - 1.0 ) end do rst = rst / real ( n - k , real64 ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_descriptive_statistics.f90.html"},{"title":"fstats_distributions.f90 – FSTATS","text":"Contents Modules fstats_distributions Source Code fstats_distributions.f90 Source Code module fstats_distributions use iso_fortran_env use ieee_arithmetic use fstats_special_functions use fstats_helper_routines use ferror use fstats_errors implicit none private public :: distribution public :: distribution_function public :: distribution_property public :: t_distribution public :: normal_distribution public :: f_distribution public :: chi_squared_distribution public :: binomial_distribution public :: multivariate_distribution public :: multivariate_distribution_function public :: multivariate_normal_distribution public :: log_normal_distribution real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) type , abstract :: distribution !! Defines a probability distribution. contains procedure ( distribution_function ), deferred , pass :: pdf !! Computes the probability density function. procedure ( distribution_function ), deferred , pass :: cdf !! Computes the cumulative distribution function. procedure ( distribution_property ), deferred , pass :: mean !! Computes the mean of the distribution. procedure ( distribution_property ), deferred , pass :: median !! Computes the median of the distribution. procedure ( distribution_property ), deferred , pass :: mode !! Computes the mode of the distribution. procedure ( distribution_property ), deferred , pass :: variance !! Computes the variance of the distribution. procedure , public :: standardized_variable => dist_std_var !! Computes the standardized variable for the distribution. end type interface pure elemental function distribution_function ( this , x ) result ( rst ) !! Defines the interface for a probability distribution function. use iso_fortran_env , only : real64 import distribution class ( distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function pure function distribution_property ( this ) result ( rst ) !! Computes the value of a distribution property. use iso_fortran_env , only : real64 import distribution class ( distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ) :: rst !! The property value. end function end interface ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: t_distribution !! Defines Student's T-Distribution. real ( real64 ) :: dof !! The number of degrees of freedom. contains procedure , public :: pdf => td_pdf procedure , public :: cdf => td_cdf procedure , public :: mean => td_mean procedure , public :: median => td_median procedure , public :: mode => td_mode procedure , public :: variance => td_variance end type ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: normal_distribution !! Defines a normal distribution. real ( real64 ) :: standard_deviation !! The standard deviation of the distribution. real ( real64 ) :: mean_value !! The mean value of the distribution. contains procedure , public :: pdf => nd_pdf procedure , public :: cdf => nd_cdf procedure , public :: mean => nd_mean procedure , public :: median => nd_median procedure , public :: mode => nd_mode procedure , public :: variance => nd_variance procedure , public :: standardize => nd_standardize end type ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: f_distribution !! Defines an F-distribution. real ( real64 ) :: d1 !! The measure of degrees of freedom for the first data set. real ( real64 ) :: d2 !! The measure of degrees of freedom for the second data set. contains procedure , public :: pdf => fd_pdf procedure , public :: cdf => fd_cdf procedure , public :: mean => fd_mean procedure , public :: median => fd_median procedure , public :: mode => fd_mode procedure , public :: variance => fd_variance end type ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: chi_squared_distribution !! Defines a Chi-squared distribution. integer ( int32 ) :: dof !! The number of degrees of freedom. contains procedure , public :: pdf => cs_pdf procedure , public :: cdf => cs_cdf procedure , public :: mean => cs_mean procedure , public :: median => cs_median procedure , public :: mode => cs_mode procedure , public :: variance => cs_variance end type ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: binomial_distribution !! Defines a binomial distribution.  The binomial distribution describes !! the probability p of getting k successes in n independent trials. integer ( int32 ) :: n !! The number of independent trials. real ( real64 ) :: p !! The success probability for each trial.  This parameter must !! exist on the set [0, 1]. contains procedure , public :: pdf => bd_pdf procedure , public :: cdf => bd_cdf procedure , public :: mean => bd_mean procedure , public :: median => bd_median procedure , public :: mode => bd_mode procedure , public :: variance => bd_variance end type ! ------------------------------------------------------------------------------ type , extends ( distribution ) :: log_normal_distribution !! Defines a normal distribution. real ( real64 ) :: standard_deviation !! The standard deviation of the distribution. real ( real64 ) :: mean_value !! The mean value of the distribution. contains procedure , public :: pdf => lnd_pdf procedure , public :: cdf => lnd_cdf procedure , public :: mean => lnd_mean procedure , public :: median => lnd_median procedure , public :: mode => lnd_mode procedure , public :: variance => lnd_variance end type ! ****************************************************************************** ! MULTIVARIATE DISTRIBUTIONS ! ------------------------------------------------------------------------------ type , abstract :: multivariate_distribution !! Defines a multivariate probability distribution. contains procedure ( multivariate_distribution_function ), deferred , pass :: pdf !! Computes the probability density function. end type interface pure function multivariate_distribution_function ( this , x ) result ( rst ) !! Defines an interface for a multivariate probability distribution !! function. use iso_fortran_env , only : real64 import multivariate_distribution class ( multivariate_distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ), intent ( in ), dimension (:) :: x !! The values at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. end function end interface ! ------------------------------------------------------------------------------ type , extends ( multivariate_distribution ) :: multivariate_normal_distribution !! Defines a multivariate normal (Gaussian) distribution. real ( real64 ), private , allocatable , dimension (:) :: m_means !! An N-element array of mean values. real ( real64 ), private , allocatable , dimension (:,:) :: m_cov !! The N-by-N covariance matrix.  This matrix must be !! positive-definite. real ( real64 ), private , allocatable , dimension (:,:) :: m_cholesky !! The N-by-N Cholesky factored form (lower) of the covariance !! matrix. real ( real64 ), private , allocatable , dimension (:,:) :: m_covInv !! The N-by-N inverse of the covariance matrix. real ( real64 ), private :: m_covDet !! The determinant of the covariance matrix. contains procedure , public :: initialize => mvnd_init procedure , public :: pdf => mvnd_pdf procedure , public :: get_means => mvnd_get_means procedure , public :: set_means => mvnd_update_mean procedure , public :: get_covariance => mvnd_get_covariance procedure , public :: get_cholesky_factored_matrix => mvnd_get_cholesky end type contains ! ------------------------------------------------------------------------------ pure elemental function dist_std_var ( this , x ) result ( rst ) !! Computes the standardized variable for the distribution. class ( distribution ), intent ( in ) :: this !! The distribution object. real ( real64 ), intent ( in ) :: x !! The value of interest. real ( real64 ) :: rst !! The result. ! Local Variables integer ( int32 ), parameter :: maxiter = 100 real ( real64 ), parameter :: tol = 1.0d-6 integer ( int32 ) :: i real ( real64 ) :: f , df , h , twoh , dy ! Process ! ! We use a simplified Newton's method to solve for the independent variable ! of the CDF function h = 1.0d-6 twoh = 2.0d0 * h rst = 0.5d0 ! just an initial guess do i = 1 , maxiter ! Compute the CDF and its derivative at y f = this % cdf ( rst ) - x df = ( this % cdf ( rst + h ) - this % cdf ( rst - h )) / twoh dy = f / df rst = rst - dy if ( abs ( dy ) < tol ) exit end do end function ! ****************************************************************************** ! STUDENT'S T-DISTRIBUTION ! ------------------------------------------------------------------------------ ! REF: https://en.wikipedia.org/wiki/Student%27s_t-distribution pure elemental function td_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for Student's T-Distribution is given as !!  f(t) = \\frac{ \\Gamma \\left( \\frac{\\nu + 1}{2} \\right) } !! { \\sqrt{\\nu \\pi} \\Gamma \\left( \\frac{\\nu}{2} \\right) } !! \\left( 1 + \\frac{t&#94;2}{\\nu} \\right)&#94;{-(\\nu + 1) / 2} . class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Process rst = gamma (( this % dof + 1.0d0 ) / 2.0d0 ) / & ( sqrt ( this % dof * pi ) * gamma ( this % dof / 2.0d0 )) * & ( 1.0d0 + x ** 2 / this % dof ) ** ( - 0.5d0 * ( 1.0d0 + this % dof )) end function ! ------------------------------------------------------------------------------ pure elemental function td_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for Student's T-Distribution is given as !!  F(t) = \\int_{-\\infty}&#94;{t} f(u) \\,du = 1 - \\frac{1}{2} I_{x(t)} !! \\left( \\frac{\\nu}{2}, \\frac{1}{2} \\right)  !! where  x(t) = \\frac{\\nu}{\\nu + t&#94;2} . class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Process real ( real64 ) :: t t = this % dof / ( this % dof + x ** 2 ) rst = 1.0d0 - 0.5d0 * regularized_beta ( 0.5d0 * this % dof , 0.5d0 , t ) if ( x < 0 ) rst = 1.0d0 - rst end function ! ------------------------------------------------------------------------------ pure function td_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The mean. ! Process if ( this % dof < 1.0d0 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) else rst = 0.0d0 end if end function ! ------------------------------------------------------------------------------ pure function td_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst ! Process rst = 0.0d0 end function ! ------------------------------------------------------------------------------ pure function td_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The mode. ! Process rst = 0.0d0 end function ! ------------------------------------------------------------------------------ pure function td_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( t_distribution ), intent ( in ) :: this !! The t_distribution object. real ( real64 ) :: rst !! The variance. ! Process if ( this % dof <= 1.0d0 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) else if ( this % dof > 1.0d0 . and . this % dof <= 2.0d0 ) then rst = ieee_value ( rst , IEEE_POSITIVE_INF ) else rst = this % dof / ( this % dof - 2.0d0 ) end if end function ! ****************************************************************************** ! NORMAL DISTRIBUTION ! ------------------------------------------------------------------------------ pure elemental function nd_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a normal distribution is given as !!  f(x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} \\exp \\left(-\\frac{1}{2} !! \\left( \\frac{x - \\mu}{\\sigma} \\right)&#94;2 \\right) . class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. rst = exp ( - 0.5d0 * (( x - this % mean_value ) / this % standard_deviation ) ** 2 ) / & ( this % standard_deviation * sqrt ( 2.0d0 * pi )) end function ! ------------------------------------------------------------------------------ pure elemental function nd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a normal distribution is given as !!  F(x) = \\frac{1}{2} \\left( 1 + erf \\left( \\frac{x - \\mu} !! {\\sigma \\sqrt{2}} \\right) \\right) . class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. rst = 0.5d0 * ( 1.0d0 + erf (( x - this % mean_value ) / & ( this % standard_deviation * sqrt ( 2.0d0 )))) end function ! ------------------------------------------------------------------------------ pure function nd_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The mean rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure function nd_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The median. rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure function nd_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The mode. rst = this % mean_value end function ! ------------------------------------------------------------------------------ pure function nd_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( normal_distribution ), intent ( in ) :: this !! The normal_distribution object. real ( real64 ) :: rst !! The variance. rst = this % standard_deviation ** 2 end function ! ------------------------------------------------------------------------------ subroutine nd_standardize ( this ) !! Standardizes the normal distribution to a mean of 0 and a !! standard deviation of 1. class ( normal_distribution ), intent ( inout ) :: this !! The normal_distribution object. this % mean_value = 0.0d0 this % standard_deviation = 1.0d0 end subroutine ! ****************************************************************************** ! F DISTRIBUTION ! ------------------------------------------------------------------------------ pure elemental function fd_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a F distribution is given as !!  f(x) = !! \\sqrt{ \\frac{ (d_1 x)&#94;{d_1} d_{2}&#94;{d_2} }{ (d_1 x + d_2)&#94;{d_1 + d_2} } } !! \\frac{1}{x \\beta \\left( \\frac{d_1}{2}, \\frac{d_2}{2} \\right) } . class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 rst = ( 1.0d0 / beta ( 0.5d0 * d1 , 0.5d0 * d2 )) * ( d1 / d2 ) ** ( 0.5d0 * d1 ) * & x ** ( 0.5d0 * d1 - 1.0d0 ) * ( 1.0d0 + d1 * x / d2 ) ** ( - 0.5d0 * ( d1 + d2 )) end function ! ------------------------------------------------------------------------------ pure elemental function fd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a F distribution is given as !!  F(x) = I_{d_1 x/(d_1 x + d_2)} \\left( \\frac{d_1}{2}, !! \\frac{d_2}{2} \\right) . class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 rst = regularized_beta ( 0.5d0 * d1 , 0.5d0 * d2 , d1 * x / ( d1 * x + d2 )) end function ! ------------------------------------------------------------------------------ pure function fd_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The mean. ! Process if ( this % d2 > 2.0d0 ) then rst = this % d2 / ( this % d2 - 2.0d0 ) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ------------------------------------------------------------------------------ pure function fd_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The median. rst = ieee_value ( rst , IEEE_QUIET_NAN ) end function ! ------------------------------------------------------------------------------ pure function fd_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The mode. ! Process if ( this % d1 > 2.0d0 ) then rst = (( this % d1 - 2.0d0 ) / this % d1 ) * ( this % d2 / ( this % d2 + 2.0d0 )) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ------------------------------------------------------------------------------ pure function fd_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( f_distribution ), intent ( in ) :: this !! The f_distribution object. real ( real64 ) :: rst !! The variance. ! Process real ( real64 ) :: d1 , d2 d1 = this % d1 d2 = this % d2 if ( d2 > 4.0d0 ) then rst = ( 2.0d0 * d2 ** 2 * ( d1 + d2 - 2.0d0 )) / & ( d1 * ( d2 - 2.0d0 ) ** 2 * ( d2 - 4.0d0 )) else rst = ieee_value ( rst , IEEE_QUIET_NAN ) end if end function ! ****************************************************************************** ! CHI-SQUARED DISTRIBUTION ! ------------------------------------------------------------------------------ pure elemental function cs_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a Chi-squared distribution is given as !!  f(x) = \\frac{x&#94;{k/2 - 1} \\exp{-x / 2}} {2&#94;{k / 2} !! \\Gamma \\left( \\frac{k}{2} \\right)} . class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Local Variables real ( real64 ) :: arg ! Process arg = 0.5d0 * this % dof rst = 1.0d0 / ( 2.0d0 ** arg * gamma ( arg )) * x ** ( arg - 1.0d0 ) * exp ( - 0.5d0 * x ) end function ! ------------------------------------------------------------------------------ pure elemental function cs_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a Chi-squared distribution is given as !!  F(x) = \\frac{ \\gamma \\left( \\frac{k}{2}, \\frac{x}{2} \\right) } !! { \\Gamma \\left( \\frac{k}{2} \\right)} . class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Local Variables real ( real64 ) :: arg ! Process arg = 0.5d0 * this % dof rst = incomplete_gamma_lower ( arg , 0.5d0 * x ) / gamma ( arg ) end function ! ------------------------------------------------------------------------------ pure function cs_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The mean. ! Process rst = real ( this % dof , real64 ) end function ! ------------------------------------------------------------------------------ pure function cs_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The median. ! Process rst = this % dof * ( 1.0d0 - 2.0d0 / ( 9.0d0 * this % dof )) ** 3 end function ! ------------------------------------------------------------------------------ pure function cs_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The mode. ! Process rst = max ( this % dof - 2.0d0 , 0.0d0 ) end function ! ------------------------------------------------------------------------------ pure function cs_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( chi_squared_distribution ), intent ( in ) :: this !! The chi_squared_distribution object. real ( real64 ) :: rst !! The variance. ! Process rst = 2.0d0 * this % dof end function ! ****************************************************************************** ! BINOMIAL DISTRIBUTION ! ------------------------------------------------------------------------------ pure elemental function bd_pdf ( this , x ) result ( rst ) !! Computes the probability mass function. !! !! The PMF for a binomial distribution is given as !!  f(k,n,p) = \\frac{n!}{k! \\left( n - k! \\right)} p&#94;k !! \\left( 1 - p \\right)&#94;{n-k} . class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function.  This parameter !! is the number k successes in the n independent trials.  As !! such, this parameter must exist on the set [0, n]. real ( real64 ) :: rst !! The value of the function. ! Local Variables real ( real64 ) :: dn ! Process dn = real ( this % n , real64 ) rst = ( factorial ( dn ) / ( factorial ( x ) * factorial ( dn - x ))) * ( this % p ** x ) * ( 1.0d0 - this % p ) ** ( dn - x ) end function ! ------------------------------------------------------------------------------ pure elemental function bd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution funtion. !! !! The CDF for a binomial distribution is given as !!  F(k,n,p) = I_{1-p} \\left( n - k, 1 + k \\right) , which is simply !! the regularized incomplete beta function. class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function.  This parameter !! is the number k successes in the n independent trials.  As !! such, this parameter must exist on the set [0, n]. real ( real64 ) :: rst !! The value of the function. ! Local Variables real ( real64 ) :: dn ! Process dn = real ( this % n , real64 ) rst = regularized_beta ( dn - x , x + 1.0d0 , 1.0d0 - this % p ) end function ! ------------------------------------------------------------------------------ pure function bd_mean ( this ) result ( rst ) !! Computes the mean of the distribution. class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ) :: rst !! The mean. rst = real ( this % n * this % p , real64 ) end function ! ------------------------------------------------------------------------------ pure function bd_median ( this ) result ( rst ) !! Computes the median of the distribution. class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ) :: rst !! The median. rst = real ( this % n * this % p , real64 ) end function ! ------------------------------------------------------------------------------ pure function bd_mode ( this ) result ( rst ) !! Computes the mode of the distribution. class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ) :: rst !! The mode. rst = ( this % n + 1.0d0 ) * this % p end function ! ------------------------------------------------------------------------------ pure function bd_variance ( this ) result ( rst ) !! Computes the variance of the distribution. class ( binomial_distribution ), intent ( in ) :: this !! The binomial_distribution object. real ( real64 ) :: rst !! The variance. rst = this % n * this % p * ( 1.0d0 - this % p ) end function ! ****************************************************************************** ! MULTIVARIATE NORMAL DISTRIBUTION ! ------------------------------------------------------------------------------ subroutine mvnd_init ( this , mu , sigma , err ) use linalg , only : cholesky_factor !! Initializes the multivariate normal distribution by defining the mean !! values and covariance matrix. class ( multivariate_normal_distribution ), intent ( inout ) :: this !! The multivariate_normal_distribution object. real ( real64 ), intent ( in ), dimension (:) :: mu !! An N-element array containing the mean values. real ( real64 ), intent ( in ), dimension (:,:) :: sigma !! The N-by-N covariance matrix.  The PDF exists only if this matrix !! is positive-definite; therefore, the positive-definite constraint !! is checked within this routine and enforced.  An error is thrown if !! the supplied matrix is not positive-definite. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. ! Local Variables integer ( int32 ) :: n , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( mu ) ! Input Checking if ( size ( sigma , 1 ) /= n . or . size ( sigma , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"mvnd_init\" , \"sigma\" , n , n , & size ( sigma , 1 ), size ( sigma , 2 )) return end if ! Store the matrices this % m_means = mu this % m_cov = sigma if ( allocated ( this % m_covInv )) then if ( size ( this % m_covInv , 1 ) /= n . or . size ( this % m_covInv , 2 ) /= n ) then deallocate ( this % m_covInv ) allocate ( this % m_covInv ( n , n ), stat = flag ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_covInv ( n , n ), stat = flag ) if ( flag /= 0 ) go to 10 end if if ( allocated ( this % m_cholesky )) then if ( size ( this % m_cholesky , 1 ) /= n . or . size ( this % m_cholesky , 2 ) /= n ) then deallocate ( this % m_cholesky ) allocate ( this % m_cholesky ( n , n ), stat = flag ) if ( flag /= 0 ) go to 10 end if else allocate ( this % m_cholesky ( n , n ), stat = flag , source = sigma ) if ( flag /= 0 ) go to 10 end if ! Compute the Cholesky factorization of the covariance matrix call cholesky_factor ( this % m_cholesky , upper = . false ., err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the inverse and determinant call populate_identity ( this % m_covInv ) call cholesky_inverse ( this % m_cholesky , this % m_covInv ) this % m_covDet = cholesky_determinant ( this % m_cholesky ) ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"mvnd_init\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ pure function mvnd_pdf ( this , x ) result ( rst ) !! Evaluates the PDF for the multivariate normal distribution. class ( multivariate_normal_distribution ), intent ( in ) :: this !! The multivariate_normal_distribution object. real ( real64 ), intent ( in ), dimension (:) :: x !! The values at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. ! Local Variables integer ( int32 ) :: n real ( real64 ) :: arg real ( real64 ), allocatable , dimension (:) :: delta , prod ! Process n = size ( x ) delta = x - this % m_means prod = matmul ( this % m_covInv , delta ) ! prod = inv(sigma) * (x - mu) arg = dot_product ( delta , prod ) ! arg = (x - mu)**T * prod rst = exp ( - 0.5d0 * arg ) / sqrt (( 2.0d0 * pi ) ** n * this % m_covDet ) end function ! ------------------------------------------------------------------------------ subroutine mvnd_update_mean ( this , x , err ) !! Updates the mean value array. class ( multivariate_normal_distribution ), intent ( inout ) :: this !! The multivariate_normal_distribution object. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element array of new mean values. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object.  This is referenced only in the event that !! the size of x is not compatible with the existing state. ! Local Variables integer ( int32 ) :: n , nc , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) nc = size ( this % m_means ) ! Process if (. not . allocated ( this % m_means )) then ! This is an initial set-up - just store the values and be done allocate ( this % m_means ( n ), stat = flag , source = x ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mvnd_update_mean\" , flag ) return end if return end if ! Else, ensure the array is of the correct size before updating if ( n /= nc ) then call report_array_size_error ( errmgr , \"mvnd_update_mean\" , \"x\" , nc , n ) return end if this % m_means = x end subroutine ! ------------------------------------------------------------------------------ pure function mvnd_get_means ( this ) result ( rst ) !! Gets the mean values of the distribution. class ( multivariate_normal_distribution ), intent ( in ) :: this !! The multivariate_normal_distribution object. real ( real64 ), allocatable , dimension (:) :: rst !! The mean values. ! Process integer ( int32 ) :: n if ( allocated ( this % m_means )) then n = size ( this % m_means ) allocate ( rst ( n ), source = this % m_means ) else allocate ( rst ( 0 )) end if end function ! ------------------------------------------------------------------------------ pure function mvnd_get_covariance ( this ) result ( rst ) !! Gets the covariance matrix of the distribution. class ( multivariate_normal_distribution ), intent ( in ) :: this !! The multivariate_normal_distribution object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The covariance matrix. ! Process integer ( int32 ) :: n if ( allocated ( this % m_cov )) then n = size ( this % m_cov , 1 ) allocate ( rst ( n , n ), source = this % m_cov ) else allocate ( rst ( 0 , 0 )) end if end function ! ------------------------------------------------------------------------------ pure function mvnd_get_cholesky ( this ) result ( rst ) !! Gets the lower triangular form of the Cholesky factorization of the !! covariance matrix of the distribution. class ( multivariate_normal_distribution ), intent ( in ) :: this !! The multivariate_normal_distribution object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The Cholesky factored matrix. ! Process integer ( int32 ) :: n if ( allocated ( this % m_cholesky )) then n = size ( this % m_cholesky , 1 ) allocate ( rst ( n , n ), source = this % m_cholesky ) else allocate ( rst ( 0 , 0 )) end if end function ! ****************************************************************************** ! LOG NORMAL DISTRIBUTION ! ------------------------------------------------------------------------------ pure elemental function lnd_pdf ( this , x ) result ( rst ) !! Computes the probability density function. !! !! The PDF for a log-normal distribution is given as !!  f(x) = \\frac{1}{x \\sigma \\sqrt{2 \\pi}} \\exp{\\left(- \\frac{\\left( !! \\ln{x} - \\mu \\right)&#94;2}{2 \\sigma&#94;2} \\right)}  class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. rst = exp ( - ( log ( x ) - this % mean_value ) ** 2 / & ( 2.0d0 * this % standard_deviation ** 2 )) / & ( x * this % standard_deviation * sqrt ( 2.0d0 * pi )) end function ! ------------------------------------------------------------------------------ pure elemental function lnd_cdf ( this , x ) result ( rst ) !! Computes the cumulative distribution function. !! !! The CDF for a log-normal distribution is given as !!  F(x) = \\frac{1}{2} \\left(1 + erf\\left( \\frac{\\ln{x} - \\mu} !! {\\sigma \\sqrt{2}} \\right) \\right)  class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal_distribution object. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The value of the function. rst = 0.5d0 * ( 1.0d0 + erf (( log ( x ) - this % standard_deviation ) / & ( this % standard_deviation * sqrt ( 2.0d0 )))) end function ! ------------------------------------------------------------------------------ pure function lnd_mean ( this ) result ( rst ) !! Computes the mean of the distribution class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal distribution object. real ( real64 ) :: rst !! The mean rst = exp ( this % mean_value + 0.5d0 * this % standard_deviation ** 2 ) end function ! ------------------------------------------------------------------------------ pure function lnd_median ( this ) result ( rst ) !! Computes the median of the distribution class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal distribution object. real ( real64 ) :: rst !! The median rst = exp ( this % mean_value ) end function ! ------------------------------------------------------------------------------ pure function lnd_mode ( this ) result ( rst ) !! Computes the mode of the distribution class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal distribution object. real ( real64 ) :: rst !! The mode rst = exp ( this % mean_value - this % standard_deviation ** 2 ) end function ! ------------------------------------------------------------------------------ pure function lnd_variance ( this ) result ( rst ) !! Computes the variance of the distribution class ( log_normal_distribution ), intent ( in ) :: this !! The log_normal distribution object. real ( real64 ) :: rst !! The variance rst = ( exp ( this % standard_deviation ** 2 ) - 1.0d0 ) * & exp ( 2.0d0 * this % mean_value + this % standard_deviation ** 2 ) end function ! ****************************************************************************** ! SUPPORTING ROUTINES ! ------------------------------------------------------------------------------ subroutine cholesky_inverse ( x , u ) use linalg , only : solve_triangular_system !! Computes the inverse of a Cholesky-factored matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The lower-triangular Cholesky factored matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: u !! On input, an N-by-N identity matrix.  On output, the N-by-N inverted !! matrix. ! To compute the inverse of a Cholesky factored matrix (L) consider the ! following: ! ! A = L * L**T ! ! (L * L**T) * inv(A) = I, where I is an identity matrix ! ! First, solve L * U = I, for the N-by-N matrix U ! ! And then solve L' * inv(A) = U for inv(A) ! Solve L * U = I for U call solve_triangular_system (. true ., . false ., . false ., . true ., 1.0d0 , x , u ) ! Solve L**T * inv(A) = U for inv(A) call solve_triangular_system (. true ., . false ., . true ., . true ., 1.0d0 , x , u ) end subroutine ! ------------------------------------------------------------------------------ pure function cholesky_determinant ( x ) result ( rst ) !! Computes the determinant of a Cholesky factored (lower) matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The lower-triangular Cholesky-factored matrix. real ( real64 ) :: rst !! The determinant. ! Local Variables integer ( int32 ) :: i , ep , n real ( real64 ) :: temp ! Initialization n = size ( x , 1 ) rst = 0.0d0 ! Compute the product of the squares of the diagonal temp = 1.0d0 ep = 0 do i = 1 , n temp = ( x ( i , i )) ** 2 * temp if ( temp == 0.0d0 ) then rst = 0.0d0 return end if do while ( abs ( temp ) < 1.0d0 ) temp = 1.0d1 * temp ep = ep - 1 end do do while ( abs ( temp ) > 1.0d1 ) temp = 1.0d-1 * temp ep = ep + 1 end do end do rst = temp * ( 1.0d1 ) ** ep end function ! ------------------------------------------------------------------------------ subroutine populate_identity ( x ) !! Populates the supplied matrix as an identity matrix. real ( real64 ), intent ( inout ), dimension (:,:) :: x ! Local Variables integer ( int32 ) :: i , m , n , mn ! Process m = size ( x , 1 ) n = size ( x , 2 ) mn = min ( m , n ) x = 0.0d0 do i = 1 , mn x ( i , i ) = 1.0d0 end do end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_distributions.f90.html"},{"title":"fstats_errors.f90 – FSTATS","text":"Contents Modules fstats_errors Source Code fstats_errors.f90 Source Code ! A module providing a set of routines to handle errors for the FSTATS library. module fstats_errors use ferror use iso_fortran_env , only : int32 implicit none ! ****************************************************************************** ! ERROR CODES ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: FS_NO_ERROR = 0 integer ( int32 ), parameter :: FS_ARRAY_SIZE_ERROR = 10000 integer ( int32 ), parameter :: FS_MATRIX_SIZE_ERROR = 10001 integer ( int32 ), parameter :: FS_INVALID_INPUT_ERROR = 10002 integer ( int32 ), parameter :: FS_MEMORY_ERROR = 10003 integer ( int32 ), parameter :: FS_UNDERDEFINED_PROBLEM_ERROR = 10004 integer ( int32 ), parameter :: FS_TOLERANCE_TOO_SMALL_ERROR = 10005 integer ( int32 ), parameter :: FS_TOO_FEW_ITERATION_ERROR = 10006 integer ( int32 ), parameter :: FS_INVALID_ARGUMENT_ERROR = 10007 ! ------------------------------------------------------------------------------ integer ( int32 ), private , parameter :: MESSAGE_SIZE = 1024 contains ! ------------------------------------------------------------------------------ subroutine report_memory_error ( err , fname , code ) !! Reports a memory allocation related error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fname !! The name of the routine in which the error occurred. integer ( int32 ), intent ( in ) :: code !! The error code returned by the allocation routine. ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) & \"A memory allocation error occurred with code \" , code , \".\" call err % report_error ( fname , trim ( msg ), FS_MEMORY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_array_size_error ( err , fname , name , expect , actual ) !! Reports an array size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fname !! The name of the routine in which the error occurred. character ( len = * ), intent ( in ) :: name !! The name of the array. integer ( int32 ), intent ( in ) :: expect !! The expected size of the array. integer ( int32 ), intent ( in ) :: actual !! The actual size of the array. ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Expected array \" // name // \" to be of length \" , & expect , \", but found it to be of length \" , actual , \".\" call err % report_error ( fname , trim ( msg ), FS_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_error ( err , fname , name , expect_rows , & expect_cols , actual_rows , actual_cols ) !! Reports a matrix size error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fname !! The name of the routine in which the error occurred. character ( len = * ), intent ( in ) :: name !! The name of the matrix. integer ( int32 ), intent ( in ) :: expect_rows !! The expected number of rows. integer ( int32 ), intent ( in ) :: expect_cols !! The expected number of columns. integer ( int32 ), intent ( in ) :: actual_rows !! The actual number of rows. integer ( int32 ), intent ( in ) :: actual_cols !! The actual number of columns. ! Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Expected matrix \" // name // \" to be of size (\" , & expect_rows , \", \" , expect_cols , \"), but found it to be of size (\" , & actual_rows , \", \" , actual_cols , \").\" call err % report_error ( fname , trim ( msg ), FS_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_arrays_not_same_size_error ( err , fname , name1 , name2 , & size1 , size2 ) !! Reports an error relating to two arrays not being the same size !! when they should be the same size. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fname !! The name of the routine in which the error occurred. character ( len = * ), intent ( in ) :: name1 !! The name of the first array. character ( len = * ), intent ( in ) :: name2 !! The name of the second array. integer ( int32 ), intent ( in ) :: size1 !! The size of the first array. integer ( int32 ), intent ( in ) :: size2 !! The size of the second array. ! Local Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"Array \" // name1 // \" and array \" // name2 // & \"were expected to be the same size, but instead were found \" // & \"to be sized \" , size1 , \" and \" , size2 , \" respectively.\" call err % report_error ( fname , trim ( msg ), FS_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_underdefined_error ( err , fname , expect , actual ) !! Reports an underdefined problem error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ), intent ( in ) :: fname !! The name of the routine in which the error occurred. integer ( int32 ), intent ( in ) :: expect !! The expected minimum number of equations. integer ( int32 ), intent ( in ) :: actual !! The actual number of equations. ! Local Variables character ( len = MESSAGE_SIZE ) :: msg ! Process write ( msg , 100 ) \"The problem is underdefined.  The number of \" // & \"equations was found to be \" , actual , & \", but must be at least equal to the number of unknowns \" , & expect , \".\" call err % report_error ( fname , trim ( msg ), FS_UNDERDEFINED_PROBLEM_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_iteration_count_error ( err , fname , msg , mincount ) !! Reports an iteration count error. class ( errors ), intent ( inout ) :: err !! The error handling object. character ( len = * ) :: fname !! The name of the routine in which the error occurred. character ( len = * ) :: msg !! The error message. integer ( int32 ), intent ( in ) :: mincount !! The minimum iteration count expected. ! Local Variables character ( len = MESSAGE_SIZE ) :: emsg ! Process write ( emsg , 100 ) msg // \"  A minimum of \" , mincount , \" is expected.\" call err % report_error ( fname , trim ( emsg ), FS_TOO_FEW_ITERATION_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_errors.f90.html"},{"title":"fstats_experimental_design.f90 – FSTATS","text":"Contents Modules fstats_experimental_design Source Code fstats_experimental_design.f90 Source Code module fstats_experimental_design use iso_fortran_env use fstats_errors use fstats_regression implicit none private public :: get_full_factorial_matrix_size public :: full_factorial public :: doe_fit_model public :: doe_evaluate_model public :: doe_model type doe_model !! A model used to represent a design of experiments result.  The model !! is of the following form. !! !!  Y = \\beta_{0} + \\sum_{i=1}&#94;{n} \\beta_{i} X_{i} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1 \\\\ i \\neq j}&#94;{n} \\beta_{ij} X_{i} X_{j} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1}&#94;{n} \\sum_{k=1 \\\\ i \\neq j \\neq k}&#94;{n} \\beta_{ijk} X_{i} !! X_{j} X_{k} + ...  integer ( int32 ) :: nway !! The number of interaction levels. real ( real64 ), allocatable , dimension (:) :: coefficients !! The model coefficients. type ( regression_statistics ), allocatable , dimension (:) :: stats !! Statistical information for each model parameter. logical , allocatable , dimension (:) :: map !! An array denoting if a model coefficient should be included !! as part of the model (true), or neglected (false). end type interface doe_evaluate_model module procedure :: doe_evaluate_model_1 module procedure :: doe_evaluate_model_2 end interface contains ! ------------------------------------------------------------------------------ subroutine get_full_factorial_matrix_size ( vars , m , n , err ) !! Computes the appropriate size for a full-factorial design table. integer ( int32 ), intent ( in ) :: vars (:) !! An M-element array containing the M factors to study.  Each !! of the M entries to the array is expected to contain the !! number of options for that particular factor to explore. !! This value must be greater than or equal to 1. integer ( int32 ), intent ( out ) :: m !! The number of rows for the table. integer ( int32 ), intent ( out ) :: n !! The number of columns for the table. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_INVALID_INPUT_ERROR: Occurs if any items in vars are !!      less than 1. ! Local Variables integer ( int32 ) :: i class ( errors ), pointer :: errmgr type ( errors ), target :: deferr character ( len = 256 ) :: errmsg ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = 0 n = 0 ! Ensure every value is greater than 1 do i = 1 , size ( vars ) if ( vars ( i ) < 1 ) then write ( errmsg , 100 ) \"A value less than 1 was found at index \" , & i , \" of the input array.  All values must be greater \" // & \"than or equal to 1.\" call errmgr % report_error ( \"get_full_factorial_matrix_size\" , & trim ( errmsg ), FS_INVALID_INPUT_ERROR ) return end if end do ! Process m = product ( vars ) n = size ( vars ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine full_factorial ( vars , tbl , err ) !! Computes a table with values scaled from 1 to N describing a !! full-factorial design. !! !! ```fortran !! program example !!     use iso_fortran_env !!     use fstats !!     implicit none !! !!     ! Local Variables !!     integer(int32) :: i, vars(3), tbl(24, 3) !! !!     ! Define the number of design points for each of the 3 factors to study !!     vars = [2, 4, 3] !! !!     ! Determine the design table !!     call full_factorial(vars, tbl) !! !!     ! Display the table !!     do i = 1, size(tbl, 1) !!         print *, tbl(i,:) !!     end do !! end program !! ``` !! The above program produces the following output. !! ```text !! 1           1           1 !! 1           1           2 !! 1           1           3 !! 1           2           1 !! 1           2           2 !! 1           2           3 !! 1           3           1 !! 1           3           2 !! 1           3           3 !! 1           4           1 !! 1           4           2 !! 1           4           3 !! 2           1           1 !! 2           1           2 !! 2           1           3 !! 2           2           1 !! 2           2           2 !! 2           2           3 !! 2           3           1 !! 2           3           2 !! 2           3           3 !! 2           4           1 !! 2           4           2 !! 2           4           3 !! ``` integer ( int32 ), intent ( in ) :: vars (:) !! An M-element array containing the M factors to study. !! Each of the M entries to the array is expected to contain !! the number of options for that particular factor to explore. !! This value must be greater than or equal to 1. integer ( int32 ), intent ( out ) :: tbl (:,:) !! A table where the design will be written.  Use !! get_full_factorial_matrix_size to determine the appropriate !! table size. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_INVALID_INPUT_ERROR: Occurs if any items in vars are !!      less than 1. !! - FS_ARRAY_SIZE_ERROR: Occurs if tbl is not properly sized. ! Local Variables integer ( int32 ) :: i , col , stride , last , val , m , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Verify the size of the input table call get_full_factorial_matrix_size ( vars , m , n , errmgr ) if ( errmgr % has_error_occurred ()) return if ( size ( tbl , 1 ) /= m . or . size ( tbl , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"full_factorial\" , & \"tbl\" , m , n , size ( tbl , 1 ), size ( tbl , 2 )) return end if ! Process do col = 1 , n stride = 1 if ( col /= n ) stride = product ( vars ( col + 1 : n )) val = 1 do i = 1 , m , stride last = i + stride - 1 tbl ( i : last , col ) = val val = val + 1 if ( val > vars ( col )) val = 1 end do end do end subroutine ! ------------------------------------------------------------------------------ function doe_fit_model ( nway , x , y , map , alpha , err ) result ( rst ) use blas , only : DGEMM use ieee_arithmetic !! Fits a Taylor series model to the provided data. !! !!  Y = \\beta_{0} + \\sum_{i=1}&#94;{n} \\beta_{i} X_{i} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1 \\\\ i \\neq j}&#94;{n} \\beta_{ij} X_{i} X_{j} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1}&#94;{n} \\sum_{k=1 \\\\ i \\neq j \\neq k}&#94;{n} \\beta_{ijk} X_{i} !! X_{j} X_{k} + ...  integer ( int32 ), intent ( in ) :: nway !! The number of interaction levels. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! used to produce the results. real ( real64 ), intent ( in ), dimension (:) :: y !! An M-element array containing the results from the M experiments. logical , intent ( in ), optional , target , dimension (:) :: map !! An optional array of the same size as beta that can be used to !! eliminate a parameter from the model (false), or keep a parameter !! in the model (true).  If not supplied, all parameters will be assumed !! to be part of the model as if the array were filled with all true !! values. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x and y are not properly sized !!      relative to one another. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. !! - FS_INVALID_ARGUMENT_ERROR: Occurs if nway is out of range, or if !!      map is used to \"turn off\" all model parameters. type ( doe_model ) :: rst !! The resulting model. ! Local Variables integer ( int32 ) :: i , j , m , n , nparam , nfactors , flag logical , allocatable , target , dimension (:) :: nmap logical , pointer , dimension (:) :: mapptr real ( real64 ) :: alph , nan real ( real64 ), allocatable , dimension (:) :: coeffs , ymod , resid real ( real64 ), allocatable , dimension (:,:) :: xc , c , cxt type ( regression_statistics ), allocatable , dimension (:) :: stats class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( alpha )) then alph = alpha else alph = 5.0d-2 end if m = size ( x , 1 ) nfactors = size ( x , 2 ) nan = ieee_value ( nan , IEEE_QUIET_NAN ) ! Input Checking if ( nway < 1 . or . nway > 3 ) then call errmgr % report_error ( \"doe_fit_model\" , & \"The number of interaction levels must be between one and three.\" , & FS_INVALID_ARGUMENT_ERROR ) return end if ! Determine the parameter count nparam = 1 if ( nway >= 1 ) nparam = nparam + nfactors if ( nway >= 2 ) nparam = nparam + nfactors * ( nfactors - 1 ) if ( nway >= 3 ) nparam = nparam + nfactors * ( nfactors ** 2 - 1 ) ! Set up the map parameters if ( present ( map )) then if ( size ( map ) /= nparam ) then call report_array_size_error ( errmgr , \"doe_fit_model\" , \"map\" , & nparam , size ( map )) return end if mapptr => map else allocate ( nmap ( nparam ), stat = flag , source = . true .) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"doe_fit_model\" , flag ) return end if mapptr => nmap end if ! Update the parameter count n = nparam do i = 1 , nparam if (. not . mapptr ( i )) n = n - 1 end do if ( n < 1 ) then call errmgr % report_error ( \"doe_fit_model\" , & \"There must be at least one active model parameter.\" , & FS_INVALID_ARGUMENT_ERROR ) return end if ! Local memory allocations allocate ( xc ( m , n ), c ( n , n ), cxt ( n , m ), coeffs ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"doe_fit_model\" , flag ) return end if ! Create the design matrix call doe_design_matrix ( nway , x , mapptr , xc ) ! Compute the covariance matrix call covariance_matrix ( xc , c , errmgr ) if ( errmgr % has_error_occurred ()) return ! Solve the least-squares problem (N-by-1 result) call DGEMM ( \"N\" , \"T\" , n , m , n , 1.0d0 , c , n , xc , m , 0.0d0 , cxt , n ) ! C * X**T call DGEMM ( \"N\" , \"N\" , n , 1 , m , 1.0d0 , cxt , n , y , m , 0.0d0 , coeffs , n ) ! (C * X**T) * Y ! Evaluate the model and compute the residuals ymod = matmul ( xc , coeffs ) resid = ymod - y ! Estimate parameter statistics stats = calculate_regression_statistics ( resid , coeffs , c , alph , errmgr ) if ( errmgr % has_error_occurred ()) return ! Update output rst % nway = nway allocate ( rst % coefficients ( nparam ), stat = flag ) if ( flag == 0 ) allocate ( rst % stats ( nparam ), stat = flag ) if ( flag == 0 ) allocate ( rst % map ( nparam ), stat = flag , source = mapptr ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"doe_fit_model\" , flag ) return end if j = 0 do i = 1 , nparam if ( mapptr ( i )) then j = j + 1 rst % coefficients ( i ) = coeffs ( j ) rst % stats ( i ) = stats ( j ) else rst % coefficients ( i ) = nan rst % stats ( i )% confidence_interval = nan rst % stats ( i )% probability = nan rst % stats ( i )% standard_error = nan rst % stats ( i )% t_statistic = nan end if end do end function ! ------------------------------------------------------------------------------ subroutine doe_design_matrix ( nway , x , map , c ) !! This is an internal routine used to construct the design matrix for !! the DOE model of the following form: !! !!  Y = \\beta_{0} + \\sum_{i=1}&#94;{n} \\beta_{i} X_{i} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1 \\\\ i \\neq j}&#94;{n} \\beta_{ij} X_{i} X_{j} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1}&#94;{n} \\sum_{k=1 \\\\ i \\neq j \\neq k}&#94;{n} \\beta_{ijk} X_{i} !! X_{j} X_{k} + ...  !! !! Up to a 3-way model is allowed. !! !! No error checking is provided.  It is assumed the arrays are sized !! correctly. integer ( int32 ), intent ( in ) :: nway real ( real64 ), intent ( in ), dimension (:,:) :: x logical , intent ( in ), dimension (:) :: map real ( real64 ), intent ( out ), dimension (:,:) :: c ! Local Variables integer ( int32 ) :: i , j , k , jj , kk , m , n , np ! Determine the number of model parameters np = 0 do i = 1 , size ( map ) if ( map ( i )) np = np + 1 end do ! Additional Initialization m = size ( x , 1 ) n = size ( x , 2 ) ! DC Term if ( map ( 1 )) then c (:, 1 ) = 1.0d0 jj = 2 else jj = 1 end if ! Main Effect kk = 1 if ( nway >= 1 ) then do i = 1 , n kk = kk + 1 if (. not . map ( kk )) cycle c (:, jj ) = x (:, i ) jj = jj + 1 end do end if ! Two-Way if ( nway >= 2 ) then do i = 1 , n do j = 1 , n if ( i == j ) cycle kk = kk + 1 if (. not . map ( kk )) cycle c (:, jj ) = x (:, i ) * x (:, j ) jj = jj + 1 end do end do end if ! Three-Way if ( nway >= 3 ) then do i = 1 , n do j = 1 , n do k = 1 , n if ( i == j . and . j == k ) cycle kk = kk + 1 if (. not . map ( kk )) cycle c (:, jj ) = x (:, i ) * x (:, j ) * x (:, k ) jj = jj + 1 end do end do end do end if end subroutine ! ------------------------------------------------------------------------------ function doe_evaluate_model_1 ( nway , beta , x , map , err ) result ( rst ) !! Evaluates the model of the following form. !! !!  Y = \\beta_{0} + \\sum_{i=1}&#94;{n} \\beta_{i} X_{i} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1 \\\\ i \\neq j}&#94;{n} \\beta_{ij} X_{i} X_{j} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1}&#94;{n} \\sum_{k=1 \\\\ i \\neq j \\neq k}&#94;{n} \\beta_{ijk} X_{i} !! X_{j} X_{k} + ...  integer ( int32 ), intent ( in ) :: nway !! The number of interaction levels.  Currently, this algorithm supports !! a maximum of three-way interaction. real ( real64 ), intent ( in ), dimension (:) :: beta !! The model coefficients. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! at which to evaluate the model. logical , intent ( in ), optional , target , dimension (:) :: map !! An optional array of the same size as beta that can be used to !! eliminate a parameter from the model (false), or keep a parameter !! in the model (true).  If not supplied, all parameters will be assumed !! to be part of the model as if the array were filled with all true !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if beta and map are not properly sized !!      relative to one another. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. !! - FS_INVALID_INPUT_ERROR: Occurs if nway is less than 1 or greater !!      than 3. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting M-element array. ! Local Variables integer ( int32 ) :: m , n , nparam , flag logical , pointer , dimension (:) :: mapptr logical , allocatable , target , dimension (:) :: nmap class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( x , 1 ) n = size ( x , 2 ) ! Input Checking if ( nway < 1 . or . nway > 3 ) then call errmgr % report_error ( \"doe_evaluate_model_1\" , & \"The number of interaction levels must be between one and three.\" , & FS_INVALID_ARGUMENT_ERROR ) return end if nparam = 1 if ( nway >= 1 ) nparam = nparam + n if ( nway >= 2 ) nparam = nparam + n * ( n - 1 ) if ( nway >= 3 ) nparam = nparam + n * ( n ** 2 - 1 ) if ( size ( beta ) /= nparam ) then call report_array_size_error ( errmgr , \"doe_evaluate_model_1\" , \"beta\" , & nparam , size ( beta )) return end if ! Memory Allocations allocate ( rst ( m ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"doe_evaluate_model_1\" , flag ) return end if ! Set up the map parameters if ( present ( map )) then if ( size ( map ) /= nparam ) then call report_array_size_error ( errmgr , \"doe_evaluate_model_1\" , & \"map\" , nparam , size ( map )) return end if mapptr => map else allocate ( nmap ( nparam ), stat = flag , source = . true .) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"doe_evaluate_model_1\" , flag ) return end if mapptr => nmap end if ! Process call doe_eval_engine ( nway , beta , x , mapptr , rst ) end function ! ---------- function doe_evaluate_model_2 ( mdl , x , err ) result ( rst ) !! Evaluates the model of the following form. !! !!  Y = \\beta_{0} + \\sum_{i=1}&#94;{n} \\beta_{i} X_{i} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1 \\\\ i \\neq j}&#94;{n} \\beta_{ij} X_{i} X_{j} + \\sum_{i=1}&#94;{n} !! \\sum_{j=1}&#94;{n} \\sum_{k=1 \\\\ i \\neq j \\neq k}&#94;{n} \\beta_{ijk} X_{i} !! X_{j} X_{k} + ...  class ( doe_model ), intent ( in ) :: mdl !! The model to evaluate. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! at which to evaluate the model. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting M-element array. ! Process rst = doe_evaluate_model_1 ( mdl % nway , mdl % coefficients , x , mdl % map , err ) end function ! ---------- subroutine doe_eval_engine ( nway , beta , x , map , y ) ! Driver routine for \"doe_evaluate_model\" that performs the actual ! calculations but forgoes any error checking.  This should not be exposed ! as part of the public API. integer ( int32 ), intent ( in ) :: nway real ( real64 ), intent ( in ), dimension (:) :: beta real ( real64 ), intent ( in ), dimension (:,:) :: x logical , intent ( in ), dimension (:) :: map real ( real64 ), intent ( out ), dimension (:) :: y ! Local Variables integer ( int32 ) :: i1 , i2 , n ! Initialization n = size ( x , 2 ) if ( map ( 1 )) then y = beta ( 1 ) else y = 0.0d0 end if ! Process if ( nway >= 1 ) then i1 = 2 i2 = i1 + n - 1 call doe_eval_1 ( beta ( i1 : i2 ), x , map ( i1 : i2 ), y ) end if if ( nway >= 2 ) then i1 = i2 + 1 i2 = i1 + n * ( n - 1 ) - 1 call doe_eval_2 ( beta ( i1 : i2 ), x , map ( i1 : i2 ), y ) end if if ( nway >= 3 ) then i1 = i2 + 1 i2 = i1 + n * ( n ** 2 - 1 ) - 1 call doe_eval_3 ( beta ( i1 : i2 ), x , map ( i1 : i2 ), y ) end if end subroutine ! ---------- subroutine doe_eval_1 ( beta , x , map , y ) !! Evaluates the main effect term. !! !!  Y = Y + /sum_{i=1}&#94;{n} \\beta_{i} X_{i}  real ( real64 ), intent ( in ), dimension (:) :: beta !! The model coefficients for just this portion of the model. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! at which to evaluate the model. logical , intent ( in ), dimension (:) :: map !! The usage map corresponding to the model coefficients for just this !! portion of the model. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, an M-element array containing the existing portion of the !! model.  On output, this array is updated to include the main effects. ! Local Variables integer ( int32 ) :: i , n ! Initialization n = size ( x , 2 ) ! Process do i = 1 , n if (. not . map ( i )) cycle y = y + beta ( i ) * x (:, i ) end do end subroutine ! ---------- subroutine doe_eval_2 ( beta , x , map , y ) !! Evaluates the two-way interaction term. !! !!  Y = Y + /sum_{i=1}&#94;{n} /sum_{j=1 // i /neq j}&#94;{n} \\beta_{i} X_{i} !! X_{j}  real ( real64 ), intent ( in ), dimension (:) :: beta !! The model coefficients for just this portion of the model. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! at which to evaluate the model. logical , intent ( in ), dimension (:) :: map !! The usage map corresponding to the model coefficients for just this !! portion of the model. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, an M-element array containing the existing portion of the !! model.  On output, this array is updated to include the two-way !! interactions. ! Local Variables integer ( int32 ) :: i , j , k , n ! Initialization n = size ( x , 2 ) ! Process k = 0 do i = 1 , n do j = 1 , n if ( i == j ) cycle k = k + 1 if (. not . map ( k )) cycle y = y + beta ( k ) * x (:, i ) * x (:, j ) end do end do end subroutine ! ---------- subroutine doe_eval_3 ( beta , x , map , y ) !! Evaluates the three-way interaction term. !! !!  Y = Y + /sum_{i=1}&#94;{n} /sum_{j=1 // i /neq j}&#94;{n} \\beta_{i} X_{i} !! X_{j}  real ( real64 ), intent ( in ), dimension (:) :: beta !! The model coefficients for just this portion of the model. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The M-by-N matrix containing the M values of each of the N factors !! at which to evaluate the model. logical , intent ( in ), dimension (:) :: map !! The usage map corresponding to the model coefficients for just this !! portion of the model. real ( real64 ), intent ( inout ), dimension (:) :: y !! On input, an M-element array containing the existing portion of the !! model.  On output, this array is updated to include the three-way !! interactions. ! Local Variables integer ( int32 ) :: i , j , k , ii , n ! Initialization n = size ( x , 2 ) ! Process ii = 0 do i = 1 , n do j = 1 , n do k = 1 , n if ( i == j . and . j == k ) cycle ii = ii + 1 if (. not . map ( ii )) cycle y = y + beta ( ii ) * x (:, i ) * x (:, j ) * x (:, k ) end do end do end do end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_experimental_design.f90.html"},{"title":"fstats_helper_routines.f90 – FSTATS","text":"Contents Modules fstats_helper_routines Source Code fstats_helper_routines.f90 Source Code module fstats_helper_routines use iso_fortran_env implicit none private public :: difference public :: factorial contains ! ------------------------------------------------------------------------------ pure function difference ( x ) result ( rst ) !! Computes the difference between elements in an array. real ( real64 ), intent ( in ), dimension (:) :: x !! The N-element array on which to operate. real ( real64 ), allocatable , dimension (:) :: rst !! The (N-1)-element array containing the differences between adjacent !! elements. ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( x ) allocate ( rst ( n - 1 )) do i = 1 , n - 1 rst ( i ) = x ( i + 1 ) - x ( i ) end do end function ! ------------------------------------------------------------------------------ pure elemental function factorial ( x ) result ( rst ) !! Computes the factorial of X. real ( real64 ), intent ( in ) :: x !! The value whose factorial is to be computed. real ( real64 ) :: rst !! The result. rst = gamma ( x + 1.0d0 ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_helper_routines.f90.html"},{"title":"fstats_hypothesis.f90 – FSTATS","text":"Contents Modules fstats_hypothesis Source Code fstats_hypothesis.f90 Source Code module fstats_hypothesis use iso_fortran_env use ieee_arithmetic use fstats_errors use fstats_special_functions use fstats_distributions use fstats_descriptive_statistics use fstats_types private public :: confidence_interval public :: t_test_equal_variance public :: t_test_unequal_variance public :: t_test_paired public :: f_test public :: bartletts_test public :: levenes_test public :: sample_size interface confidence_interval !! Computes the confidence interval for the specified distribution. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Confidence_interval) module procedure :: confidence_interval_scalar module procedure :: confidence_interval_array end interface contains ! ------------------------------------------------------------------------------ pure function confidence_interval_scalar ( dist , alpha , s , n ) result ( rst ) !! Computes the confidence interval for the specified distribution. class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real64 ), intent ( in ) :: alpha !! The probability value of interest.  For instance, use a value of 0.05 !! for a confidence level of 95%. real ( real64 ), intent ( in ) :: s !! The sample standard deviation. integer ( int32 ), intent ( in ) :: n !! The number of samples in the data set. real ( real64 ) :: rst !! The result. ! Local Variables real ( real64 ) :: x , dn ! Process dn = real ( n , real64 ) x = 1.0d0 - 0.5d0 * alpha rst = dist % standardized_variable ( x ) rst = rst * s / sqrt ( dn ) end function ! ------------------------------------------------------------------------------ pure function confidence_interval_array ( dist , alpha , x ) result ( rst ) !! Computes the confidence interval for the specified distribution. class ( distribution ), intent ( in ) :: dist !! The distribution object defining the probability distribution !! to establish the confidence level. real ( real64 ), intent ( in ) :: alpha !! The probability value of interest.  For instance, use a value of 0.05 !! for a confidence level of 95%. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the data to analyze. real ( real64 ) :: rst !! The result. ! Process rst = confidence_interval ( dist , alpha , standard_deviation ( x ), size ( x )) end function ! ------------------------------------------------------------------------------ subroutine t_test_equal_variance ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed equivalent variances. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables real ( real64 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = n1 + n2 - two sv = (( n1 - one ) * v1 + ( n2 - one ) * v2 ) / dof stat = abs ( m1 - m2 ) / sqrt ( sv * ( one / real ( n1 ) + one / real ( n2 ))) ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine t_test_unequal_variance ( x1 , x2 , stat , p , dof ) !! Computes the 2-tailed Student's T-Test for two data sets of !! assumed non-equivalent variances. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. ! Parameters real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables real ( real64 ) :: v1 , v2 , m1 , m2 , sv , a , b , x integer ( int32 ) :: n1 , n2 ! Compute the T-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = ( v1 / real ( n1 ) + v2 / real ( n2 )) ** 2 / (( v1 / n1 ) ** 2 / ( n1 - one ) + & ( v2 / n2 ) ** 2 / ( n2 - one )) sv = sqrt ( v1 / n1 + v2 / n2 ) stat = ( m1 - m2 ) / sv ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine t_test_paired ( x1 , x2 , stat , p , dof , err ) !! Computes the 2-tailed Student's T-Test for two paired data sets. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Student%27s_t-test) real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An N-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The Student-'s T-Test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from  two underlying populations that !! have the same mean. real ( real64 ), intent ( out ) :: dof !! The degrees of freedom. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x1 and x2 are not the same !!   length. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr real ( real64 ) :: v1 , v2 , m1 , m2 , sd , cov , a , b , x integer ( int32 ) :: i , n1 , n2 , n ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n1 = size ( x1 ) n2 = size ( x2 ) n = min ( n1 , n2 ) ! Input Checking if ( n1 /= n2 ) then call report_arrays_not_same_size_error ( errmgr , \"t_test_paired_real64\" , & \"X1\" , \"X2\" , n1 , n2 ) return end if ! Compute the T-statistic m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) dof = real ( n1 ) - one cov = zero do i = 1 , n cov = cov + ( x1 ( i ) - m1 ) * ( x2 ( i ) - m2 ) end do cov = cov / dof sd = sqrt (( v1 + v2 - two * cov ) / n ) stat = ( m1 - m2 ) / sd ! Compute the probability a = half * dof b = half x = dof / ( dof + stat ** 2 ) p = regularized_beta ( a , b , x ) end subroutine ! ------------------------------------------------------------------------------ subroutine f_test ( x1 , x2 , stat , p , dof1 , dof2 ) !! Computes the F-test and returns the probability (two-tailed) that !! the variances of two data sets are not significantly different. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/F-test) real ( real64 ), intent ( in ) :: x1 (:) !! An N-element array containing the first data set. real ( real64 ), intent ( in ) :: x2 (:) !! An M-element array containing the second data set. real ( real64 ), intent ( out ) :: stat !! The F-statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the two samples are likely to !! have come from the two underlying populations that !! have the same variance. real ( real64 ), intent ( out ) :: dof1 !! A measure of the degrees of freedom. real ( real64 ), intent ( out ) :: dof2 !! A measure of the degrees of freedom. ! Parameters real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 ! Local Variables integer ( int32 ) :: n1 , n2 real ( real64 ) :: v1 , v2 , m1 , m2 type ( f_distribution ) :: dist ! Compute the F-statistic n1 = size ( x1 ) n2 = size ( x2 ) m1 = mean ( x1 ) m2 = mean ( x2 ) v1 = variance ( x1 ) v2 = variance ( x2 ) if ( v1 > v2 ) then stat = v1 / v2 dof1 = n1 - one dof2 = n2 - one else stat = v2 / v1 dof1 = n2 - one dof2 = n1 - one end if dist % d1 = dof1 dist % d2 = dof2 p = two * ( one - dist % cdf ( stat )) ! 2x because this is a two-tailed estimate if ( p > one ) p = two - p end subroutine ! ------------------------------------------------------------------------------ subroutine bartletts_test ( x , stat , p ) !! Computes Bartlett's test statistic and associated probability. !! !! The statistic is calculated as follows. !! !!  \\chi&#94;{2} = \\frac{(N - k) \\ln(S_{p}&#94;{2}) \\sum_{i = 1}&#94;{k} !! \\left(n_{i} - 1 \\right) \\ln(S_{i}&#94;{2})}{1 + !! \\frac{1}{3 \\left( k - 1 \\right)} \\left( \\sum_{i = 1}&#94;{k} !! \\left( \\frac{1}{n_{i} - 1} \\right) - \\frac{1}{N - k} \\right)}  !! !! Where  N = \\sum_{i = 1}&#94;{k} n_{i}  and  S_{p}&#94;{2}  is the pooled !! variance. !! !! The probability is calculated as the right-tail probability of the !! chi-squared distribution. !! !! Bartlett's test is most relevant for distributions showing strong !! normality.  For distributions lacking strong normality, consider !! Levene's test instead. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Bartlett%27s_test) type ( array_container ), intent ( in ), dimension (:) :: x !! The arrays of data to analyze. real ( real64 ), intent ( out ) :: stat !! The Bartlett's test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the variances of each data set are !! equivalent.  A low p-value, less than some significance level, !! indicates a non-equivalance of variances. ! Local Variables integer ( int32 ) :: i , n , k , ni real ( real64 ) :: si , sp , numer , denom type ( chi_squared_distribution ) :: dist ! Initialization k = size ( x ) n = 0 do i = 1 , k n = n + size ( x ( i )% x ) end do ! Compute the statistic n = 0 sp = 0.0d0 numer = 0.0d0 denom = 0.0d0 do i = 1 , k ni = size ( x ( i )% x ) n = n + ni si = variance ( x ( i )% x ) sp = sp + ( ni - 1.0d0 ) * si numer = numer + ( ni - 1.0d0 ) * log ( variance ( x ( i )% x )) denom = denom + 1.0d0 / ( ni - 1.0d0 ) end do sp = sp / real ( n - k , real64 ) stat = (( n - k ) * log ( sp ) - numer ) / & ( 1.0d0 + ( 1.0d0 / ( 3.0d0 * k - 3.0d0 )) * & ( denom - 1.0d0 / real ( n - k , real64 ))) ! Compute the p-value dist % dof = k - 1 p = 1.0d0 - dist % cdf ( stat ) end subroutine ! ------------------------------------------------------------------------------ subroutine levenes_test ( x , stat , p , err ) !! Computes Levene's test statistic and associated probability. !! !! The statistic is calculated as follows. !!  W = \\frac{N - k}{k - 1} \\frac{ \\sum_{i = 1}&#94;{k} N_{i} \\left( Z_{i.} - !! Z{..} \\right)&#94;{2}}{ \\sum_{i = 1}&#94;{k} \\sum_{j = 1}&#94;{n_{i}} \\left( Z_{ij} - !! Z_{i.} \\right)&#94;{2} }  !! !! Where: !!  Z_{ij} = |X_{ij} - \\overline{X_{i.}}|  !!  Z_{i.} = \\frac{1}{n_{i}} \\sum_{j = 1}&#94;{n_{i}} Z_{ij}  !!  Z_{..} = \\frac{1}{N} \\sum_{i = 1}&#94;{k} \\sum_{j = 1}&#94;{n_{i}} Z_{ij}  !! !! As the test statistic is approximately F-distributed, the F-distribution !! is used to calculate the probability term. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Levene%27s_test) type ( array_container ), intent ( in ), dimension (:) :: x !! The arrays of data to analyze. real ( real64 ), intent ( out ) :: stat !! The Bartlett's test statistic. real ( real64 ), intent ( out ) :: p !! The probability value that the variances of each data set are !! equivalent.  A low p-value, less than some significance level, !! indicates a non-equivalance of variances. class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: i , j , k , n , ni , flag real ( real64 ) :: numer , denom , inner , yi , z , zij real ( real64 ), allocatable , dimension (:) :: y , zt , zi type ( f_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if k = size ( x ) ! Local Memory Allocations allocate ( y ( k ), zi ( k ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"levenes_test\" , flag ) return end if ! Compute the total mean z = 0.0d0 n = 0 do i = 1 , k ni = size ( x ( i )% x ) n = n + ni y ( i ) = mean ( x ( i )% x ) zt = abs ( x ( i )% x - y ( i )) zi ( i ) = mean ( zt ) z = z + zi ( i ) * ni end do z = z / n ! Process numer = 0.0d0 denom = 0.0d0 do i = 1 , k ni = size ( x ( i )% x ) yi = y ( i ) numer = numer + ni * ( zi ( i ) - z ) ** 2 inner = 0.0d0 do j = 1 , ni zij = abs ( x ( i )% x ( j ) - yi ) inner = inner + ( zij - zi ( i )) ** 2 end do denom = denom + inner end do stat = real (( N - k ) / ( k - 1 ), real64 ) * ( numer / denom ) dist % d1 = k - 1.0d0 dist % d2 = real ( n - k , real64 ) p = 1.0d0 - dist % cdf ( stat ) end subroutine ! ------------------------------------------------------------------------------ pure function sample_size ( dist , var , delta , bet , alpha ) result ( rst ) !! Estimates the sample size required to achieve an experiment with the !! desired power and significance levels to ascertain the desired !! difference in parameter. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Power_of_a_test) class ( distribution ), intent ( in ) :: dist !! The distribution to utilize as a measure. real ( real64 ), intent ( in ) :: var !! An estimate of the population variance. real ( real64 ), intent ( in ) :: delta !! The parameter difference that is desired. real ( real64 ), intent ( in ), optional :: bet !! The desired power level.  The default for this value is 0.2, for a !! power of 80%. real ( real64 ), intent ( in ), optional :: alpha !! The desired significance level.  The default for this value is 0.05 !! for a confidence level of 95%. real ( real64 ) :: rst !! The minimum sample size requried to achieve the desired experimental !! outcome. ! Local Variables real ( real64 ) :: a , b , za , zb ! Initialization if ( present ( bet )) then b = bet else b = 0.8d0 end if if ( present ( alpha )) then a = alpha else a = 0.05d0 end if za = dist % standardized_variable ( 1.0d0 - a / 2.0d0 ) zb = dist % standardized_variable ( b ) rst = 2.0d0 * ( za + zb ) ** 2 * var / ( delta ** 2 ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_hypothesis.f90.html"},{"title":"fstats_mcmc.f90 – FSTATS","text":"Contents Modules fstats_mcmc Source Code fstats_mcmc.f90 Source Code module fstats_mcmc use iso_fortran_env use fstats_distributions use fstats_sampling use ferror use fstats_errors use fstats_descriptive_statistics use fstats_types use fstats_regression use fstats_sampling implicit none private public :: metropolis_hastings type metropolis_hastings !! An implementation of the Metropolis-Hastings algorithm for the !! generation of a Markov chain.  This is a default implementation !! that allows sampling of normally distributed posterior distributions !! centered on zero with unit standard deviations.  Proposals are !! generated from a multivariate normal distribution with an identity !! covariance matrix and centered on zero.  To alter these sampling !! and target distributions simply create a new class inheriting from !! this class and override the appropriate routines. integer ( int32 ), private :: initial_iteration_estimate = 10000 !! An initial estimate at the number of allowed iterations. integer ( int32 ), private :: m_bufferSize = 0 !! The actual number of states (# of used rows) in the buffer. real ( real64 ), private , allocatable , dimension (:,:) :: m_buffer !! The buffer where each new state is stored as a row in the matrix. integer ( int32 ), private :: m_numVars = 0 !! The number of state variables. type ( multivariate_normal_distribution ), private :: m_propDist !! The proposal distribution from which to draw samples. logical , private :: m_propDistInitialized = . false . !! Set to true if the proposal distribution object has been !! initialized; else, false. integer ( int32 ), private :: m_accepted = 0 !! The number of accepted steps. contains procedure , public :: get_state_variable_count => mh_get_nvars procedure , public :: get_chain_length => mh_get_chain_length procedure , public :: push_new_state => mh_push procedure , public :: get_chain => mh_get_chain procedure , public :: generate_proposal => mh_proposal procedure , public :: compute_hastings_ratio => mh_hastings_ratio procedure , public :: target_distribution => mh_target procedure , public :: sample => mh_sample procedure , public :: reset => mh_clear_chain procedure , public :: on_acceptance => mh_on_success procedure , public :: on_rejection => mh_on_rejection generic , public :: initialize_proposal => mh_init_proposal_1 , & mh_init_proposal_2 procedure , public :: get_proposal_initialized => mh_get_is_prop_init procedure , public :: get_proposal_means => mh_get_prop_mean procedure , public :: set_proposal_means => mh_set_prop_mean procedure , public :: get_proposal_covariance => mh_get_prop_cov procedure , public :: set_proposal_covariance => mh_set_prop_cov procedure , public :: get_proposal_cholesky => mh_get_prop_chol_cov procedure , public :: evaluate_proposal_pdf => mh_eval_proposal procedure , public :: get_accepted_count => mh_get_num_accepted ! Private Routines procedure , private :: resize_buffer => mh_resize_buffer procedure , private :: get_buffer_length => mh_get_buffer_length procedure , private :: mh_init_proposal_1 procedure , private :: mh_init_proposal_2 end type contains ! ------------------------------------------------------------------------------ pure function mh_get_nvars ( this ) result ( rst ) !! Gets the number of state variables. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. integer ( int32 ) :: rst !! The number of state variables. rst = this % m_numVars end function ! ------------------------------------------------------------------------------ pure function mh_get_chain_length ( this ) result ( rst ) !! Gets the length of the chain (number of stored state variables). class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. integer ( int32 ) :: rst !! The chain length. rst = this % m_bufferSize end function ! ------------------------------------------------------------------------------ subroutine mh_resize_buffer ( this , err ) !! Resizes the buffer to accept more states. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. ! Local Variables integer ( int32 ) :: m , n , flag , mOld class ( errors ), pointer :: errmgr type ( errors ), target :: deferr real ( real64 ), allocatable , dimension (:,:) :: copy ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = this % initial_iteration_estimate n = this % get_state_variable_count () ! Is this the first time? if (. not . allocated ( this % m_buffer )) then allocate ( this % m_buffer ( m , n ), stat = flag ) if ( flag /= 0 ) go to 10 return end if ! If we're here, then we need to create a copy and go from there m = size ( this % m_buffer , 1 ) mOld = m allocate ( copy ( m , n ), stat = flag , source = this % m_buffer ) if ( flag /= 0 ) go to 10 deallocate ( this % m_buffer ) m = m + this % initial_iteration_estimate allocate ( this % m_buffer ( m , n ), stat = flag ) if ( flag /= 0 ) go to 10 this % m_buffer ( 1 : mOld ,:) = copy deallocate ( copy ) ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"mh_resize_buffer\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ pure function mh_get_buffer_length ( this ) result ( rst ) !! Gets the actual length of the buffer.  This value will likely exceed the !! actual number of items in the chain. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. integer ( int32 ) :: rst !! The actual buffer length. if ( allocated ( this % m_buffer )) then rst = size ( this % m_buffer , 1 ) else rst = 0 end if end function ! ------------------------------------------------------------------------------ subroutine mh_push ( this , x , err ) !! Pushes a new set of state variables onto the buffer. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: x !! The new N-element state array. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. ! Local Variables integer ( int32 ) :: n , n1 , nbuffer , nvars class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = this % get_chain_length () n1 = n + 1 nbuffer = this % get_buffer_length () nvars = size ( x ) ! If this is the first time, ensure the collection is initialized if ( this % get_state_variable_count () == 0 ) then this % m_numVars = nvars end if ! Input Checking if ( nvars /= this % get_state_variable_count ()) then call report_array_size_error ( errmgr , \"mh_push\" , \"x\" , & this % get_state_variable_count (), nvars ) return end if ! Resize the buffer, if necessary if ( n == 0 . or . n == nbuffer ) then call this % resize_buffer ( errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Store the new state this % m_buffer ( n1 ,:) = x this % m_bufferSize = this % m_bufferSize + 1 end subroutine ! ------------------------------------------------------------------------------ function mh_get_chain ( this , bin , err ) result ( rst ) !! Gets a copy of the stored Markov chain. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), optional :: bin !! An optional input allowing for a burn-in region.  The parameter !! represents the amount (percentage-based) of the overall chain to !! disregard as \"burn-in\" values.  The value shoud exist on [0, 1). !! The default value is 0 such that no values are disregarded. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting chain with each parameter represented by a column. ! Local Variables integer ( int32 ) :: npts , nvar , flag , nstart , n class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = this % get_chain_length () n = npts nvar = this % get_state_variable_count () if ( present ( bin )) then nstart = floor ( bin * npts ) npts = npts - nstart else nstart = 1 end if ! Process allocate ( rst ( npts , nvar ), stat = flag , & source = this % m_buffer ( nstart : n , 1 : nvar )) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mh_get_chain\" , flag ) return end if end function ! ------------------------------------------------------------------------------ function mh_proposal ( this , xc ) result ( rst ) !! Proposes a new sample set of variables.  The sample is generated by !! sampling a multivariate normal distribution. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The current set of variables. real ( real64 ), allocatable , dimension (:) :: rst !! The proposed set of variables. ! Sample from the distribution call this % m_propDist % set_means ( xc ) ! center the distribution at the current state rst = sample_normal_multivariate ( this % m_propDist ) end function ! ------------------------------------------------------------------------------ pure function mh_eval_proposal ( this , xc ) result ( rst ) !! Evaluates the proposal distribution PDF at the specified set of !! variables. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The array of variables to evaluate. real ( real64 ) :: rst !! The value of the PDF at xc. ! Process rst = this % m_propDist % pdf ( xc ) end function ! ------------------------------------------------------------------------------ function mh_hastings_ratio ( this , xc , xp ) result ( rst ) !! Evaluates the Hasting's ratio.  If the proposal distribution is !! symmetric, this ratio is unity; however, in the case of an asymmetric !! distribution this ratio is not ensured to be unity. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The current state vector. real ( real64 ), intent ( in ), dimension ( size ( xc )) :: xp !! The proposed state vector. real ( real64 ) :: rst !! The ratio. ! Local Variables real ( real64 ), allocatable , dimension (:) :: means real ( real64 ) :: q1 , q2 ! Initialization means = this % m_propDist % get_means () ! Process call this % m_propDist % set_means ( xc ) q1 = this % m_propDist % pdf ( xp ) call this % m_propDist % set_means ( xp ) q2 = this % m_propDist % pdf ( xc ) ! Restore the state of the object call this % m_propDist % set_means ( means ) ! Compute the ratio rst = q2 / q1 end function ! ------------------------------------------------------------------------------ function mh_target ( this , x ) result ( rst ) !! Returns the probability value from the target distribution at the !! specified state.  The user is expected to overload this routine to !! define the desired distribution.  The default behavior of this !! routine is to sample a multivariate normal distribution with a mean !! of zero and a variance of one (identity covariance matrix). class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: x !! The state vector. real ( real64 ) :: rst !! The value of the probability density function of the distribution !! being sampled. ! Local Variables integer ( int32 ) :: i , n real ( real64 ), allocatable , dimension (:) :: mu real ( real64 ), allocatable , dimension (:,:) :: sigma type ( multivariate_normal_distribution ) :: dist ! The default will be a multivariate normal distribution with an identity ! matrix for the covariance matrix n = size ( x ) allocate ( mu ( n ), sigma ( n , n ), source = 0.0d0 ) do i = 1 , n sigma ( i , i ) = 1.0d0 end do call dist % initialize ( mu , sigma ) rst = dist % pdf ( x ) end function ! ------------------------------------------------------------------------------ subroutine mh_sample ( this , xi , niter , err ) !! Samples the distribution using the Metropolis-Hastings algorithm. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: xi !! An N-element array containing initial starting values of the state !! variables. integer ( int32 ), intent ( in ), optional :: niter !! An optional input defining the number of iterations to take.  The !! default is 10,000. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. ! Local Variables integer ( int32 ) :: i , n , npts , flag real ( real64 ) :: r , pp , pc , a , a1 , a2 , alpha real ( real64 ), allocatable , dimension (:) :: xc , xp , means real ( real64 ), allocatable , dimension (:,:) :: sigma class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( niter )) then npts = niter else npts = this % initial_iteration_estimate end if n = size ( xi ) this % m_accepted = 0 ! Initialize the proposal distribution.  Use an identity matrix for the ! covariance matrix and assume a zero mean. if (. not . this % get_proposal_initialized ()) then call this % initialize_proposal ( n , err = errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Store the initial value call this % push_new_state ( xi , err = errmgr ) if ( errmgr % has_error_occurred ()) return this % m_accepted = 1 ! Iteration Process xc = xi pc = this % target_distribution ( xc ) do i = 2 , npts ! Create a proposal & evaluate it's PDF xp = this % generate_proposal ( xc ) pp = this % target_distribution ( xp ) ! Evaluate the probabilities a1 = this % compute_hastings_ratio ( xc , xp ) a2 = pp / pc alpha = min ( 1.0d0 , a1 * a2 ) ! Do we keep our current state or move to the new state? call random_number ( r ) if ( r <= alpha ) then ! Take the new value call this % push_new_state ( xp , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Update the values xc = xp pc = pp ! Log the success this % m_accepted = this % m_accepted + 1 ! Take additional actions on success??? call this % on_acceptance ( i , alpha , xc , xp , err = errmgr ) if ( errmgr % has_error_occurred ()) return else ! Keep our current estimate call this % push_new_state ( xc , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Take additional actions on failure??? call this % on_rejection ( i , alpha , xc , xp , err = errmgr ) if ( errmgr % has_error_occurred ()) return end if end do end subroutine ! ------------------------------------------------------------------------------ subroutine mh_clear_chain ( this ) !! Resets the object and clears out the buffer storing the chain values. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. ! Clear the buffer this % m_bufferSize = 0 this % m_numVars = 0 end subroutine ! ------------------------------------------------------------------------------ subroutine mh_on_success ( this , iter , alpha , xc , xp , err ) !! Currently, this routine does nothing and is a placeholder for the user !! that inherits this class to provide functionallity upon acceptance of !! a proposed value. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. integer ( int32 ), intent ( in ) :: iter !! The current iteration number. real ( real64 ), intent ( in ) :: alpha !! The proposal probabilty term used for acceptance criteria. real ( real64 ), intent ( in ), dimension (:) :: xc !! An N-element array containing the current state variables. real ( real64 ), intent ( in ), dimension ( size ( xc )) :: xp !! An N-element array containing the proposed state variables that !! were just accepted. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. end subroutine ! ------------------------------------------------------------------------------ subroutine mh_on_rejection ( this , iter , alpha , xc , xp , err ) !! Currently, this routine does nothing and is a placeholder for the user !! that inherits this class to provide functionallity upon rejection of !! a proposed value. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. integer ( int32 ), intent ( in ) :: iter !! The current iteration number. real ( real64 ), intent ( in ) :: alpha !! The proposal probabilty term used for acceptance criteria. real ( real64 ), intent ( in ), dimension (:) :: xc !! An N-element array containing the current state variables. real ( real64 ), intent ( in ), dimension ( size ( xc )) :: xp !! An N-element array containing the proposed state variables that !! were just rejected. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. end subroutine ! ------------------------------------------------------------------------------ subroutine mh_init_proposal_1 ( this , mu , sigma , err ) !! Initializes the multivariate normal distribution used to generate !! proposals. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: mu !! An N-element array containing the mean values for the distribution. real ( real64 ), intent ( in ), dimension (:,:) :: sigma !! An N-by-N covariance matrix for the distribution.  This matrix must !! be positive-definite. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Initialize the proposal distribution call this % m_propDist % initialize ( mu , sigma , err = errmgr ) if ( errmgr % has_error_occurred ()) return this % m_propDistInitialized = . true . end subroutine ! ------------------------------------------------------------------------------ subroutine mh_init_proposal_2 ( this , n , err ) !! Initializes the multivariate normal distribution to a mean of zero and !! a variance of one. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. integer ( int32 ), intent ( in ) :: n !! The number of state variables. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: i , flag real ( real64 ), allocatable , dimension (:) :: mu real ( real64 ), allocatable , dimension (:,:) :: sigma class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Process allocate ( mu ( n ), sigma ( n , n ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mh_init_proposal_2\" , flag ) return end if do i = 1 , n sigma ( i , i ) = 1.0d0 end do call this % m_propDist % initialize ( mu , sigma , err = errmgr ) if ( errmgr % has_error_occurred ()) return this % m_propDistInitialized = . true . end subroutine ! ------------------------------------------------------------------------------ pure function mh_get_is_prop_init ( this ) result ( rst ) !! Gets a value determining if the proposal distribution object has been !! initialized. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. logical :: rst !! Returns true if the object has been initialized; else, false. rst = this % m_propDistInitialized end function ! ------------------------------------------------------------------------------ pure function mh_get_prop_mean ( this ) result ( rst ) !! Gets the mean values of the proposal distribution. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. real ( real64 ), allocatable , dimension (:) :: rst !! An array containing the mean values. if ( this % get_proposal_initialized ()) then rst = this % m_propDist % get_means () else allocate ( rst ( 0 )) end if end function ! ------------------------------------------------------------------------------ subroutine mh_set_prop_mean ( this , x , err ) !! Sets the mean values of the proposal distribution. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:) :: x !! The updated mean values. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. if ( this % get_proposal_initialized ()) then call this % m_propDist % set_means ( x , err ) else call this % initialize_proposal ( size ( x ), err ) call this % m_propDist % set_means ( x , err ) end if end subroutine ! ------------------------------------------------------------------------------ pure function mh_get_prop_cov ( this ) result ( rst ) !! Gets the covariance matrix of the proposal distribution. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The covariance matrix. if ( this % get_proposal_initialized ()) then rst = this % m_propDist % get_covariance () else allocate ( rst ( 0 , 0 )) end if end function ! ------------------------------------------------------------------------------ subroutine mh_set_prop_cov ( this , x , err ) !! Sets the covariance matrix of the proposal distribution. class ( metropolis_hastings ), intent ( inout ) :: this !! The metropolis_hastings object. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The covariance matrix.  This matrix must be positive-definite. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: n , flag real ( real64 ), allocatable , dimension (:) :: mu class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Process n = size ( x , 1 ) if ( this % get_proposal_initialized ()) then mu = this % m_propDist % get_means () else allocate ( mu ( n ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mh_set_prop_cov\" , flag ) return end if end if call this % m_propDist % initialize ( mu , x , err = errmgr ) end subroutine ! ------------------------------------------------------------------------------ pure function mh_get_prop_chol_cov ( this ) result ( rst ) !! Gets the Cholesky-factored (lower-triangular) form of the proposal !! covariance matrix. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The Cholesky-factored form of the proposal covariance matrix store !! in lower-triangular form. if ( this % get_proposal_initialized ()) then rst = this % m_propDist % get_cholesky_factored_matrix () else allocate ( rst ( 0 , 0 )) end if end function ! ------------------------------------------------------------------------------ pure function mh_get_num_accepted ( this ) result ( rst ) !! Gets the number of accepted steps. class ( metropolis_hastings ), intent ( in ) :: this !! The metropolis_hastings object. integer ( int32 ) :: rst !! The number of accepted steps. rst = this % m_accepted end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_mcmc.f90.html"},{"title":"fstats_mcmc_fitting.f90 – FSTATS","text":"Contents Modules fstats_mcmc_fitting Source Code fstats_mcmc_fitting.f90 Source Code module fstats_mcmc_fitting use iso_fortran_env use ieee_arithmetic use fstats_mcmc use fstats_errors use ferror use fstats_regression use fstats_distributions use fstats_sampling use fstats_descriptive_statistics implicit none private public :: mcmc_regression type , extends ( metropolis_hastings ) :: mcmc_regression !! The mcmc_regression type extends the metropolis_hastings type to !! specifically target regression problems.  The problem is formulated !! such that the target distribution takes the form y \\sim !! N \\left( f(x), \\sigma&#94;{2} \\right) , where N is a normal !! distribution with f(x) as the mean and the model variance, !! \\sigma&#94;2 is determined by computing the variance for the current !! estimate of the model. real ( real64 ), public , allocatable , dimension (:) :: x !! The independent-variable data to fit. real ( real64 ), public , allocatable , dimension (:) :: y !! The dependent-variable data to fit. procedure ( regression_function ), pointer , nopass :: fcn !! The function to fit. real ( real64 ), allocatable , dimension (:) :: upper_limits !! An optional array that, if used, provides an upper limit to !! each parameter in the model.  If used, be sure this array is the !! same dimension as the parameter array.  If not used, leave this !! alone and no upper limits will be placed on the parameters. !! If used and the array is not sized correctly, it will be ignored. real ( real64 ), allocatable , dimension (:) :: lower_limits !! An optional array that, if used, provides a lower limit to !! each parameter in the model.  If used, be sure this array is the !! same dimension as the parameter array.  If not used, leave this !! alone and no lower limits will be placed on the parameters. !! If used and the array is not sized correctly, it will be ignored. ! ----- ! Private Workspace Arrays real ( real64 ), private , allocatable , dimension (:) :: m_f0 !! An N-element array used for containing the current function !! estimate (N = size(x)). real ( real64 ), private , allocatable , dimension (:) :: m_mean !! A NP-element array used to contain a running mean of each !! parameter. ! ----- ! Private Member Variables real ( real64 ), private :: m_dataVariance = 1.0d0 !! The variance within the data set itself. contains procedure , public :: generate_proposal => mr_proposal procedure , public :: likelihood => mr_likelihood procedure , public :: target_distribution => mr_target procedure , public :: covariance_matrix => mr_covariance procedure , public :: compute_fit_statistics => mr_calc_regression_stats procedure , public :: get_data_variance => mr_get_data_variance procedure , public :: set_data_variance => mr_set_data_variance procedure , public :: on_acceptance => mr_on_success procedure , public :: push_new_state => mr_push end type contains ! ------------------------------------------------------------------------------ function mr_proposal ( this , xc ) result ( rst ) !! Arguments class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The current model parameters. real ( real64 ), allocatable , dimension (:) :: rst !! The proposed set of model parameters. ! Local Variables integer ( int32 ) :: n ! Establish the parameter guess rst = this % metropolis_hastings % generate_proposal ( xc ) ! Apply limits? n = size ( xc ) if ( allocated ( this % upper_limits )) then if ( size ( this % upper_limits ) == n ) then rst = min ( this % upper_limits , rst ) end if end if if ( allocated ( this % lower_limits )) then if ( size ( this % lower_limits ) == n ) then rst = max ( this % lower_limits , rst ) end if end if end function ! ------------------------------------------------------------------------------ function mr_likelihood ( this , x ) result ( rst ) !! Estimates the likelihood of the model. !! !! The likelihood is computed as follows assuming \\sigma&#94;2 is known !! a priori. !!  L \\left( \\theta \\right) = \\prod_{i=1}&#94;{n} N \\left(y_{i} | f(x_{i}), !! \\sigma&#94;2 \\right)  class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: x !! The current set of model parameters. real ( real64 ) :: rst !! The likelihood value. ! Local Variables type ( normal_distribution ) :: dist integer ( int32 ) :: i , npts , ep real ( real64 ) :: p , temp logical :: stop ! Initialization npts = size ( this % x ) ! Evaluate the model given the current parameters if (. not . allocated ( this % m_f0 )) allocate ( this % m_f0 ( npts )) call this % fcn ( this % x , x , this % m_f0 , stop ) if ( stop ) return ! Evaluate the probibility distribution temp = 1.0d0 ep = 0 rst = 1.0d0 dist % standard_deviation = sqrt ( this % get_data_variance ()) do i = 1 , npts dist % mean_value = this % m_f0 ( i ) p = dist % pdf ( this % y ( i )) temp = p * temp if ( temp == 0.0d0 ) then rst = 0.0d0 return end if do while ( abs ( temp ) < 1.0d0 ) temp = 1.0d1 * temp ep = ep - 1 end do do while ( abs ( temp ) > 1.0d1 ) temp = 1.0d-1 * temp ep = ep + 1 end do end do rst = temp * ( 1.0d1 ) ** ep end function ! ------------------------------------------------------------------------------ ! https://scalismo.org/docs/Tutorials/tutorial14 function mr_target ( this , x ) result ( rst ) !! Returns the probability value from the target distribution given the !! current set of model parameters. !! !! The probability value is determined as follows, assuming f(x) !! is the function value. !!  \\prod_{i=1}&#94;{n} p \\left( y_{i} | \\theta, x_{i} \\right) = !! p \\left( \\theta, \\sigma&#94;2 \\right) !! \\prod_{i=1}&#94;{n} N \\left(y_{i} | f(x_{i}), \\sigma&#94;2 \\right) . class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: x !! The current set of model parameters. real ( real64 ) :: rst !! The value of the probability density function being sampled. ! Process rst = this % likelihood ( x ) * this % evaluate_proposal_pdf ( x ) end function ! ------------------------------------------------------------------------------ function mr_covariance ( this , xc , err ) result ( rst ) !! Computes the covariance matrix for the model given the specified model !! parameters. class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The current set of model parameters. class ( errors ), intent ( inout ), optional , target :: err !! The error handling object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The covariance matrix. ! Local Variables logical :: stop integer ( int32 ) :: m , n , flag real ( real64 ) :: nan real ( real64 ), allocatable , dimension (:,:) :: J class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( allocated ( this % x )) then m = size ( this % x ) else m = 0 end if n = size ( xc ) nan = ieee_value ( nan , ieee_quiet_nan ) allocate ( rst ( n , n ), source = nan , stat = flag ) if ( flag /= 0 ) go to 10 ! Quick return if ( m == 0 ) return ! Evaluate the Jacobian matrix allocate ( J ( m , n ), stat = flag ) if ( flag /= 0 ) go to 10 call jacobian ( this % fcn , this % x , xc , J , stop , err = errmgr ) if ( errmgr % has_error_occurred ()) return if ( stop ) return ! Compute the covariance matrix call covariance_matrix ( J , rst , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! End return ! Memory Error Handling 10 continue call report_memory_error ( errmgr , \"mr_covariance\" , flag ) return end function ! ------------------------------------------------------------------------------ function mr_calc_regression_stats ( this , xc , alpha , err ) result ( rst ) !! Calculates statistics for the quality of fit for the regression. class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: xc !! The model parameters.  Be sure to only include the model parameters. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence intervals. !! The default value is 0.05 such that a 95% confidence interval is !! calculated. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. type ( regression_statistics ), allocatable , dimension (:) :: rst !! The resulting statistics for each parameter. ! Local Variables logical :: stop integer ( int32 ) :: n , flag real ( real64 ), allocatable , dimension (:) :: resid real ( real64 ), allocatable , dimension (:,:) :: c class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Compute the covariance matrix c = this % covariance_matrix ( xc , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Evaluate the model to compute the residuals n = size ( this % x ) if (. not . allocated ( this % m_f0 )) then allocate ( this % m_f0 ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mr_calc_regression_stats\" , flag ) return end if end if call this % fcn ( this % x , xc , this % m_f0 , stop ) resid = this % m_f0 - this % y ! Compute the statistics rst = calculate_regression_statistics ( resid , xc , c , alpha = alpha , & err = errmgr ) if ( errmgr % has_error_occurred ()) return end function ! ------------------------------------------------------------------------------ pure function mr_get_data_variance ( this ) result ( rst ) !! Gets the variance of the observed data. class ( mcmc_regression ), intent ( in ) :: this !! The mcmc_regression object. real ( real64 ) :: rst !! The variance. rst = this % m_dataVariance end function ! ------------------------------------------------------------------------------ subroutine mr_set_data_variance ( this , x ) !! Sets the variance of the observed data. class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ) :: x !! The variance. this % m_dataVariance = x end subroutine ! ------------------------------------------------------------------------------ subroutine mr_on_success ( this , iter , alpha , xc , xp , err ) !! Updates the covariance matrix of the proposal distribution upon a !! successful step.  If overloaded, be sure to call the base method to !! retain the functionallity required to keep the covariance matrix !! up-to-date. class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. integer ( int32 ), intent ( in ) :: iter !! The current iteration number. real ( real64 ), intent ( in ) :: alpha !! The proposal probability term used for acceptance criteria. real ( real64 ), intent ( in ), dimension (:) :: xc !! The current model parameter estimates. real ( real64 ), intent ( in ), dimension ( size ( xc )) :: xp !! The recently accepted model parameter estimates. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: i , j , n , np real ( real64 ) :: nm1 , nm2 , ratio real ( real64 ), allocatable , dimension (:) :: delta real ( real64 ), allocatable , dimension (:,:) :: sig ! Updates the estimate of the covariance matrix by implementing Roberts & ! Rosenthals adaptive approach. ! ! Parameters: ! - xp: NP-by-1 array of the newest sampled points ! - xm: NP-by-1 array of the updated mean over all samples ! - sig: NP-by-NP old covariance matrix ! - n: # of samples drawn ! ! C = (n - 2) / (n - 1) * sig + matmul(xp - xm, transpose(xp - xm)) / (n - 1) np = size ( xc ) n = this % get_chain_length () if ( n == 1 . or . . not . allocated ( this % m_mean )) then ! No action is necessary return end if nm1 = n - 1.0d0 nm2 = n - 2.0d0 ratio = nm2 / nm1 delta = xp - this % m_mean sig = this % get_proposal_covariance () do j = 1 , np do i = 1 , np sig ( i , j ) = ratio * sig ( i , j ) + delta ( i ) * delta ( j ) / nm1 end do end do ! Update the covariance matrix call this % set_proposal_covariance ( sig , err = err ) end subroutine ! ------------------------------------------------------------------------------ subroutine mr_push ( this , x , err ) !! Pushes a new set of parameters onto the end of the chain buffer. class ( mcmc_regression ), intent ( inout ) :: this !! The mcmc_regression object. real ( real64 ), intent ( in ), dimension (:) :: x !! The new N-element state array. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: n , npts , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Push the item onto the stack using the base method call this % metropolis_hastings % push_new_state ( x , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Update the running average term n = size ( x ) npts = this % get_chain_length () if (. not . allocated ( this % m_mean )) then allocate ( this % m_mean ( n ), stat = flag , source = x ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"mr_push\" , flag ) return end if ! No more action is necessary - end here return end if ! Update the mean this % m_mean = ( npts * this % m_mean + x ) / ( npts + 1.0d0 ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_mcmc_fitting.f90.html"},{"title":"fstats_regression.f90 – FSTATS","text":"Contents Modules fstats_regression Source Code fstats_regression.f90 Source Code module fstats_regression use iso_fortran_env use linalg use fstats_errors use blas use ferror use fstats_descriptive_statistics use fstats_distributions use fstats_special_functions use fstats_hypothesis implicit none private public :: iteration_controls public :: convergence_info public :: lm_solver_options public :: regression_function public :: iteration_update public :: regression_statistics public :: r_squared public :: adjusted_r_squared public :: correlation public :: design_matrix public :: covariance_matrix public :: linear_least_squares public :: calculate_regression_statistics public :: jacobian public :: nonlinear_least_squares public :: FS_LEVENBERG_MARQUARDT_UPDATE public :: FS_QUADRATIC_UPDATE public :: FS_NIELSEN_UPDATE ! ****************************************************************************** ! CONSTANTS ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: FS_LEVENBERG_MARQUARDT_UPDATE = 1 integer ( int32 ), parameter :: FS_QUADRATIC_UPDATE = 2 integer ( int32 ), parameter :: FS_NIELSEN_UPDATE = 3 ! ****************************************************************************** ! TYPES ! ------------------------------------------------------------------------------ type regression_statistics !! A container for regression-related statistical information. real ( real64 ) :: standard_error !! The standard error for the model coefficient. !! !!  E_{s}(\\beta_{i}) = \\sqrt{\\sigma&#94;{2} C_{ii}}  real ( real64 ) :: t_statistic !! The T-statistic for the model coefficient. !! !!  t_o = \\frac{ \\beta_{i} }{E_{s}(\\beta_{i})}  real ( real64 ) :: probability !! The probability that the coefficient is not statistically !! important.  A statistically important coefficient will have a !! low probability (p-value), typically 0.05 or lower; however, a !! p-value of up to ~0.2 may be acceptable dependent upon the !! problem.  Typically any p-value larger than ~0.2 indicates the !! parameter is not statistically important for the model. !! !!  p = t_{|t_o|, df_{residual}}  real ( real64 ) :: confidence_interval !! The confidence interval for the parameter at the level !! determined by the regression process. !! !!  c = t_{\\alpha, df} E_{s}(\\beta_{i})  end type type iteration_controls !! Provides a collection of iteration control parameters. integer ( int32 ) :: max_iteration_count !! Defines the maximum number of iterations allowed. integer ( int32 ) :: max_function_evaluations !! Defines the maximum number of function evaluations allowed. real ( real64 ) :: gradient_tolerance !! Defines a tolerance on the gradient of the fitted function. real ( real64 ) :: change_in_solution_tolerance !! Defines a tolerance on the change in parameter values. real ( real64 ) :: residual_tolerance !! Defines a tolerance on the metric associated with the residual !! error. real ( real64 ) :: iteration_improvement_tolerance !! Defines a tolerance to ensure adequate improvement on each !! iteration. integer ( int32 ) :: max_iteration_between_updates !! Defines how many iterations can pass before a re-evaluation of !! the Jacobian matrix is forced. contains procedure , public :: set_to_default => lm_set_default_tolerances end type type convergence_info !! Provides information regarding convergence status. logical :: converge_on_gradient !! True if convergence on the gradient was achieved; else, false. real ( real64 ) :: gradient_value !! The value of the gradient test parameter. logical :: converge_on_solution_change !! True if convergence on the change in solution was achieved; else, !! false. real ( real64 ) :: solution_change_value !! The value of the change in solution parameter. logical :: converge_on_residual_parameter !! True if convergence on the residual error parameter was achieved; !! else, false. real ( real64 ) :: residual_value !! The value of the residual error parameter. logical :: reach_iteration_limit !! True if the solution did not converge in the allowed number of !! iterations. integer ( int32 ) :: iteration_count !! The iteration count. logical :: reach_function_evaluation_limit !! True if the solution did not converge in the allowed number of !! function evaluations. integer ( int32 ) :: function_evaluation_count !! The function evaluation count. logical :: user_requested_stop !! True if the user requested the stop; else, false. end type type lm_solver_options !! Options to control the Levenberg-Marquardt solver. integer ( int32 ) :: method !! The solver method to utilize. !! - FS_LEVENBERG_MARQUARDT_UPDATE: !! - FS_QUADRATIC_UPDATE: !! - FS_NIELSEN_UDPATE: real ( real64 ) :: finite_difference_step_size !! The step size used for the finite difference calculations of the !! Jacobian matrix. real ( real64 ) :: damping_increase_factor !! The factor to use when increasing the damping parameter. real ( real64 ) :: damping_decrease_factor !! The factor to use when decreasing the damping parameter. contains procedure , public :: set_to_default => lm_set_default_settings end type interface subroutine regression_function ( xdata , params , f , stop ) !! Defines the interface of a subroutine computing the function !! values at each of the N data points as part of a regression !! analysis. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: xdata !! An N-element array containing the N independent data points. real ( real64 ), intent ( in ), dimension (:) :: params !! An M-element array containing the M model parameters. real ( real64 ), intent ( out ), dimension (:) :: f !! An N-element array where the results of the N function !! evaluations will be written. logical , intent ( out ) :: stop !! A mechanism to force a stop to the iteration process.  If !! set to true, the iteration process will terminate.  If set !! to false, the iteration process will continue along as !! normal. end subroutine subroutine iteration_update ( iter , funvals , resid , params , step ) !! Defines a routine for providing updates about an iteration !! process. use iso_fortran_env , only : int32 , real64 integer ( int32 ), intent ( in ) :: iter !! The current iteration number. real ( real64 ), intent ( in ), dimension (:) :: funvals !! The function values. real ( real64 ), intent ( in ), dimension (:) :: resid !! The residuals. real ( real64 ), intent ( in ), dimension (:) :: params !! The model parameters. real ( real64 ), intent ( in ), dimension (:) :: step !! Step sizes for each parameter. end subroutine end interface contains ! ------------------------------------------------------------------------------ function r_squared ( x , xm , err ) result ( rst ) !! Computes the R-squared value for a data set. !! !! The R-squared value is computed by determining the sum of the squares !! of the residuals: !!  SS_{res} = \\Sigma \\left( y_i - f_i \\right)&#94;2  !! The total sum of the squares: !!  SS_{tot} = \\Sigma \\left( y_i - \\bar{y} \\right)&#94;2 . !! The R-squared value is then: !!  R&#94;2 = 1 - \\frac{SS_{res}}{SS_{tot}} . !! !! See Also: !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Coefficient_of_determination) real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real64 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the !!   same size. real ( real64 ) :: rst !! The result. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: esum , vt class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Check n = size ( x ) if ( size ( xm ) /= n ) then call report_array_size_error ( errmgr , \"r_squared_real64\" , \"XM\" , n , & size ( xm )) return end if ! Process esum = zero do i = 1 , n esum = esum + ( x ( i ) - xm ( i )) ** 2 end do vt = variance ( x ) * ( n - one ) rst = one - esum / vt end function ! ------------------------------------------------------------------------------ function adjusted_r_squared ( p , x , xm , err ) result ( rst ) !! Computes the adjusted R-squared value for a data set. !! !! The adjusted R-squared provides a mechanism for tempering the effects !! of extra explanatory variables on the traditional R-squared !! calculation.  It is computed by noting the sample size  n  and !! the number of variables  p . !!  \\bar{R}&#94;2 = 1 - \\left( 1 - R&#94;2 \\right) \\frac{n - 1}{n - p} . !! !! See Also: !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Coefficient_of_determination#Adjusted_R2) integer ( int32 ), intent ( in ) :: p !! The number of variables. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the dependent variables from !! the data set. real ( real64 ), intent ( in ) :: xm (:) !! An N-element array containing the corresponding modeled !! values. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings !! to the caller.  Possible warning and error codes are as !! follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if x and xm are not the !!   same size. real ( real64 ) :: rst !! The result. ! Local Variables integer ( int32 ) :: n real ( real64 ) :: r2 class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) ! Process r2 = r_squared ( x , xm , errmgr ) if ( errmgr % has_error_occurred ()) return rst = one - ( one - r2 ) * ( n - one ) / ( n - p - one ) end function ! ------------------------------------------------------------------------------ pure function correlation ( x , y ) result ( rst ) !! Computes the sample correlation coefficient (an estimate to the !! population Pearson correlation) as follows. !! !!  r_{xy} = \\frac{cov(x, y)}{s_{x} s_{y}} . !! !! Where,  s_{x}  &  s_{y}  are the sample standard deviations of !! x and y respectively. real ( real64 ), intent ( in ), dimension (:) :: x !! The first N-element data set. real ( real64 ), intent ( in ), dimension ( size ( x )) :: y !! The second N-element data set. real ( real64 ) :: rst !! The correlation coefficient. ! Process rst = covariance ( x , y ) / ( standard_deviation ( x ) * standard_deviation ( y )) end function ! ------------------------------------------------------------------------------ subroutine design_matrix ( order , intercept , x , c , err ) !! Computes the design matrix  X  for the linear !! least-squares regression problem of  X \\beta = y , where !!  X  is the matrix computed here,  \\beta  is !! the vector of coefficients to be determined, and  y  is the !! vector of measured dependent variables. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Linear_regression) !! - [Wikipedia](https://en.wikipedia.org/wiki/Vandermonde_matrix) !! - [Wikipedia](https://en.wikipedia.org/wiki/Design_matrix) integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be !! at least one (linear equation), but can be higher as desired. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed !! as part of the regression; else, false. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real64 ), intent ( out ) :: c (:,:) !! An N-by-K matrix where the results will be written.  K !! must equal order + 1 in the event intercept is true; !! however, if intercept is false, K must equal order. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not properly sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. ! Parameters real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , start , npts , ncols class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncols = order if ( intercept ) ncols = ncols + 1 ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"design_matrix\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( c , 1 ) /= npts . or . size ( c , 2 ) /= ncols ) then call report_matrix_size_error ( errmgr , \"design_matrix\" , & \"c\" , npts , ncols , size ( c , 1 ), size ( c , 2 )) return end if ! Process if ( intercept ) then c (:, 1 ) = one c (:, 2 ) = x start = 3 else c (:, 1 ) = x start = 2 end if if ( start >= ncols ) return do i = start , ncols c (:, i ) = c (:, i - 1 ) * x end do end subroutine ! ------------------------------------------------------------------------------ subroutine covariance_matrix ( x , c , err ) !! Computes the covariance matrix  C  where !!  C = \\left( X&#94;{T} X \\right)&#94;{-1}  and  X  is computed !! by design_matrix. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Covariance_matrix) !! - [Wikipedia - Regression](https://en.wikipedia.org/wiki/Linear_regression) real ( real64 ), intent ( in ) :: x (:,:) !! An M-by-N matrix containing the formatted independent data !!  matrix  X  as computed by design_matrix. real ( real64 ), intent ( out ) :: c (:,:) !! The N-by-N covariance matrix. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the matrices are not !!      sized correctly. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr integer ( int32 ) :: npts , ncoeffs , flag real ( real64 ), allocatable :: xtx (:,:) ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x , 1 ) ncoeffs = size ( x , 2 ) ! Input Checking if ( size ( c , 1 ) /= ncoeffs . or . size ( c , 2 ) /= ncoeffs ) then call report_matrix_size_error ( errmgr , \"covariance_matrix\" , & \"c\" , ncoeffs , ncoeffs , size ( c , 1 ), size ( c , 2 )) return end if ! Local Memory Allocation allocate ( xtx ( ncoeffs , ncoeffs ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"covariance_matrix\" , flag ) return end if ! Compute X**T * X call DGEMM ( \"T\" , \"N\" , ncoeffs , ncoeffs , npts , one , x , npts , x , npts , & zero , xtx , ncoeffs ) ! Compute the inverse of X**T * X to obtain the covariance matrix call mtx_pinverse ( xtx , c , err = errmgr ) if ( errmgr % has_error_occurred ()) return end subroutine ! ------------------------------------------------------------------------------ subroutine linear_least_squares ( order , intercept , x , y , coeffs , & ymod , resid , stats , alpha , err ) !! Computes a linear least-squares regression to fit a set of data. !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Linear_regression) !! - [SPC Excel Understanding Regression Statistics](https://www.spcforexcel.com/knowledge/root-cause-analysis/understanding-regression-statistics-part-1) integer ( int32 ), intent ( in ) :: order !! The order of the equation to fit.  This value must be at !! least one (linear equation), but can be higher as desired, !! as long as there is sufficient data. logical , intent ( in ) :: intercept !! Set to true if the intercept is being computed as part of !! the regression; else, false. real ( real64 ), intent ( in ) :: x (:) !! An N-element array containing the independent variable !! measurement points. real ( real64 ), intent ( in ) :: y (:) !! An N-element array containing the dependent variable !! measurement points. real ( real64 ), intent ( out ) :: coeffs (:) !! An ORDER+1 element array where the coefficients will be written. real ( real64 ), intent ( out ) :: ymod (:) !! An N-element array where the modeled data will be written. real ( real64 ), intent ( out ) :: resid (:) !! An N-element array where the residual error data will be !! written (modeled - actual). type ( regression_statistics ), intent ( out ), optional :: stats (:) !! An M-element array of regression_statistics items where !! M = ORDER + 1 when intercept is set to true; however, if !! intercept is set to false, M = ORDER. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      approriately sized. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , npts , ncols , ncoeffs , flag real ( real64 ) :: alph , var , df , ssr , talpha real ( real64 ), allocatable :: a (:,:), c (:,:), cxt (:,:) type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) ncoeffs = order + 1 ncols = order if ( intercept ) ncols = ncols + 1 alph = 0.05d0 if ( present ( alpha )) alph = alpha ! Input Check if ( order < 1 ) then call errmgr % report_error ( \"linear_least_squares\" , & \"The model order must be at least one.\" , FS_INVALID_INPUT_ERROR ) return end if if ( size ( y ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares\" , & \"y\" , npts , size ( y )) return end if if ( size ( coeffs ) /= ncoeffs ) then call report_array_size_error ( errmgr , \"linear_least_squares\" , & \"coeffs\" , ncoeffs , size ( coeffs )) return end if if ( size ( ymod ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares\" , & \"ymod\" , npts , size ( ymod )) return end if if ( size ( resid ) /= npts ) then call report_array_size_error ( errmgr , \"linear_least_squares\" , & \"resid\" , npts , size ( resid )) return end if if ( present ( stats )) then if ( size ( stats ) /= ncols ) then call report_array_size_error ( errmgr , & \"linear_least_squares\" , \"stats\" , ncols , size ( stats )) return end if end if ! Memory Allocation allocate ( a ( npts , ncols ), stat = flag ) if ( flag == 0 ) allocate ( c ( ncols , ncols ), stat = flag ) if ( flag == 0 ) allocate ( cxt ( ncols , npts ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"linear_least_squares\" , flag ) return end if ! Compute the coefficient matrix call design_matrix ( order , intercept , x , a , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the covariance matrix call covariance_matrix ( a , c , errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the coefficients (NCOLS-by-1) call DGEMM ( \"N\" , \"T\" , ncols , npts , ncols , one , c , ncols , a , npts , zero , & cxt , ncols ) ! C * X**T i = 2 coeffs ( 1 ) = zero if ( intercept ) i = 1 call DGEMM ( \"N\" , \"N\" , ncols , 1 , npts , one , cxt , ncols , y , npts , zero , & coeffs ( i :), ncols ) ! (C * X**T) * Y ! Evaluate the model and compute the residuals call DGEMM ( \"N\" , \"N\" , npts , 1 , ncols , one , a , npts , coeffs ( i :), & ncols , zero , ymod , npts ) resid = ymod - y ! If the user doesn't want the statistics calculations we can stop now if (. not . present ( stats )) return ! Start the process of computing statistics stats = calculate_regression_statistics ( resid , coeffs ( i :), c , alph , & errmgr ) end subroutine ! ------------------------------------------------------------------------------ function calculate_regression_statistics ( resid , params , c , alpha , err ) & result ( rst ) !! Computes statistics for the quality of fit for a regression !! model. real ( real64 ), intent ( in ) :: resid (:) !! An M-element array containing the model residual errors. real ( real64 ), intent ( in ) :: params (:) !! An N-element array containing the model parameters. real ( real64 ), intent ( in ) :: c (:,:) !! The N-by-N covariance matrix. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if c is not sized correctly. !! - FS_INVALID_INPUT_ERROR: Occurs if order is less than 1. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. type ( regression_statistics ), allocatable :: rst (:) !! A regression_statistics object containing the analysis results. ! Parameters real ( real64 ), parameter :: p05 = 0.05d0 real ( real64 ), parameter :: half = 0.5d0 real ( real64 ), parameter :: one = 1.0d0 ! Local Variables integer ( int32 ) :: i , m , n , dof , flag real ( real64 ) :: a , ssr , var , talpha type ( t_distribution ) :: dist class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Initialization m = size ( resid ) n = size ( params ) dof = m - n if ( present ( alpha )) then a = alpha else a = p05 end if allocate ( rst ( n ), stat = flag ) if ( flag /= 0 ) then end if ! Input Checking if ( size ( c , 1 ) /= n . or . size ( c , 2 ) /= n ) then end if ! Process ssr = norm2 ( resid ) ** 2 ! sum of the squares of the residual var = ssr / dof dist % dof = real ( dof , real64 ) talpha = confidence_interval ( dist , a , one , 1 ) do i = 1 , n rst ( i )% standard_error = sqrt ( var * c ( i , i )) rst ( i )% t_statistic = params ( i ) / rst ( i )% standard_error rst ( i )% probability = regularized_beta ( & half * dof , & half , & real ( dof , real64 ) / ( dof + ( rst ( i )% t_statistic ) ** 2 ) & ) rst ( i )% confidence_interval = talpha * rst ( i )% standard_error end do end function ! ------------------------------------------------------------------------------ subroutine jacobian ( fun , xdata , params , & jac , stop , f0 , f1 , step , err ) !! Computes the Jacobian matrix for a nonlinear regression problem. procedure ( regression_function ), intent ( in ), pointer :: fun !! A pointer to the regression_function to evaluate. real ( real64 ), intent ( in ) :: xdata (:) !! The M-element array containing x-coordinate data. real ( real64 ), intent ( in ) :: params (:) !! The N-element array containing the model parameters. real ( real64 ), intent ( out ) :: jac (:,:) !! The M-by-N matrix where the Jacobian will be written. logical , intent ( out ) :: stop !! A value that the user can set in fun forcing the !! evaluation process to stop prior to completion. real ( real64 ), intent ( in ), optional , target :: f0 (:) !! An optional M-element array containing the model values !!  using the current parameters as defined in m.  This input !! can be used to prevent the routine from performing a !! function evaluation at the model parameter state defined in !! params. real ( real64 ), intent ( out ), optional , target :: f1 (:) !! An optional M-element workspace array used for function !! evaluations. real ( real64 ), intent ( in ), optional :: step !! The differentiation step size.  The default is the square !! root of machine precision. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      properly sized. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. ! Local Variables real ( real64 ) :: h integer ( int32 ) :: m , n , flag , expected , actual real ( real64 ), pointer :: f1p (:), f0p (:) real ( real64 ), allocatable , target :: f1a (:), f0a (:), work (:) class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( step )) then h = step else h = sqrt ( epsilon ( h )) end if m = size ( xdata ) n = size ( params ) ! Input Size Checking if ( size ( jac , 1 ) /= m . or . size ( jac , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"jacobian\" , & \"JAC\" , m , n , size ( jac , 1 ), size ( jac , 2 )) return end if if ( present ( f0 )) then ! Check Size if ( size ( f0 ) /= m ) then call report_array_size_error ( errmgr , \"jacobian\" , & \"F0\" , m , size ( f0 )) return end if f0p ( 1 : m ) => f0 else ! Allocate space, and fill the array with the current function ! results allocate ( f0a ( m ), stat = flag ) if ( flag /= 0 ) go to 20 f0p ( 1 : m ) => f0a call fun ( xdata , params , f0p , stop ) if ( stop ) return end if if ( present ( f1 )) then ! Check Size if ( size ( f1 ) /= m ) then call report_array_size_error ( errmgr , \"jacobian\" , & \"F1\" , m , size ( f1 )) return end if f1p ( 1 : m ) => f1 else ! Allocate space allocate ( f1a ( m ), stat = flag ) if ( flag /= 0 ) go to 20 f1p ( 1 : m ) => f1a end if ! Allocate a workspace array the same size as params allocate ( work ( n ), stat = flag ) if ( flag /= 0 ) go to 20 ! Compute the Jacobian call jacobian_finite_diff ( fun , xdata , params , f0p , jac , f1p , & stop , h , work ) ! End return ! Memroy Allocation Error Handling 20 continue call report_memory_error ( errmgr , \"jacobian\" , flag ) return end subroutine ! ------------------------------------------------------------------------------ subroutine nonlinear_least_squares ( fun , x , y , params , ymod , & resid , weights , maxp , minp , stats , alpha , controls , settings , info , & status , cov , err ) !! Performs a nonlinear regression to fit a model using a version !! of the Levenberg-Marquardt algorithm. procedure ( regression_function ), intent ( in ), pointer :: fun !! A pointer to the regression_function to evaluate. real ( real64 ), intent ( in ) :: x (:) !! The M-element array containing independent data. real ( real64 ), intent ( in ) :: y (:) !! The M-element array containing dependent data. real ( real64 ), intent ( inout ) :: params (:) !! On input, the N-element array containing the initial estimate !! of the model parameters.  On output, the computed model !! parameters. real ( real64 ), intent ( out ) :: ymod (:) !! An M-element array where the modeled dependent data will !! be written. real ( real64 ), intent ( out ) :: resid (:) !! An M-element array where the model residuals will be !! written. real ( real64 ), intent ( in ), optional , target :: weights (:) !! An optional M-element array allowing the weighting of !! individual points. real ( real64 ), intent ( in ), optional , target :: maxp (:) !! An optional N-element array that can be used as upper limits !! on the parameter values.  If no upper limit is requested for !! a particular parameter, utilize a very large value.  The !! internal default is to utilize huge() as a value. real ( real64 ), intent ( in ), optional , target :: minp (:) !! An optional N-element array that can be used as lower limits !! on the parameter values.  If no lower limit is requested for !! a particalar parameter, utilize a very large magnitude, but !! negative, value.  The internal default is to utilize -huge() !! as a value. type ( regression_statistics ), intent ( out ), optional :: stats (:) !! An optional N-element array that, if supplied, will be used !! to return statistics about the fit for each parameter. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals.  The default value is 0.05 such that a 95% !! confidence interval is calculated. type ( iteration_controls ), intent ( in ), optional :: controls !! An optional input providing custom iteration controls. type ( lm_solver_options ), intent ( in ), optional :: settings !! An optional input providing custom settings for the solver. type ( convergence_info ), intent ( out ), optional , target :: info !! An optional output that can be used to gain information about !! the iterative solution and the nature of the convergence. procedure ( iteration_update ), intent ( in ), pointer , optional :: status !! An optional pointer to a routine that can be used to extract !! iteration information. real ( real64 ), intent ( out ), optional , dimension (:,:) :: cov !! An optional N-by-N matrix that, if supplied, will be used to return !! the covariance matrix. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      properly sized. !! !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation !!      error. !! !! - FS_UNDERDEFINED_PROBLEM_ERROR: Occurs if the problem posed !!      is underdetetermined (M < N). !! !! - FS_TOLERANCE_TOO_SMALL_ERROR: Occurs if any supplied !!      tolerances are too small to be practical. !! !! - FS_TOO_FEW_ITERATION_ERROR: Occurs if too few iterations !!      are allowed. ! Parameters real ( real64 ), parameter :: too_small = 1.0d-14 integer ( int32 ), parameter :: min_iter_count = 2 integer ( int32 ), parameter :: min_fun_count = 10 integer ( int32 ), parameter :: min_update_count = 1 ! Local Variables logical :: stop integer ( int32 ) :: m , n , actual , expected , flag real ( real64 ), pointer :: w (:), pmax (:), pmin (:) real ( real64 ), allocatable , target :: defaultWeights (:), maxparam (:), & minparam (:), JtWJ (:,:) type ( iteration_controls ) :: tol type ( lm_solver_options ) :: opt type ( convergence_info ) :: cInfo class ( errors ), pointer :: errmgr type ( errors ), target :: deferr type ( convergence_info ), target :: defaultinfo type ( convergence_info ), pointer :: inf ! Initialization stop = . false . m = size ( x ) n = size ( params ) if ( present ( info )) then inf => info else inf => defaultinfo end if if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( controls )) then tol = controls else call tol % set_to_default () end if if ( present ( settings )) then opt = settings else call opt % set_to_default () end if ! Input Checking if ( size ( y ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares\" , & \"y\" , m , size ( y )) return end if if ( size ( ymod ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares\" , & \"ymod\" , m , size ( ymod )) return end if if ( size ( resid ) /= m ) then call report_array_size_error ( errmgr , \"nonlinear_least_squares\" , & \"resid\" , m , size ( resid )) return end if if ( m < n ) then call report_underdefined_error ( errmgr , & \"nonlinear_least_squares\" , n , m ) return end if ! Tolerance Checking if ( tol % gradient_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares\" , & \"The gradient tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % change_in_solution_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares\" , & \"The change in solution tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % residual_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares\" , & \"The residual error tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if if ( tol % iteration_improvement_tolerance < too_small ) then call errmgr % report_error ( \"nonlinear_least_squares\" , & \"The iteration improvement tolerance was found to be too small.\" , & FS_TOLERANCE_TOO_SMALL_ERROR ) return end if ! Iteration Count Checking if ( tol % max_iteration_count < min_iter_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares\" , & \"Too few iterations were specified.\" , & min_iter_count ) return end if if ( tol % max_function_evaluations < min_fun_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares\" , & \"Too few function evaluations were specified.\" , & min_fun_count ) return end if if ( tol % max_iteration_between_updates < min_update_count ) then call report_iteration_count_error ( errmgr , & \"nonlinear_least_squares\" , & \"Too few iterations between updates were specified.\" , & min_update_count ) return end if ! Optional Array Arguments (weights, parameter limits, etc.) if ( present ( weights )) then if ( size ( weights ) < m ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares\" , \"weights\" , m , size ( weights )) return end if w ( 1 : m ) => weights ( 1 : m ) else allocate ( defaultWeights ( m ), source = 1.0d0 , stat = flag ) if ( flag /= 0 ) go to 50 w ( 1 : m ) => defaultWeights ( 1 : m ) end if if ( present ( maxp )) then if ( size ( maxp ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares\" , \"maxp\" , n , size ( maxp )) return end if pmax ( 1 : n ) => maxp ( 1 : n ) else allocate ( maxparam ( n ), source = huge ( 1.0d0 ), stat = flag ) if ( flag /= 0 ) go to 50 pmax ( 1 : n ) => maxparam ( 1 : n ) end if if ( present ( minp )) then if ( size ( minp ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares\" , \"minp\" , n , size ( minp )) return end if pmin ( 1 : n ) => minp ( 1 : n ) else allocate ( minparam ( n ), source = - huge ( 1.0d0 ), stat = flag ) if ( flag /= 0 ) go to 50 pmin ( 1 : n ) => minparam ( 1 : n ) end if ! Local Memory Allocations allocate ( JtWJ ( n , n ), stat = flag ) if ( flag /= 0 ) go to 50 ! Process call lm_solve ( fun , x , y , params , w , pmax , pmin , tol , opt , ymod , & resid , JtWJ , inf , stop , errmgr , status ) ! Compute the covariance matrix if ( present ( stats ) . or . present ( cov )) then call mtx_inverse ( JtWJ , err = errmgr ) if ( errmgr % has_error_occurred ()) return end if ! Statistical Parameters if ( present ( stats )) then if ( size ( stats ) /= n ) then call report_array_size_error ( errmgr , & \"nonlinear_least_squares\" , \"stats\" , n , size ( stats )) return end if ! Compute the statistics stats = calculate_regression_statistics ( resid , params , JtWJ , & alpha , errmgr ) end if ! Return the covariance matrix if ( present ( cov )) then if ( size ( cov , 1 ) /= n . or . size ( cov , 2 ) /= n ) then call report_matrix_size_error ( errmgr , \"nonlinear_least_squares\" , & \"cov\" , n , n , size ( cov , 1 ), size ( cov , 2 )) return end if cov = JtWJ end if ! End return ! Memory Error Handler 50 continue call report_memory_error ( errmgr , \"nonlinear_least_squares\" , flag ) return end subroutine ! ****************************************************************************** ! SETTINGS DEFAULTS ! ------------------------------------------------------------------------------ ! Sets up default tolerances. subroutine lm_set_default_tolerances ( x ) ! Arguments class ( iteration_controls ), intent ( inout ) :: x ! Set defaults x % max_iteration_count = 500 x % max_function_evaluations = 5000 x % max_iteration_between_updates = 10 x % gradient_tolerance = 1.0d-8 x % residual_tolerance = 0.5d-2 x % change_in_solution_tolerance = 1.0d-6 x % iteration_improvement_tolerance = 1.0d-1 end subroutine ! ------------------------------------------------------------------------------ ! Sets up default solver settings. subroutine lm_set_default_settings ( x ) ! Arguments class ( lm_solver_options ), intent ( inout ) :: x ! Set defaults x % method = FS_LEVENBERG_MARQUARDT_UPDATE x % finite_difference_step_size = sqrt ( epsilon ( 1.0d0 )) x % damping_increase_factor = 1 1.0d0 x % damping_decrease_factor = 9.0d0 end subroutine ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ ! Computes the Jacobian matrix via a forward difference. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - params: The model parameters (N-by-1) ! - f0: The current model estimate (M-by-1) ! - step: The differentiation step size ! ! Outputs: ! - jac: The Jacobian matrix (M-by-N) ! - f1: A workspace array for the model output (M-by-1) ! - stop: A flag allowing the user to terminate model execution ! - work: A workspace array for the model parameters (N-by-1) subroutine jacobian_finite_diff ( fun , xdata , params , f0 , jac , f1 , & stop , step , work ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), params (:) real ( real64 ), intent ( in ) :: f0 (:) real ( real64 ), intent ( out ) :: jac (:,:) real ( real64 ), intent ( out ) :: f1 (:), work (:) logical , intent ( out ) :: stop real ( real64 ), intent ( in ) :: step ! Local Variables integer ( int32 ) :: i , n ! Initialization n = size ( params ) ! Cycle over each column of the Jacobian and calculate the derivative ! via a forward difference scheme ! ! J(i,j) = df(i) / dx(j) work = params do i = 1 , n work ( i ) = work ( i ) + step call fun ( xdata , work , f1 , stop ) if ( stop ) return jac (:, i ) = ( f1 - f0 ) / step work ( i ) = params ( i ) end do end subroutine ! ------------------------------------------------------------------------------ ! Computes a rank-1 update to the Jacobian matrix ! ! Inputs: ! - pOld: previous set of parameters (N-by-1) ! - yOld: model evaluation at previous set of parameters (M-by-1) ! - jac: current Jacobian estimate (M-by-N) ! - p: current set of parameters (N-by-1) ! - y: model evaluation at current set of parameters (M-by-1) ! ! Outputs: ! - jac: updated Jacobian matrix (M-by-N) (dy * dp**T + J) ! - dp: p - pOld (N-by-1) ! - dy: (y - yOld - J * dp) / (dp' * dp) (M-by-1) subroutine broyden_update ( pOld , yOld , jac , p , y , dp , dy ) ! Arguments real ( real64 ), intent ( in ) :: pOld (:), yOld (:), p (:), y (:) real ( real64 ), intent ( inout ) :: jac (:,:) real ( real64 ), intent ( out ) :: dp (:), dy (:) ! Local Variables real ( real64 ) :: h2 ! Process dp = p - pOld h2 = dot_product ( dp , dp ) dy = y - yOld - matmul ( jac , dp ) dy = dy / h2 call rank1_update ( 1.0d0 , dy , dp , jac ) end subroutine ! ------------------------------------------------------------------------------ ! Updates the Levenberg-Marquardt matrix by either computing a new Jacobian ! matrix or performing a rank-1 update to the existing Jacobian matrix. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - pOld: previous set of parameters (N-by-1) ! - yOld: model evaluation at previous set of parameters (M-by-1) ! - dX2: The previous change in the Chi-squared criteria ! - jac: current Jacobian estimate (M-by-N) ! - p: current set of parameters (N-by-1) ! - weights: A weighting vector (M-by-1) ! - neval: Current number of function evaluations ! - update: Set to true to force an update of the Jacobian; else, set to !       false to let the program choose based upon the change in the !       Chi-squared parameter. ! - step: The differentiation step size ! ! Outputs: ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - JtWdy: linearized fitting vector (N-by-1) ! - X2: Updated Chi-squared criteria ! - yNew: model evaluated with parameters of p (M-by-1) ! - jac: updated Jacobian matrix (M-by-N) ! - neval: updated count of function evaluations ! - stop: A flag allowing the user to terminate model execution ! - work: A workspace array (N+M-by-1) ! - mwork: A workspace matrix (N-by-M) ! - update: Reset to false if a Jacobian evaluation was performed. subroutine lm_matrix ( fun , xdata , ydata , pOld , yOld , dX2 , jac , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , yNew , stop , work , mwork ) ! Arguments procedure ( regression_function ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), pOld (:), yOld (:), & p (:), weights (:) real ( real64 ), intent ( in ) :: dX2 , step real ( real64 ), intent ( inout ) :: jac (:,:) integer ( int32 ), intent ( inout ) :: neval logical , intent ( inout ) :: update real ( real64 ), intent ( out ) :: JtWJ (:,:), JtWdy (:) real ( real64 ), intent ( out ) :: X2 , mwork (:,:), yNew (:) logical , intent ( out ) :: stop real ( real64 ), intent ( out ), target :: work (:) ! Local Variables integer ( int32 ) :: m , n real ( real64 ), pointer :: w1 (:), w2 (:) ! Initialization m = size ( xdata ) n = size ( p ) w1 ( 1 : m ) => work ( 1 : m ) w2 ( 1 : n ) => work ( m + 1 : n + m ) ! Perform the next function evaluation call fun ( xdata , p , yNew , stop ) neval = neval + 1 if ( stop ) return ! Update or recompute the Jacobian matrix if ( dX2 > 0 . or . update ) then ! Recompute the Jacobian call jacobian_finite_diff ( fun , xdata , p , yNew , jac , w1 , & stop , step , w2 ) neval = neval + n if ( stop ) return update = . false . else ! Simply perform a rank-1 update to the Jacobian call broyden_update ( pOld , yOld , jac , p , yNew , w2 , w1 ) end if ! Update the Chi-squared estimate w1 = ydata - yNew X2 = dot_product ( w1 , w1 * weights ) ! Compute J**T * (W .* dY) w1 = w1 * weights call mtx_mult (. true ., 1.0d0 , jac , w1 , 0.0d0 , JtWdy ) ! Update the Hessian ! First: J**T * W = MWORK ! Second: (J**T * W) * J call diag_mtx_mult (. false ., . true ., 1.0d0 , weights , jac , 0.0d0 , mwork ) call mtx_mult (. false ., . false ., 1.0d0 , mwork , jac , 0.0d0 , JtWJ ) end subroutine ! ------------------------------------------------------------------------------ ! Performs a single iteration of the Levenberg-Marquardt algorithm. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - p: current set of parameters (N-by-1) ! - neval: current number of function evaluations ! - niter: current iteration number ! - update: set to 1 to use Marquardt's modification; else, ! - step: the differentiation step size ! - lambda: LM damping parameter ! - maxP: maximum limits on the parameters.  Use huge() or larger for no constraints (N-by-1) ! - minP: minimum limits on the parameters.  Use -huge() or smaller for no constraints (N-by-1) ! - weights: a weighting vector (M-by-1) ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - JtWdy: linearized fitting vector (N-by-1) ! ! Outputs: ! - JtWJ: overwritten LU factorization of the original matrix (N-by-N) ! - h: The new estimate of the change in parameter (N-by-1) ! - pNew: The new parameter estimates (N-by-1) ! - deltaY: The new difference between data and model (M-by-1) ! - yNew: model evaluated with parameters of pNew (M-by-1) ! - neval: updated count of function evaluations ! - niter: updated current iteration number ! - X2: updated Chi-squared criteria ! - stop: A flag allowing the user to terminate model execution ! - iwork: A workspace array (N-by-1) ! - err: An error handling mechanism subroutine lm_iter ( fun , xdata , ydata , p , neval , niter , update , lambda , & maxP , minP , weights , JtWJ , JtWdy , h , pNew , deltaY , yNew , X2 , X2Old , & alpha , stop , iwork , err , status ) ! Arguments procedure ( regression_function ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), p (:), maxP (:), & minP (:), weights (:), JtWdy (:) real ( real64 ), intent ( in ) :: lambda , X2Old integer ( int32 ), intent ( inout ) :: neval , niter integer ( int32 ), intent ( in ) :: update real ( real64 ), intent ( inout ) :: JtWJ (:,:) real ( real64 ), intent ( out ) :: h (:), pNew (:), deltaY (:), yNew (:) real ( real64 ), intent ( out ) :: X2 , alpha logical , intent ( out ) :: stop integer ( int32 ), intent ( out ) :: iwork (:) class ( errors ), intent ( inout ) :: err procedure ( iteration_update ), intent ( in ), pointer , optional :: status ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: dpJh ! Initialization n = size ( p ) ! Increment the iteration counter niter = niter + 1 ! Solve the linear system to determine the change in parameters ! A is N-by-N and is stored in JtWJ ! b is N-by-1 if ( update == FS_LEVENBERG_MARQUARDT_UPDATE ) then ! Compute: h = A \\ b ! A = J**T * W * J + lambda * diag(J**T * W * J) ! b = J**T * W * dy do i = 1 , n JtWJ ( i , i ) = JtWJ ( i , i ) * ( 1.0d0 + lambda ) h ( i ) = JtWdy ( i ) end do else ! Compute: h = A \\ b ! A = J**T * W * J + lambda * I ! b = J**T * W * dy do i = 1 , n JtWJ ( i , i ) = JtWJ ( i , i ) + lambda h ( i ) = JtWdy ( i ) end do end if call lu_factor ( JtWJ , iwork , err ) ! overwrites JtWJ with [L\\U] if ( err % has_error_occurred ()) return ! if JtWJ is singular call solve_lu ( JtWJ , iwork , h ) ! solution stored in h ! Compute the new attempted solution, and apply any constraints do i = 1 , n pNew ( i ) = min ( max ( minP ( i ), h ( i ) + p ( i )), maxP ( i )) end do ! Update the residual error call fun ( xdata , pNew , yNew , stop ) neval = neval + 1 deltaY = ydata - yNew if ( stop ) return ! Update the Chi-squared estimate X2 = dot_product ( deltaY , deltaY * weights ) ! Perform a quadratic line update in the H direction, if necessary if ( update == FS_QUADRATIC_UPDATE ) then dpJh = dot_product ( JtWdy , h ) alpha = abs ( dpJh / ( 0.5d0 * ( X2 - X2Old ) + 2.0d0 * dpJh )) h = alpha * h do i = 1 , n pNew ( i ) = min ( max ( minP ( i ), p ( i ) + h ( i )), maxP ( i )) end do call fun ( xdata , pNew , yNew , stop ) if ( stop ) return neval = neval + 1 deltaY = ydata - yNew X2 = dot_product ( deltaY , deltaY * weights ) end if ! Update the status of the iteration, if needed if ( present ( status )) then call status ( niter , yNew , deltaY , pNew , h ) end if end subroutine ! ------------------------------------------------------------------------------ ! A Levenberg-Marquardt solver. ! ! Inputs: ! - fun: The function to evaluate ! - xdata: The independent coordinate data to fit (M-by-1) ! - ydata: The dependent coordinate data to fit (M-by-1) ! - p: current set of parameters (N-by-1) ! - weights: a weighting vector (M-by-1) ! - maxP: maximum limits on the parameters.  Use huge() or larger for no constraints (N-by-1) ! - minP: minimum limits on the parameters.  Use -huge() or smaller for no constraints (N-by-1) ! - controls: an iteration_controls instance containing solution tolerances ! ! Outputs: ! - p: solution (N-by-1) ! - y: model results at p (M-by-1) ! - resid: residual (ydata - y) (M-by-1) ! - JtWJ: linearized Hessian matrix (inverse of the covariance matrix) (N-by-N) ! - opt: a convergence_info object containing information regarding !       convergence of the iteration ! - stop: A flag allowing the user to terminate model execution ! - err: An error handling object subroutine lm_solve ( fun , xdata , ydata , p , weights , maxP , minP , controls , & opt , y , resid , JtWJ , info , stop , err , status ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), weights (:), maxP (:), & minP (:) real ( real64 ), intent ( inout ) :: p (:) class ( iteration_controls ), intent ( in ) :: controls class ( lm_solver_options ), intent ( in ) :: opt real ( real64 ), intent ( out ) :: y (:), resid (:), JtWJ (:,:) class ( convergence_info ), intent ( out ) :: info logical , intent ( out ) :: stop class ( errors ), intent ( inout ) :: err procedure ( iteration_update ), intent ( in ), pointer , optional :: status ! Local Variables logical :: update integer ( int32 ) :: i , m , n , dof , flag , neval , niter , nupdate real ( real64 ) :: dX2 , X2 , X2Old , X2Try , lambda , alpha , nu , step real ( real64 ), allocatable :: pOld (:), yOld (:), J (:,:), JtWdy (:), & work (:), mwork (:,:), pTry (:), yTemp (:), JtWJc (:,:), h (:) integer ( int32 ), allocatable :: iwork (:) character ( len = :), allocatable :: errmsg ! Initialization update = . true . m = size ( xdata ) n = size ( p ) dof = m - n niter = 0 step = opt % finite_difference_step_size stop = . false . info % user_requested_stop = . false . nupdate = 0 ! Local Memory Allocation allocate ( pOld ( n ), source = 0.0d0 , stat = flag ) if ( flag == 0 ) allocate ( yOld ( m ), source = 0.0d0 , stat = flag ) if ( flag == 0 ) allocate ( J ( m , n ), stat = flag ) if ( flag == 0 ) allocate ( JtWdy ( n ), stat = flag ) if ( flag == 0 ) allocate ( work ( m + n ), stat = flag ) if ( flag == 0 ) allocate ( mwork ( n , m ), stat = flag ) if ( flag == 0 ) allocate ( pTry ( n ), stat = flag ) if ( flag == 0 ) allocate ( h ( n ), stat = flag ) if ( flag == 0 ) allocate ( yTemp ( m ), stat = flag ) if ( flag == 0 ) allocate ( JtWJc ( n , n ), stat = flag ) if ( flag == 0 ) allocate ( iwork ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Perform an initial function evaluation call fun ( xdata , p , y , stop ) neval = 1 ! Evaluate the problem matrices call lm_matrix ( fun , xdata , ydata , pOld , yOld , 1.0d0 , J , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , y , stop , work , mwork ) if ( stop ) go to 5 X2Old = X2 JtWJc = JtWJ ! Determine an initial value for lambda if ( opt % method == FS_LEVENBERG_MARQUARDT_UPDATE ) then lambda = 1.0d-2 else call extract_diagonal ( JtWJ , work ( 1 : n )) lambda = 1.0d-2 * maxval ( work ( 1 : n )) nu = 2.0d0 end if ! Main Loop main : do while ( niter < controls % max_iteration_count ) ! Compute the linear solution at the current solution estimate and ! update the new parameter estimates call lm_iter ( fun , xdata , ydata , p , neval , niter , opt % method , & lambda , maxP , minP , weights , JtWJc , JtWdy , h , pTry , resid , & yTemp , X2Try , X2Old , alpha , stop , iwork , err , status ) if ( stop ) go to 5 if ( err % has_error_occurred ()) return ! Update the Chi-squared estimate, update the damping parameter ! lambda, and, if necessary, update the matrices call lm_update ( fun , xdata , ydata , pOld , p , pTry , yOld , y , h , dX2 , & X2Old , X2 , X2Try , lambda , alpha , nu , JtWdy , JtWJ , J , weights , & niter , neval , update , step , work , mwork , controls , opt , stop ) if ( stop ) go to 5 JtWJc = JtWJ ! Determine the matrix update scheme nupdate = nupdate + 1 if ( opt % method == FS_QUADRATIC_UPDATE ) then update = mod ( niter , 2 * n ) > 0 else if ( nupdate >= controls % max_iteration_between_updates ) then update = . true . nupdate = 0 end if ! Test for convergence if ( lm_check_convergence ( controls , dof , resid , niter , neval , & JtWdy , h , p , X2 , info )) & then exit main end if end do main ! End return ! User Requested End 5 continue info % user_requested_stop = . true . return ! Memory Error Handling 10 continue allocate ( character ( len = 512 ) :: errmsg ) write ( errmsg , 100 ) \"Memory allocation error code \" , flag , \".\" call err % report_error ( \"lm_solve\" , & trim ( errmsg ), FS_MEMORY_ERROR ) return ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ ! subroutine lm_update ( fun , xdata , ydata , pOld , p , pTry , yOld , y , h , dX2 , & X2old , X2 , X2try , lambda , alpha , nu , JtWdy , JtWJ , J , weights , niter , & neval , update , step , work , mwork , controls , opt , stop ) ! Arguments procedure ( regression_function ), intent ( in ), pointer :: fun real ( real64 ), intent ( in ) :: xdata (:), ydata (:), X2try , h (:), step , & pTry (:), weights (:), alpha real ( real64 ), intent ( inout ) :: pOld (:), p (:), yOld (:), y (:), lambda , & JtWdy (:), dX2 , X2 , X2old , JtWJ (:,:), J (:,:), nu real ( real64 ), intent ( out ) :: work (:), mwork (:,:) integer ( int32 ), intent ( in ) :: niter integer ( int32 ), intent ( inout ) :: neval logical , intent ( inout ) :: update class ( iteration_controls ), intent ( in ) :: controls class ( lm_solver_options ), intent ( in ) :: opt logical , intent ( out ) :: stop ! Local Variables integer ( int32 ) :: n real ( real64 ) :: rho ! Initialization n = size ( p ) ! Process if ( opt % method == FS_LEVENBERG_MARQUARDT_UPDATE ) then call extract_diagonal ( JtWJ , work ( 1 : n )) work ( 1 : n ) = lambda * work ( 1 : n ) * h + JtWdy else work ( 1 : n ) = lambda * h + JtWdy end if rho = ( X2 - X2try ) / abs ( dot_product ( h , work ( 1 : n ))) if ( rho > controls % iteration_improvement_tolerance ) then ! Things are getting better at an acceptable rate dX2 = X2 - X2old X2old = X2 pOld = p yOld = y p = pTry ! Recompute the matrices call lm_matrix ( fun , xdata , ydata , pOld , yOld , dX2 , J , p , weights , & neval , update , step , JtWJ , JtWdy , X2 , y , stop , work , mwork ) if ( stop ) return ! Decrease lambda select case ( opt % method ) case ( FS_LEVENBERG_MARQUARDT_UPDATE ) lambda = max ( lambda / opt % damping_decrease_factor , 1.0d-7 ) case ( FS_QUADRATIC_UPDATE ) lambda = max ( lambda / ( 1.0d0 + alpha ), 1.0d-7 ) case ( FS_NIELSEN_UPDATE ) lambda = lambda * max ( 1.0d0 / 3.0d0 , & 1.0d0 - ( 2.0d0 * rho - 1.0d0 ** 3 )) nu = 2.0d0 end select else ! The iteration is not improving in a satisfactory manner X2 = X2old if ( mod ( niter , 2 * n ) /= 0 ) then call lm_matrix ( fun , xdata , ydata , pOld , yOld , - 1.0d0 , J , p , & weights , neval , update , step , JtWJ , JtWdy , dX2 , y , stop , & work , mwork ) if ( stop ) return end if ! Increase lambda select case ( opt % method ) case ( FS_LEVENBERG_MARQUARDT_UPDATE ) lambda = min ( lambda * opt % damping_increase_factor , 1.0d7 ) case ( FS_QUADRATIC_UPDATE ) lambda = lambda + abs (( X2try - X2 ) / 2.0d0 / alpha ) case ( FS_NIELSEN_UPDATE ) lambda = lambda * nu nu = 2.0d0 * nu end select end if end subroutine ! ------------------------------------------------------------------------------ ! Checks the Levenberg-Marquardt solution against the convergence criteria. ! ! Inputs: ! - controls: the solution controls and convergence criteria ! - dof: the statistical degrees of freedom of the system (M - N) ! - resid: the residual error (M-by-1) ! - niter: the number of iterations ! - neval: the number of function evaluations ! - JtWdy: linearized fitting vector (N-by-1) ! - h: the change in parameter (solution) values (N-by-1) ! - p: the parameter (solution) values (N-by-1) ! - X2: the Chi-squared estimate ! ! Outputs: ! - info: The convergence information. ! - rst: True if convergence was achieved; else, false. function lm_check_convergence ( controls , dof , resid , niter , neval , & JtWdy , h , p , X2 , info ) result ( rst ) ! Arguments class ( iteration_controls ), intent ( in ) :: controls real ( real64 ), intent ( in ) :: resid (:), JtWdy (:), h (:), p (:), X2 integer ( int32 ), intent ( in ) :: dof , niter , neval class ( convergence_info ), intent ( out ) :: info logical :: rst ! Initialization rst = . false . ! Iteration Checks info % iteration_count = niter if ( niter >= controls % max_iteration_count ) then info % reach_iteration_limit = . true . rst = . true . else info % reach_iteration_limit = . false . end if info % function_evaluation_count = neval if ( neval >= controls % max_function_evaluations ) then info % reach_function_evaluation_limit = . true . rst = . true . else info % reach_function_evaluation_limit = . false . end if info % gradient_value = maxval ( abs ( JtWdy )) if ( info % gradient_value < controls % gradient_tolerance . and . niter > 2 ) & then info % converge_on_gradient = . true . rst = . true . else info % converge_on_gradient = . false . end if info % solution_change_value = maxval ( abs ( h ) / ( abs ( p ) + 1.0d-12 )) if ( info % solution_change_value < & controls % change_in_solution_tolerance . and . niter > 2 ) & then info % converge_on_solution_change = . true . rst = . true . else info % converge_on_solution_change = . false . end if info % residual_value = X2 / dof if ( info % residual_value < controls % residual_tolerance . and . niter > 2 ) & then info % converge_on_residual_parameter = . true . rst = . true . else info % converge_on_residual_parameter = . false . end if end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_regression.f90.html"},{"title":"fstats_sampling.f90 – FSTATS","text":"Contents Modules fstats_sampling Source Code fstats_sampling.f90 Source Code module fstats_sampling use iso_fortran_env use linalg , only : sort use fstats_distributions implicit none private public :: box_muller_sample public :: rejection_sample public :: sample_normal_multivariate real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) real ( real64 ), parameter :: twopi = 2.0d0 * pi real ( real64 ), parameter :: pi_f = 2.0 * acos ( 0.0 ) real ( real64 ), parameter :: twopi_f = 2.0 * pi_f interface box_muller_sample !! Generates random, normally distributed values via the Box-Muller !! transform. module procedure :: box_muller_sample_scalar module procedure :: box_muller_array end interface contains ! ------------------------------------------------------------------------------ function box_muller_sample_scalar ( mu , sigma ) result ( rst ) !! Generates a pair of independent, standard, normally distributed !! random values using the Box-Muller transform. real ( real64 ), intent ( in ) :: mu !! The mean of the distribution. real ( real64 ), intent ( in ) :: sigma !! The standard deviation of the distribution. real ( real64 ) :: rst ( 2 ) !! The pair of random values. ! Local Variables real ( real64 ) :: u1 , u2 complex ( real64 ) :: z ! Process call random_number ( u1 ) call random_number ( u2 ) z = sqrt ( - 2.0d0 * log ( u1 )) * sigma rst = [ z * cos ( twopi * u2 ) + mu , z * sin ( twopi * u2 ) + mu ] end function ! ------------------------------------------------------------------------------ function box_muller_array ( mu , sigma , n ) result ( rst ) !! Generates an array of normally distributed random values sampled !! by the Box-Muller transform. real ( real64 ), intent ( in ) :: mu !! The mean of the distribution. real ( real64 ), intent ( in ) :: sigma !! The standard deviation of the distribution. integer ( int32 ), intent ( in ) :: n !! The number of Box-Muller pairs to generate. real ( real64 ), allocatable , dimension (:) :: rst !! A 2N-element array containing the N Box-Muller pairs. ! Local Variables integer ( int32 ) :: i ! Process if ( n < 1 ) then allocate ( rst ( 0 )) return end if allocate ( rst ( 2 * n )) do i = 1 , n rst ( 2 * i - 1 : 2 * i ) = box_muller_sample ( mu , sigma ) end do end function ! ****************************************************************************** ! REJECTION SAMPLING ! ------------------------------------------------------------------------------ function rejection_sample ( tdist , n , xmin , xmax ) result ( rst ) !! Uses rejection sampling to randomly sample a target distribution. class ( distribution ), intent ( in ) :: tdist !! The distribution to sample integer ( int32 ), intent ( in ) :: n !! The number of samples to make. real ( real64 ), intent ( in ) :: xmin !! The minimum range to explore. real ( real64 ), intent ( in ) :: xmax !! The maximum range to explore. real ( real64 ), allocatable , dimension (:) :: rst !! An N-element array containing the N samples from the !! distribution. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: c_start = 1.01d0 ! Local Variables integer ( int32 ) :: i , j , jmax real ( real64 ) :: u , c , g , f , rng ! Quick Return if ( n < 1 ) then allocate ( rst ( 0 ), source = zero ) end if ! Process i = 0 j = 0 jmax = min ( 1000 * n , huge ( j )) ! Guard against insanity rng = xmax - xmin c = c_start allocate ( rst ( n ), source = zero ) do while ( i <= n ) ! Update the acceptance threshold call random_number ( u ) ! Sample from the proposal distribution call random_number ( g ) g = g * rng + xmin ! Sample the target distribution f = tdist % pdf ( g ) ! Test if ( u <= f / ( c * g )) then i = i + 1 rst ( i ) = g end if ! Update C c = max ( c , f / g ) ! Update the infinite loop guard variable j = j + 1 if ( j == jmax ) exit end do end function ! ****************************************************************************** ! MULTIVARIATE SAMPLING ! ------------------------------------------------------------------------------ function sample_normal_multivariate ( dist ) result ( rst ) !! Samples a multivariate normal distribution such that \\vec{x} = !! \\vec{mu} + L \\vec{u}, where L is the lower form of the Cholesky !! factorization of the covariance matrix, and \\vec{u} is a randomly !! generated vector that exists on the set [-1 1] class ( multivariate_normal_distribution ), intent ( in ) :: dist !! The multivariate normal distribution to sample. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting vector. ! Local Variables integer ( int32 ) :: n real ( real64 ), allocatable , dimension (:) :: u real ( real64 ), allocatable , dimension (:,:) :: L ! Initialization L = dist % get_cholesky_factored_matrix () n = size ( L , 1 ) allocate ( u ( n )) call random_number ( u ) ! populating u from [0, 1]. u = 2.0d0 * ( u - 0.5d0 ) ! centering u around 0 over the range [-1, 1] ! Process rst = dist % get_means () + matmul ( L , u ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_sampling.f90.html"},{"title":"fstats_smoothing.f90 – FSTATS","text":"Contents Modules fstats_smoothing Source Code fstats_smoothing.f90 Source Code module fstats_smoothing use iso_fortran_env use ferror use fstats_errors use linalg , only : sort implicit none private public :: lowess contains ! ------------------------------------------------------------------------------ subroutine lowess ( x , y , ys , fsmooth , nstps , del , rweights , resid , err ) !! Computes the smoothing of a data set using a robust locally weighted !! scatterplot smoothing (LOWESS) algorithm.  Fitted values are computed at !! each of the supplied x values. !! !! Remarks !! !! The code is a reimplementation of the LOWESS library.  For a detailed !! understanding, see [this] !! (http://www.aliquote.org/cours/2012_biomed/biblio/Cleveland1979.pdf) !! paper by William Cleveland. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the independent variable data.  This !! array must be monotonically increasing. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the dependent variable data. real ( real64 ), intent ( out ), dimension (:) :: ys !! An N-element array where the smoothed results will be written. real ( real64 ), intent ( in ), optional :: fsmooth !! An optional input that specifies the amount of smoothing. !! Specifically, this value is the fraction of points used to compute !! each value.  As this value increases, the output becomes smoother. !! Choosing a value in the range of 0.2 to 0.8 typically results in a !! good fit.  The default value is 0.2. integer ( int32 ), intent ( in ), optional :: nstps !! An optional input that specifies the numb of iterations.  If set to !! zero, a non-robust fit is returned.  The default value is set to 2. real ( real64 ), intent ( in ), optional :: del !! real ( real64 ), intent ( out ), optional , dimension (:), target :: rweights !! An optional N-element array, that if supplied, will be used to !! return the weights given to each data point. real ( real64 ), intent ( out ), optional , dimension (:), target :: resid !! An optional N-element array, that if supplied, will be used to !! return the residual. class ( errors ), intent ( inout ), optional , target :: err !! A mechanism for communicating errors and warnings to the !! caller.  Possible warning and error codes are as follows. !! - FS_NO_ERROR: No errors encountered. !! - FS_ARRAY_SIZE_ERROR: Occurs if any of the arrays are not !!      approriately sized. !! - FS_MEMORY_ERROR: Occurs if there is a memory allocation error. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: p2 = 2.0d-1 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: three = 3.0d0 real ( real64 ), parameter :: p001 = 1.0d-3 real ( real64 ), parameter :: p999 = 0.999d0 ! Local Variables logical :: ok integer ( int32 ) :: iter , i , j , nleft , nright , ns , last , m1 , m2 , n , nsteps , flag real ( real64 ) :: f , delta , d1 , d2 , denom , alpha , cut , eps , cmad , c1 , c9 , r real ( real64 ), allocatable , target , dimension (:) :: rwdef , rsdef real ( real64 ), pointer , dimension (:) :: rw , res class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) if ( present ( fsmooth )) then f = fsmooth else f = p2 end if if ( present ( nstps )) then nsteps = nstps else nsteps = 2 end if if ( present ( del )) then delta = del else delta = 0.0d0 end if if ( present ( rweights )) then if ( size ( rweights ) /= n ) then call report_array_size_error ( errmgr , \"lowess\" , \"rweights\" , n , & size ( rweights )) return end if rw => rweights else allocate ( rwdef ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"lowess\" , flag ) return end if rw => rwdef end if if ( present ( resid )) then if ( size ( resid ) /= n ) then call report_array_size_error ( errmgr , \"lowess\" , \"resid\" , n , & size ( resid )) return end if res => resid else allocate ( rsdef ( n ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( errmgr , \"lowess\" , flag ) return end if res => rsdef end if ns = max ( min ( int ( f * real ( n ), int32 ), n ), 2 ) eps = epsilon ( eps ) ! Input Checking if ( size ( y ) /= n ) then call report_array_size_error ( errmgr , \"lowess\" , \"y\" , n , size ( y )) return end if if ( size ( ys ) /= n ) then call report_array_size_error ( errmgr , \"lowess\" , \"ys\" , n , size ( ys )) return end if ! Quick Return if ( n < 2 ) then ys = y return end if ! Process do iter = 1 , nsteps + 1 nleft = 1 nright = ns last = 0 i = 1 do do while ( nright < n ) d1 = x ( i ) - x ( nleft ) d2 = x ( nright + 1 ) - x ( i ) if ( d1 <= d2 ) exit nleft = nleft + 1 nright = nright + 1 end do call lowest ( x , y , x ( i ), ys ( i ), nleft , nright , res , iter > 1 , & rw , ok ) if (. not . ok ) ys ( i ) = y ( i ) if ( last < i - 1 ) then denom = x ( i ) - x ( last ) do j = last + 1 , i - 1 alpha = ( x ( j ) - x ( last )) / denom ys ( j ) = alpha * ys ( i ) + ( one - alpha ) * ys ( last ) end do end if last = i cut = x ( last ) + delta do i = last + 1 , n if ( x ( i ) > cut ) exit if ( abs ( x ( i ) - x ( last )) < eps ) then ys ( i ) = ys ( last ) last = i end if end do i = max ( last + 1 , i - 1 ) if ( last >= n ) exit end do res = y - ys if ( iter > nsteps ) exit rw = abs ( res ) call sort ( rw , . true .) m1 = 1 + n / 2 m2 = n - m1 + 1 cmad = three * ( rw ( m1 ) + rw ( m2 )) c9 = p999 * cmad c1 = p001 * cmad do i = 1 , n r = abs ( res ( i )) if ( r <= c1 ) then rw ( i ) = one else if ( r > c9 ) then rw ( i ) = zero else rw ( i ) = ( one - ( r / cmad ) ** 2 ) ** 2 end if end do end do end subroutine ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ ! REF: ! - https://en.wikipedia.org/wiki/Local_regression ! - http://www.aliquote.org/cours/2012_biomed/biblio/Cleveland1979.pdf subroutine lowest ( x , y , xs , ys , nleft , nright , w , userw , rw , ok ) ! Arguments real ( real64 ), intent ( in ), dimension (:) :: x , y , rw ! N ELEMENT real ( real64 ), intent ( in ) :: xs real ( real64 ), intent ( out ) :: ys integer ( int32 ), intent ( in ) :: nleft , nright real ( real64 ), intent ( out ), dimension (:) :: w ! N ELEMENT logical , intent ( in ) :: userw logical , intent ( out ) :: ok ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: p001 = 1.0d-3 real ( real64 ), parameter :: p999 = 0.999d0 ! Local Variables integer ( int32 ) :: j , n , nrt real ( real64 ) :: range , h , h9 , h1 , a , b , c , r ! Initialization n = size ( x ) range = x ( n ) - x ( 1 ) h = max ( xs - x ( nleft ), x ( nright ) - xs ) h9 = p999 * h h1 = p001 * h a = zero ! Process do j = nleft , n w ( j ) = zero r = abs ( x ( j ) - xs ) if ( r <= h9 ) then if ( r > h1 ) then w ( j ) = ( one - ( r / h ) ** 3 ) ** 3 else w ( j ) = one end if if ( userw ) w ( j ) = rw ( j ) * w ( j ) a = a + w ( j ) else if ( x ( j ) > xs ) then exit end if end do nrt = j - 1 if ( a <= zero ) then ok = . false . else ok = . true . w ( nleft : nrt ) = w ( nleft : nrt ) / a if ( h > zero ) then a = zero do j = nleft , nrt a = a + w ( j ) * x ( j ) end do b = xs - a c = zero do j = nleft , nrt c = c + w ( j ) * ( x ( j ) - a ) ** 2 end do if ( sqrt ( c ) > p001 * range ) then b = b / c do j = nleft , nrt w ( j ) = w ( j ) * ( one + b * ( x ( j ) - a )) end do end if end if ys = zero do j = nleft , nrt ys = ys + w ( j ) * y ( j ) end do end if end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_smoothing.f90.html"},{"title":"fstats_special_functions.f90 – FSTATS","text":"Contents Modules fstats_special_functions Source Code fstats_special_functions.f90 Source Code module fstats_special_functions use iso_fortran_env use ieee_arithmetic implicit none private public :: beta public :: regularized_beta public :: incomplete_beta public :: incomplete_gamma_lower public :: incomplete_gamma_upper public :: digamma contains ! ------------------------------------------------------------------------------ pure elemental function beta ( a , b ) result ( rst ) !! Computes the beta function. !! !! The beta function is related to the gamma function !! by the following relationship. !!  \\beta(a,b) = \\frac{\\Gamma(a) \\Gamma(b)}{\\Gamma(a + b)} . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function) real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ) :: rst !! The value of the beta function at  a  and  b . ! Process ! REF: https://en.wikipedia.org/wiki/Beta_function rst = exp ( log_gamma ( a ) + log_gamma ( b ) - log_gamma ( a + b )) end function ! ------------------------------------------------------------------------------ ! source: https://people.math.sc.edu/Burkardt/f_src/special_functions/special_functions.f90 pure elemental function regularized_beta ( a , b , x ) result ( rst ) !! Computes the regularized beta function. !! !! The regularized beta function is defined as the ratio between !! the incomplete beta function and the beta function. !!  I_{x}(a,b) = \\frac{\\beta(x;a,b)}{\\beta(a,b)} . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function) real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ), intent ( in ) :: x !! The upper limit of the integration. real ( real64 ) :: rst !! The value of the regularized beta function. ! Local Variables real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: two = 2.0d0 real ( real64 ) :: bt , dk ( 51 ), fk ( 51 ), s0 , t1 , t2 , ta , tb integer ( int32 ) :: k ! Process s0 = ( a + one ) / ( a + b + two ) bt = beta ( a , b ) if ( x <= s0 ) then do k = 1 , 20 dk ( 2 * k ) = k * ( b - k ) * x / ( a + two * k - one ) / ( a + two * k ) end do do k = 0 , 20 dk ( 2 * k + 1 ) = - ( a + k ) * ( a + b + k ) * x / ( a + two * k ) / & ( a + two * k + one ) end do t1 = zero do k = 20 , 1 , - 1 t1 = dk ( k ) / ( one + t1 ) end do ta = one / ( one + t1 ) rst = x ** a * ( one - x ) ** b / ( a * bt ) * ta else do k = 1 , 20 fk ( 2 * k ) = k * ( a - k ) * ( one - x ) / ( b + two * k - one ) / & ( b + two * k ) end do do k = 0 , 20 fk ( 2 * k + 1 ) = - ( b + k ) * ( a + b + k ) * ( one - x ) / ( b + two * k ) / & ( b + two * k + one ) end do t2 = zero do k = 20 , 1 , - 1 t2 = fk ( k ) / ( one + t2 ) end do tb = one / ( one + t2 ) rst = one - x ** a * ( one - x ) ** b / ( b * bt ) * tb end if end function ! ------------------------------------------------------------------------------ pure elemental function incomplete_beta ( a , b , x ) result ( rst ) !! Computes the incomplete beta function. !! !! The incomplete beta function is defind as: !!  \\beta(x;a,b) = \\int_{0}&#94;{x} t&#94;{a-1} (1 - t)&#94;{b-1} dt . !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function) real ( real64 ), intent ( in ) :: a !! The first argument of the function. real ( real64 ), intent ( in ) :: b !! The second argument of the function. real ( real64 ), intent ( in ) :: x !! The upper limit of the integration. real ( real64 ) :: rst !! The value of the incomplete beta function. ! Process rst = beta ( a , b ) * regularized_beta ( a , b , x ) end function ! ------------------------------------------------------------------------------ ! REF: https://people.math.sc.edu/Burkardt/f_src/special_functions/special_functions.f90 pure elemental function incomplete_gamma_upper ( a , x ) result ( rst ) !! Computes the upper incomplete gamma function. !! !! The upper incomplete gamma function is defined as: !!  \\Gamma(a, x) = \\int_{x}&#94;{\\infty} t&#94;{a-1} e&#94;{-t} \\,dt  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Incomplete_gamma_function) real ( real64 ), intent ( in ) :: a !! The coefficient value. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 ! Local Variables real ( real64 ) :: ga , gin , gip , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0d2 . or . a > 1.7d2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = gamma ( a ) else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do gin = exp ( xam ) * s ga = gamma ( a ) gip = gin / ga rst = ga - gin else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do rst = exp ( xam ) / ( x + t0 ) end if end function ! ------------------------------------------------------------------------------ pure elemental function incomplete_gamma_lower ( a , x ) result ( rst ) !! Computes the lower incomplete gamma function. !! !! The lower incomplete gamma function is defined as: !!  \\gamma(a, x) = \\int_{0}&#94;{x} t&#94;{a-1} e&#94;{-t} \\,dt  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Incomplete_gamma_function) real ( real64 ), intent ( in ) :: a !! The coefficient value. real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. ! Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ), parameter :: ten = 1.0d1 ! Local Variables real ( real64 ) :: ga , gim , r , s , t0 , xam , small integer ( int32 ) :: k ! Process small = ten * epsilon ( small ) xam = - x + a * log ( x ) if ( xam > 7.0d2 . or . a > 1.7d2 ) then rst = ieee_value ( rst , IEEE_QUIET_NAN ) return end if if ( x == zero ) then rst = 0.0d0 else if ( x <= one + a ) then s = one / a r = s do k = 1 , 60 r = r * x / ( a + k ) s = s + r if ( abs ( r / s ) < small ) then exit end if end do rst = exp ( xam ) * s else if ( one + a < x ) then t0 = zero do k = 60 , 1 , - 1 t0 = ( k - a ) / ( one + k / ( x + t0 )) end do gim = exp ( xam ) / ( x + t0 ) ga = gamma ( a ) rst = ga - gim end if end function ! ------------------------------------------------------------------------------ pure elemental function digamma ( x ) result ( rst ) !! Computes the digamma function. !! !! The digamma function is defined as: !!  \\psi(x) = !! \\frac{d}{dx}\\left( \\ln \\left( \\Gamma \\left( x \\right) \\right) !! \\right)  !! !! See Also !! !! - [Wikipedia](https://en.wikipedia.org/wiki/Digamma_function) real ( real64 ), intent ( in ) :: x !! The value at which to evaluate the function. real ( real64 ) :: rst !! The function value. ! Parameters real ( real64 ), parameter :: c = 8.5d0 real ( real64 ), parameter :: euler_mascheroni = 0.57721566490153286060d0 ! Local Variables real ( real64 ) :: r , x2 , nan ! REF: ! - https://people.sc.fsu.edu/~jburkardt/f_src/asa103/asa103.f90 ! If x <= 0.0 if ( x <= 0.0 ) then nan = ieee_value ( nan , IEEE_QUIET_NAN ) rst = nan return end if ! Approximation for a small argument if ( x <= 1.0d-6 ) then rst = - euler_mascheroni - 1.0d0 / x + 1.6449340668482264365d0 * x return end if ! Process rst = 0.0d0 x2 = x do while ( x2 < c ) rst = rst - 1.0d0 / x2 x2 = x2 + 1.0d0 end do r = 1.0d0 / x2 rst = rst + log ( x2 ) - 0.5d0 * r r = r * r rst = rst & - r * ( 1.0d0 / 1 2.0d0 & - r * ( 1.0d0 / 12 0.0d0 & - r * ( 1.0d0 / 25 2.0d0 & - r * ( 1.0d0 / 24 0.0d0 & - r * ( 1.0d0 / 13 2.0d0 ) & )))) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\fstats_special_functions.f90.html"},{"title":"fstats_types.f90 – FSTATS","text":"Contents Modules fstats_types Source Code fstats_types.f90 Source Code module fstats_types use iso_fortran_env implicit none type array_container !! Provides a container for a real-valued array.  A practical use of !! this construct is in the construction of jagged arrays. real ( real64 ), allocatable , dimension (:) :: x !! The array. end type end module","tags":"","loc":"sourcefile\\fstats_types.f90.html"}]}